<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
            <title>Plan report</title>
            <meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src vscode-resource: https: data:; script-src vscode-resource: https://www.gstatic.com/charts/ 'unsafe-inline'; style-src vscode-resource: https://www.gstatic.com/charts/ 'unsafe-inline';">    
            <style>
div.gantt {
    position: relative;
    margin: 5px;
}

div.planstep {
    position: absolute;
    white-space: pre;
    display: inline-flex;
    font-family: sans-serif;
    align-items: center;
}

div.planstep-bar {
    background-color: darkgray;
    height: 15px;
    margin: 3px;
    margin-left: 0px;
    margin-right: 0px;
    min-width: 1px;
}

div.planstep-bar-relaxed {
    background-color: darkgray;
    height: 15px;
    margin: 3px;
    margin-left: 0px;
}

span.error {
    color: red;
    text-overflow: ellipsis;
}

a:link {
    text-decoration: none;
}

a:visited {
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

a:active {
    text-decoration: underline;
}

.planSelector {
    margin: 3px;
    width: 50px;
    text-align: center;
    padding: 1px;
    border: transparent 2px solid;
    font-family: sans-serif;
}

.planSelector-selected {
    border: 2px solid lightgray;
}

.planSelector:hover {
    border: 2px solid darkgray;
}

.planMetricBar {
    background-color: lightgreen;
}

.planSelectors {
    margin: 5px;
    display: flex;
    align-items: flex-end;
    overflow: auto;
}

th, td {
    border-bottom: 1px solid #ddd;
    text-align: left;
}

a.action {
    cursor: pointer;
}

td.objectName {
    vertical-align: baseline;
}

th.actionToolTip, td.actionToolTip {
    border-bottom-style: none;
}

/* https://iros.github.io/patternfills/sample_css.html */

.whitecarbon {
    background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHhtbG5zOnhsaW5rPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyB3aWR0aD0nNicgaGVpZ2h0PSc2Jz4KICA8cmVjdCB3aWR0aD0nNicgaGVpZ2h0PSc2JyBmaWxsPScjZWVlZWVlJy8+CiAgPGcgaWQ9J2MnPgogICAgPHJlY3Qgd2lkdGg9JzMnIGhlaWdodD0nMycgZmlsbD0nI2U2ZTZlNicvPgogICAgPHJlY3QgeT0nMScgd2lkdGg9JzMnIGhlaWdodD0nMicgZmlsbD0nI2Q4ZDhkOCcvPgogIDwvZz4KICA8dXNlIHhsaW5rOmhyZWY9JyNjJyB4PSczJyB5PSczJy8+Cjwvc3ZnPg==");
    background-repeat: repeat;
}

/* CHARTS */

div.lineCharts {
    /* ensure it is visible, when scrolling to it */
    min-height: 100px;
    margin-top: 20px;
    display: inline-block; /* to ensure the loader is considered in viewport even if the plan is wider than the viewport */
}

/* SPINNING LOADER */

.loader {
    border: 5px solid #f3f3f3;
    border-radius: 50%;
    opacity: 0.75;
    border-top: 5px solid blue;
    border-right: 5px solid green;
    border-bottom: 5px solid red;
    width: 30px;
    height: 30px;
    display: inline-block; /* to ensure the loader is considered in viewport even if the plan is wider than the viewport */
    -webkit-animation: spin 2s linear infinite;
    animation: spin 2s linear infinite;
}

@-webkit-keyframes spin {
    0% {
        -webkit-transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(360deg);
    }
}

@keyframes spin {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(360deg);
    }
}

/* RESOURCE SWIM-LANE BARS */

/* Tooltip container */
.resourceTaskTooltip {
    white-space: nowrap; 
    overflow: hidden;
    text-overflow: ellipsis; 
    position: absolute;
}

/* We need to unhide the overflow, so the tooltip has something to show : ( */
.resourceTaskTooltip:hover {
    overflow: visible;
    text-overflow: unset; 
}

/* Tooltip text */
.resourceTaskTooltip .resourceTaskTooltipText {
    visibility: hidden;
    /* width: 120px; */
    background-color: black;
    color: #fff;
    text-align: center;
    padding: 5px;
    border-radius: 3px;
 
    position: absolute;
    z-index: 1;

    bottom: 150%;
    left: 50%;
    margin-left: -60px;
}

.resourceTaskTooltip .resourceTaskTooltipText::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: black transparent transparent transparent;
}

/* Show the tooltip text when you mouse over the tooltip container */
.resourceTaskTooltip:hover .resourceTaskTooltipText {
    visibility: visible;
}

#diamond-narrow {
	width: 0;
	height: 0;
	border: 3px solid transparent;
	border-bottom: 7.5px solid red;
	position: relative;
	top: -3px;
}
#diamond-narrow:after {
	content: '';
	position: absolute;
	left: -3px; top: 7.5px;
	width: 0;
	height: 0;
	border: 3px solid transparent;
	border-top: 7.5px solid red;
}
</style>
            <style>

div.plans {
    width: 100%;
}

/* MENU */

.menu {
    display: inline-block;
    font-size: 200%;
    position: fixed;
    z-index: 10;
    top: 0;
    right: 0;
    cursor: pointer;
}


div.iconBar {
    margin: 3px;
}
div.iconBar .codicon {
    font-size: 25px;
    cursor: pointer;
}

/* WARNINGS AND HINTS */

a#downloadVal {
    margin-top: 10px;
    visibility: collapse;
}

div.hint {
    opacity: 60%;
    visibility: collapse;
}

div.error {
    color: red;
    visibility: collapse;
}
</style>
            <script>
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process,setImmediate){(function (){
/*! Browser bundle of nunjucks 3.2.3  */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["nunjucks"] = factory();
	else
		root["nunjucks"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var escapeMap = {
  '&': '&amp;',
  '"': '&quot;',
  '\'': '&#39;',
  '<': '&lt;',
  '>': '&gt;'
};
var escapeRegex = /[&"'<>]/g;
var exports = module.exports = {};

function hasOwnProp(obj, k) {
  return ObjProto.hasOwnProperty.call(obj, k);
}

exports.hasOwnProp = hasOwnProp;

function lookupEscape(ch) {
  return escapeMap[ch];
}

function _prettifyError(path, withInternals, err) {
  if (!err.Update) {
    // not one of ours, cast it
    err = new exports.TemplateError(err);
  }

  err.Update(path); // Unless they marked the dev flag, show them a trace from here

  if (!withInternals) {
    var old = err;
    err = new Error(old.message);
    err.name = old.name;
  }

  return err;
}

exports._prettifyError = _prettifyError;

function TemplateError(message, lineno, colno) {
  var err;
  var cause;

  if (message instanceof Error) {
    cause = message;
    message = cause.name + ": " + cause.message;
  }

  if (Object.setPrototypeOf) {
    err = new Error(message);
    Object.setPrototypeOf(err, TemplateError.prototype);
  } else {
    err = this;
    Object.defineProperty(err, 'message', {
      enumerable: false,
      writable: true,
      value: message
    });
  }

  Object.defineProperty(err, 'name', {
    value: 'Template render error'
  });

  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, this.constructor);
  }

  var getStack;

  if (cause) {
    var stackDescriptor = Object.getOwnPropertyDescriptor(cause, 'stack');

    getStack = stackDescriptor && (stackDescriptor.get || function () {
      return stackDescriptor.value;
    });

    if (!getStack) {
      getStack = function getStack() {
        return cause.stack;
      };
    }
  } else {
    var stack = new Error(message).stack;

    getStack = function getStack() {
      return stack;
    };
  }

  Object.defineProperty(err, 'stack', {
    get: function get() {
      return getStack.call(err);
    }
  });
  Object.defineProperty(err, 'cause', {
    value: cause
  });
  err.lineno = lineno;
  err.colno = colno;
  err.firstUpdate = true;

  err.Update = function Update(path) {
    var msg = '(' + (path || 'unknown path') + ')'; // only show lineno + colno next to path of template
    // where error occurred

    if (this.firstUpdate) {
      if (this.lineno && this.colno) {
        msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
      } else if (this.lineno) {
        msg += " [Line " + this.lineno + "]";
      }
    }

    msg += '\n ';

    if (this.firstUpdate) {
      msg += ' ';
    }

    this.message = msg + (this.message || '');
    this.firstUpdate = false;
    return this;
  };

  return err;
}

if (Object.setPrototypeOf) {
  Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
} else {
  TemplateError.prototype = Object.create(Error.prototype, {
    constructor: {
      value: TemplateError
    }
  });
}

exports.TemplateError = TemplateError;

function escape(val) {
  return val.replace(escapeRegex, lookupEscape);
}

exports.escape = escape;

function isFunction(obj) {
  return ObjProto.toString.call(obj) === '[object Function]';
}

exports.isFunction = isFunction;

function isArray(obj) {
  return ObjProto.toString.call(obj) === '[object Array]';
}

exports.isArray = isArray;

function isString(obj) {
  return ObjProto.toString.call(obj) === '[object String]';
}

exports.isString = isString;

function isObject(obj) {
  return ObjProto.toString.call(obj) === '[object Object]';
}

exports.isObject = isObject;
/**
 * @param {string|number} attr
 * @returns {(string|number)[]}
 * @private
 */

function _prepareAttributeParts(attr) {
  if (!attr) {
    return [];
  }

  if (typeof attr === 'string') {
    return attr.split('.');
  }

  return [attr];
}
/**
 * @param {string}   attribute      Attribute value. Dots allowed.
 * @returns {function(Object): *}
 */


function getAttrGetter(attribute) {
  var parts = _prepareAttributeParts(attribute);

  return function attrGetter(item) {
    var _item = item;

    for (var i = 0; i < parts.length; i++) {
      var part = parts[i]; // If item is not an object, and we still got parts to handle, it means
      // that something goes wrong. Just roll out to undefined in that case.

      if (hasOwnProp(_item, part)) {
        _item = _item[part];
      } else {
        return undefined;
      }
    }

    return _item;
  };
}

exports.getAttrGetter = getAttrGetter;

function groupBy(obj, val, throwOnUndefined) {
  var result = {};
  var iterator = isFunction(val) ? val : getAttrGetter(val);

  for (var i = 0; i < obj.length; i++) {
    var value = obj[i];
    var key = iterator(value, i);

    if (key === undefined && throwOnUndefined === true) {
      throw new TypeError("groupby: attribute \"" + val + "\" resolved to undefined");
    }

    (result[key] || (result[key] = [])).push(value);
  }

  return result;
}

exports.groupBy = groupBy;

function toArray(obj) {
  return Array.prototype.slice.call(obj);
}

exports.toArray = toArray;

function without(array) {
  var result = [];

  if (!array) {
    return result;
  }

  var length = array.length;
  var contains = toArray(arguments).slice(1);
  var index = -1;

  while (++index < length) {
    if (indexOf(contains, array[index]) === -1) {
      result.push(array[index]);
    }
  }

  return result;
}

exports.without = without;

function repeat(char_, n) {
  var str = '';

  for (var i = 0; i < n; i++) {
    str += char_;
  }

  return str;
}

exports.repeat = repeat;

function each(obj, func, context) {
  if (obj == null) {
    return;
  }

  if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
    obj.forEach(func, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, l = obj.length; i < l; i++) {
      func.call(context, obj[i], i, obj);
    }
  }
}

exports.each = each;

function map(obj, func) {
  var results = [];

  if (obj == null) {
    return results;
  }

  if (ArrayProto.map && obj.map === ArrayProto.map) {
    return obj.map(func);
  }

  for (var i = 0; i < obj.length; i++) {
    results[results.length] = func(obj[i], i);
  }

  if (obj.length === +obj.length) {
    results.length = obj.length;
  }

  return results;
}

exports.map = map;

function asyncIter(arr, iter, cb) {
  var i = -1;

  function next() {
    i++;

    if (i < arr.length) {
      iter(arr[i], i, next, cb);
    } else {
      cb();
    }
  }

  next();
}

exports.asyncIter = asyncIter;

function asyncFor(obj, iter, cb) {
  var keys = keys_(obj || {});
  var len = keys.length;
  var i = -1;

  function next() {
    i++;
    var k = keys[i];

    if (i < len) {
      iter(k, obj[k], i, len, next);
    } else {
      cb();
    }
  }

  next();
}

exports.asyncFor = asyncFor;

function indexOf(arr, searchElement, fromIndex) {
  return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
}

exports.indexOf = indexOf;

function keys_(obj) {
  /* eslint-disable no-restricted-syntax */
  var arr = [];

  for (var k in obj) {
    if (hasOwnProp(obj, k)) {
      arr.push(k);
    }
  }

  return arr;
}

exports.keys = keys_;

function _entries(obj) {
  return keys_(obj).map(function (k) {
    return [k, obj[k]];
  });
}

exports._entries = _entries;

function _values(obj) {
  return keys_(obj).map(function (k) {
    return obj[k];
  });
}

exports._values = _values;

function extend(obj1, obj2) {
  obj1 = obj1 || {};
  keys_(obj2).forEach(function (k) {
    obj1[k] = obj2[k];
  });
  return obj1;
}

exports._assign = exports.extend = extend;

function inOperator(key, val) {
  if (isArray(val) || isString(val)) {
    return val.indexOf(key) !== -1;
  } else if (isObject(val)) {
    return key in val;
  }

  throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
}

exports.inOperator = inOperator;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // A simple class system, more documentation to come

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = __webpack_require__(16);

var lib = __webpack_require__(0);

function parentWrap(parent, prop) {
  if (typeof parent !== 'function' || typeof prop !== 'function') {
    return prop;
  }

  return function wrap() {
    // Save the current parent method
    var tmp = this.parent; // Set parent to the previous method, call, and restore

    this.parent = parent;
    var res = prop.apply(this, arguments);
    this.parent = tmp;
    return res;
  };
}

function extendClass(cls, name, props) {
  props = props || {};
  lib.keys(props).forEach(function (k) {
    props[k] = parentWrap(cls.prototype[k], props[k]);
  });

  var subclass = /*#__PURE__*/function (_cls) {
    _inheritsLoose(subclass, _cls);

    function subclass() {
      return _cls.apply(this, arguments) || this;
    }

    _createClass(subclass, [{
      key: "typename",
      get: function get() {
        return name;
      }
    }]);

    return subclass;
  }(cls);

  lib._assign(subclass.prototype, props);

  return subclass;
}

var Obj = /*#__PURE__*/function () {
  function Obj() {
    // Unfortunately necessary for backwards compatibility
    this.init.apply(this, arguments);
  }

  var _proto = Obj.prototype;

  _proto.init = function init() {};

  Obj.extend = function extend(name, props) {
    if (typeof name === 'object') {
      props = name;
      name = 'anonymous';
    }

    return extendClass(this, name, props);
  };

  _createClass(Obj, [{
    key: "typename",
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return Obj;
}();

var EmitterObj = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(EmitterObj, _EventEmitter);

  function EmitterObj() {
    var _this2;

    var _this;

    _this = _EventEmitter.call(this) || this; // Unfortunately necessary for backwards compatibility

    (_this2 = _this).init.apply(_this2, arguments);

    return _this;
  }

  var _proto2 = EmitterObj.prototype;

  _proto2.init = function init() {};

  EmitterObj.extend = function extend(name, props) {
    if (typeof name === 'object') {
      props = name;
      name = 'anonymous';
    }

    return extendClass(this, name, props);
  };

  _createClass(EmitterObj, [{
    key: "typename",
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return EmitterObj;
}(EventEmitter);

module.exports = {
  Obj: Obj,
  EmitterObj: EmitterObj
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var lib = __webpack_require__(0);

var arrayFrom = Array.from;
var supportsIterators = typeof Symbol === 'function' && Symbol.iterator && typeof arrayFrom === 'function'; // Frames keep track of scoping both at compile-time and run-time so
// we know how to access variables. Block tags can introduce special
// variables, for example.

var Frame = /*#__PURE__*/function () {
  function Frame(parent, isolateWrites) {
    this.variables = Object.create(null);
    this.parent = parent;
    this.topLevel = false; // if this is true, writes (set) should never propagate upwards past
    // this frame to its parent (though reads may).

    this.isolateWrites = isolateWrites;
  }

  var _proto = Frame.prototype;

  _proto.set = function set(name, val, resolveUp) {
    // Allow variables with dots by automatically creating the
    // nested structure
    var parts = name.split('.');
    var obj = this.variables;
    var frame = this;

    if (resolveUp) {
      if (frame = this.resolve(parts[0], true)) {
        frame.set(name, val);
        return;
      }
    }

    for (var i = 0; i < parts.length - 1; i++) {
      var id = parts[i];

      if (!obj[id]) {
        obj[id] = {};
      }

      obj = obj[id];
    }

    obj[parts[parts.length - 1]] = val;
  };

  _proto.get = function get(name) {
    var val = this.variables[name];

    if (val !== undefined) {
      return val;
    }

    return null;
  };

  _proto.lookup = function lookup(name) {
    var p = this.parent;
    var val = this.variables[name];

    if (val !== undefined) {
      return val;
    }

    return p && p.lookup(name);
  };

  _proto.resolve = function resolve(name, forWrite) {
    var p = forWrite && this.isolateWrites ? undefined : this.parent;
    var val = this.variables[name];

    if (val !== undefined) {
      return this;
    }

    return p && p.resolve(name);
  };

  _proto.push = function push(isolateWrites) {
    return new Frame(this, isolateWrites);
  };

  _proto.pop = function pop() {
    return this.parent;
  };

  return Frame;
}();

function makeMacro(argNames, kwargNames, func) {
  return function macro() {
    for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      macroArgs[_key] = arguments[_key];
    }

    var argCount = numArgs(macroArgs);
    var args;
    var kwargs = getKeywordArgs(macroArgs);

    if (argCount > argNames.length) {
      args = macroArgs.slice(0, argNames.length); // Positional arguments that should be passed in as
      // keyword arguments (essentially default values)

      macroArgs.slice(args.length, argCount).forEach(function (val, i) {
        if (i < kwargNames.length) {
          kwargs[kwargNames[i]] = val;
        }
      });
      args.push(kwargs);
    } else if (argCount < argNames.length) {
      args = macroArgs.slice(0, argCount);

      for (var i = argCount; i < argNames.length; i++) {
        var arg = argNames[i]; // Keyword arguments that should be passed as
        // positional arguments, i.e. the caller explicitly
        // used the name of a positional arg

        args.push(kwargs[arg]);
        delete kwargs[arg];
      }

      args.push(kwargs);
    } else {
      args = macroArgs;
    }

    return func.apply(this, args);
  };
}

function makeKeywordArgs(obj) {
  obj.__keywords = true;
  return obj;
}

function isKeywordArgs(obj) {
  return obj && Object.prototype.hasOwnProperty.call(obj, '__keywords');
}

function getKeywordArgs(args) {
  var len = args.length;

  if (len) {
    var lastArg = args[len - 1];

    if (isKeywordArgs(lastArg)) {
      return lastArg;
    }
  }

  return {};
}

function numArgs(args) {
  var len = args.length;

  if (len === 0) {
    return 0;
  }

  var lastArg = args[len - 1];

  if (isKeywordArgs(lastArg)) {
    return len - 1;
  } else {
    return len;
  }
} // A SafeString object indicates that the string should not be
// autoescaped. This happens magically because autoescaping only
// occurs on primitive string objects.


function SafeString(val) {
  if (typeof val !== 'string') {
    return val;
  }

  this.val = val;
  this.length = val.length;
}

SafeString.prototype = Object.create(String.prototype, {
  length: {
    writable: true,
    configurable: true,
    value: 0
  }
});

SafeString.prototype.valueOf = function valueOf() {
  return this.val;
};

SafeString.prototype.toString = function toString() {
  return this.val;
};

function copySafeness(dest, target) {
  if (dest instanceof SafeString) {
    return new SafeString(target);
  }

  return target.toString();
}

function markSafe(val) {
  var type = typeof val;

  if (type === 'string') {
    return new SafeString(val);
  } else if (type !== 'function') {
    return val;
  } else {
    return function wrapSafe(args) {
      var ret = val.apply(this, arguments);

      if (typeof ret === 'string') {
        return new SafeString(ret);
      }

      return ret;
    };
  }
}

function suppressValue(val, autoescape) {
  val = val !== undefined && val !== null ? val : '';

  if (autoescape && !(val instanceof SafeString)) {
    val = lib.escape(val.toString());
  }

  return val;
}

function ensureDefined(val, lineno, colno) {
  if (val === null || val === undefined) {
    throw new lib.TemplateError('attempted to output null or undefined value', lineno + 1, colno + 1);
  }

  return val;
}

function memberLookup(obj, val) {
  if (obj === undefined || obj === null) {
    return undefined;
  }

  if (typeof obj[val] === 'function') {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return obj[val].apply(obj, args);
    };
  }

  return obj[val];
}

function callWrap(obj, name, context, args) {
  if (!obj) {
    throw new Error('Unable to call `' + name + '`, which is undefined or falsey');
  } else if (typeof obj !== 'function') {
    throw new Error('Unable to call `' + name + '`, which is not a function');
  }

  return obj.apply(context, args);
}

function contextOrFrameLookup(context, frame, name) {
  var val = frame.lookup(name);
  return val !== undefined ? val : context.lookup(name);
}

function handleError(error, lineno, colno) {
  if (error.lineno) {
    return error;
  } else {
    return new lib.TemplateError(error, lineno, colno);
  }
}

function asyncEach(arr, dimen, iter, cb) {
  if (lib.isArray(arr)) {
    var len = arr.length;
    lib.asyncIter(arr, function iterCallback(item, i, next) {
      switch (dimen) {
        case 1:
          iter(item, i, len, next);
          break;

        case 2:
          iter(item[0], item[1], i, len, next);
          break;

        case 3:
          iter(item[0], item[1], item[2], i, len, next);
          break;

        default:
          item.push(i, len, next);
          iter.apply(this, item);
      }
    }, cb);
  } else {
    lib.asyncFor(arr, function iterCallback(key, val, i, len, next) {
      iter(key, val, i, len, next);
    }, cb);
  }
}

function asyncAll(arr, dimen, func, cb) {
  var finished = 0;
  var len;
  var outputArr;

  function done(i, output) {
    finished++;
    outputArr[i] = output;

    if (finished === len) {
      cb(null, outputArr.join(''));
    }
  }

  if (lib.isArray(arr)) {
    len = arr.length;
    outputArr = new Array(len);

    if (len === 0) {
      cb(null, '');
    } else {
      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];

        switch (dimen) {
          case 1:
            func(item, i, len, done);
            break;

          case 2:
            func(item[0], item[1], i, len, done);
            break;

          case 3:
            func(item[0], item[1], item[2], i, len, done);
            break;

          default:
            item.push(i, len, done);
            func.apply(this, item);
        }
      }
    }
  } else {
    var keys = lib.keys(arr || {});
    len = keys.length;
    outputArr = new Array(len);

    if (len === 0) {
      cb(null, '');
    } else {
      for (var _i = 0; _i < keys.length; _i++) {
        var k = keys[_i];
        func(k, arr[k], _i, len, done);
      }
    }
  }
}

function fromIterator(arr) {
  if (typeof arr !== 'object' || arr === null || lib.isArray(arr)) {
    return arr;
  } else if (supportsIterators && Symbol.iterator in arr) {
    return arrayFrom(arr);
  } else {
    return arr;
  }
}

module.exports = {
  Frame: Frame,
  makeMacro: makeMacro,
  makeKeywordArgs: makeKeywordArgs,
  numArgs: numArgs,
  suppressValue: suppressValue,
  ensureDefined: ensureDefined,
  memberLookup: memberLookup,
  contextOrFrameLookup: contextOrFrameLookup,
  callWrap: callWrap,
  handleError: handleError,
  isArray: lib.isArray,
  keys: lib.keys,
  SafeString: SafeString,
  copySafeness: copySafeness,
  markSafe: markSafe,
  asyncEach: asyncEach,
  asyncAll: asyncAll,
  inOperator: lib.inOperator,
  fromIterator: fromIterator
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = __webpack_require__(1),
    Obj = _require.Obj;

function traverseAndCheck(obj, type, results) {
  if (obj instanceof type) {
    results.push(obj);
  }

  if (obj instanceof Node) {
    obj.findAll(type, results);
  }
}

var Node = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Node, _Obj);

  function Node() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Node.prototype;

  _proto.init = function init(lineno, colno) {
    var _arguments = arguments,
        _this = this;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.lineno = lineno;
    this.colno = colno;
    this.fields.forEach(function (field, i) {
      // The first two args are line/col numbers, so offset by 2
      var val = _arguments[i + 2]; // Fields should never be undefined, but null. It makes
      // testing easier to normalize values.

      if (val === undefined) {
        val = null;
      }

      _this[field] = val;
    });
  };

  _proto.findAll = function findAll(type, results) {
    var _this2 = this;

    results = results || [];

    if (this instanceof NodeList) {
      this.children.forEach(function (child) {
        return traverseAndCheck(child, type, results);
      });
    } else {
      this.fields.forEach(function (field) {
        return traverseAndCheck(_this2[field], type, results);
      });
    }

    return results;
  };

  _proto.iterFields = function iterFields(func) {
    var _this3 = this;

    this.fields.forEach(function (field) {
      func(_this3[field], field);
    });
  };

  return Node;
}(Obj); // Abstract nodes


var Value = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Value, _Node);

  function Value() {
    return _Node.apply(this, arguments) || this;
  }

  _createClass(Value, [{
    key: "typename",
    get: function get() {
      return 'Value';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['value'];
    }
  }]);

  return Value;
}(Node); // Concrete nodes


var NodeList = /*#__PURE__*/function (_Node2) {
  _inheritsLoose(NodeList, _Node2);

  function NodeList() {
    return _Node2.apply(this, arguments) || this;
  }

  var _proto2 = NodeList.prototype;

  _proto2.init = function init(lineno, colno, nodes) {
    _Node2.prototype.init.call(this, lineno, colno, nodes || []);
  };

  _proto2.addChild = function addChild(node) {
    this.children.push(node);
  };

  _createClass(NodeList, [{
    key: "typename",
    get: function get() {
      return 'NodeList';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['children'];
    }
  }]);

  return NodeList;
}(Node);

var Root = NodeList.extend('Root');
var Literal = Value.extend('Literal');
var Symbol = Value.extend('Symbol');
var Group = NodeList.extend('Group');
var ArrayNode = NodeList.extend('Array');
var Pair = Node.extend('Pair', {
  fields: ['key', 'value']
});
var Dict = NodeList.extend('Dict');
var LookupVal = Node.extend('LookupVal', {
  fields: ['target', 'val']
});
var If = Node.extend('If', {
  fields: ['cond', 'body', 'else_']
});
var IfAsync = If.extend('IfAsync');
var InlineIf = Node.extend('InlineIf', {
  fields: ['cond', 'body', 'else_']
});
var For = Node.extend('For', {
  fields: ['arr', 'name', 'body', 'else_']
});
var AsyncEach = For.extend('AsyncEach');
var AsyncAll = For.extend('AsyncAll');
var Macro = Node.extend('Macro', {
  fields: ['name', 'args', 'body']
});
var Caller = Macro.extend('Caller');
var Import = Node.extend('Import', {
  fields: ['template', 'target', 'withContext']
});

var FromImport = /*#__PURE__*/function (_Node3) {
  _inheritsLoose(FromImport, _Node3);

  function FromImport() {
    return _Node3.apply(this, arguments) || this;
  }

  var _proto3 = FromImport.prototype;

  _proto3.init = function init(lineno, colno, template, names, withContext) {
    _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
  };

  _createClass(FromImport, [{
    key: "typename",
    get: function get() {
      return 'FromImport';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['template', 'names', 'withContext'];
    }
  }]);

  return FromImport;
}(Node);

var FunCall = Node.extend('FunCall', {
  fields: ['name', 'args']
});
var Filter = FunCall.extend('Filter');
var FilterAsync = Filter.extend('FilterAsync', {
  fields: ['name', 'args', 'symbol']
});
var KeywordArgs = Dict.extend('KeywordArgs');
var Block = Node.extend('Block', {
  fields: ['name', 'body']
});
var Super = Node.extend('Super', {
  fields: ['blockName', 'symbol']
});
var TemplateRef = Node.extend('TemplateRef', {
  fields: ['template']
});
var Extends = TemplateRef.extend('Extends');
var Include = Node.extend('Include', {
  fields: ['template', 'ignoreMissing']
});
var Set = Node.extend('Set', {
  fields: ['targets', 'value']
});
var Switch = Node.extend('Switch', {
  fields: ['expr', 'cases', 'default']
});
var Case = Node.extend('Case', {
  fields: ['cond', 'body']
});
var Output = NodeList.extend('Output');
var Capture = Node.extend('Capture', {
  fields: ['body']
});
var TemplateData = Literal.extend('TemplateData');
var UnaryOp = Node.extend('UnaryOp', {
  fields: ['target']
});
var BinOp = Node.extend('BinOp', {
  fields: ['left', 'right']
});
var In = BinOp.extend('In');
var Is = BinOp.extend('Is');
var Or = BinOp.extend('Or');
var And = BinOp.extend('And');
var Not = UnaryOp.extend('Not');
var Add = BinOp.extend('Add');
var Concat = BinOp.extend('Concat');
var Sub = BinOp.extend('Sub');
var Mul = BinOp.extend('Mul');
var Div = BinOp.extend('Div');
var FloorDiv = BinOp.extend('FloorDiv');
var Mod = BinOp.extend('Mod');
var Pow = BinOp.extend('Pow');
var Neg = UnaryOp.extend('Neg');
var Pos = UnaryOp.extend('Pos');
var Compare = Node.extend('Compare', {
  fields: ['expr', 'ops']
});
var CompareOperand = Node.extend('CompareOperand', {
  fields: ['expr', 'type']
});
var CallExtension = Node.extend('CallExtension', {
  init: function init(ext, prop, args, contentArgs) {
    this.parent();
    this.extName = ext.__name || ext;
    this.prop = prop;
    this.args = args || new NodeList();
    this.contentArgs = contentArgs || [];
    this.autoescape = ext.autoescape;
  },
  fields: ['extName', 'prop', 'args', 'contentArgs']
});
var CallExtensionAsync = CallExtension.extend('CallExtensionAsync'); // This is hacky, but this is just a debugging function anyway

function print(str, indent, inline) {
  var lines = str.split('\n');
  lines.forEach(function (line, i) {
    if (line && (inline && i > 0 || !inline)) {
      process.stdout.write(' '.repeat(indent));
    }

    var nl = i === lines.length - 1 ? '' : '\n';
    process.stdout.write("" + line + nl);
  });
} // Print the AST in a nicely formatted tree format for debuggin


function printNodes(node, indent) {
  indent = indent || 0;
  print(node.typename + ': ', indent);

  if (node instanceof NodeList) {
    print('\n');
    node.children.forEach(function (n) {
      printNodes(n, indent + 2);
    });
  } else if (node instanceof CallExtension) {
    print(node.extName + "." + node.prop + "\n");

    if (node.args) {
      printNodes(node.args, indent + 2);
    }

    if (node.contentArgs) {
      node.contentArgs.forEach(function (n) {
        printNodes(n, indent + 2);
      });
    }
  } else {
    var nodes = [];
    var props = null;
    node.iterFields(function (val, fieldName) {
      if (val instanceof Node) {
        nodes.push([fieldName, val]);
      } else {
        props = props || {};
        props[fieldName] = val;
      }
    });

    if (props) {
      print(JSON.stringify(props, null, 2) + '\n', null, true);
    } else {
      print('\n');
    }

    nodes.forEach(function (_ref) {
      var fieldName = _ref[0],
          n = _ref[1];
      print("[" + fieldName + "] =>", indent + 2);
      printNodes(n, indent + 4);
    });
  }
}

module.exports = {
  Node: Node,
  Root: Root,
  NodeList: NodeList,
  Value: Value,
  Literal: Literal,
  Symbol: Symbol,
  Group: Group,
  Array: ArrayNode,
  Pair: Pair,
  Dict: Dict,
  Output: Output,
  Capture: Capture,
  TemplateData: TemplateData,
  If: If,
  IfAsync: IfAsync,
  InlineIf: InlineIf,
  For: For,
  AsyncEach: AsyncEach,
  AsyncAll: AsyncAll,
  Macro: Macro,
  Caller: Caller,
  Import: Import,
  FromImport: FromImport,
  FunCall: FunCall,
  Filter: Filter,
  FilterAsync: FilterAsync,
  KeywordArgs: KeywordArgs,
  Block: Block,
  Super: Super,
  Extends: Extends,
  Include: Include,
  Set: Set,
  Switch: Switch,
  Case: Case,
  LookupVal: LookupVal,
  BinOp: BinOp,
  In: In,
  Is: Is,
  Or: Or,
  And: And,
  Not: Not,
  Add: Add,
  Concat: Concat,
  Sub: Sub,
  Mul: Mul,
  Div: Div,
  FloorDiv: FloorDiv,
  Mod: Mod,
  Pow: Pow,
  Neg: Neg,
  Pos: Pos,
  Compare: Compare,
  CompareOperand: CompareOperand,
  CallExtension: CallExtension,
  CallExtensionAsync: CallExtensionAsync,
  printNodes: printNodes
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {



/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var parser = __webpack_require__(8);

var transformer = __webpack_require__(17);

var nodes = __webpack_require__(3);

var _require = __webpack_require__(0),
    TemplateError = _require.TemplateError;

var _require2 = __webpack_require__(2),
    Frame = _require2.Frame;

var _require3 = __webpack_require__(1),
    Obj = _require3.Obj; // These are all the same for now, but shouldn't be passed straight
// through


var compareOps = {
  '==': '==',
  '===': '===',
  '!=': '!=',
  '!==': '!==',
  '<': '<',
  '>': '>',
  '<=': '<=',
  '>=': '>='
};

var Compiler = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Compiler, _Obj);

  function Compiler() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Compiler.prototype;

  _proto.init = function init(templateName, throwOnUndefined) {
    this.templateName = templateName;
    this.codebuf = [];
    this.lastId = 0;
    this.buffer = null;
    this.bufferStack = [];
    this._scopeClosers = '';
    this.inBlock = false;
    this.throwOnUndefined = throwOnUndefined;
  };

  _proto.fail = function fail(msg, lineno, colno) {
    if (lineno !== undefined) {
      lineno += 1;
    }

    if (colno !== undefined) {
      colno += 1;
    }

    throw new TemplateError(msg, lineno, colno);
  };

  _proto._pushBuffer = function _pushBuffer() {
    var id = this._tmpid();

    this.bufferStack.push(this.buffer);
    this.buffer = id;

    this._emit("var " + this.buffer + " = \"\";");

    return id;
  };

  _proto._popBuffer = function _popBuffer() {
    this.buffer = this.bufferStack.pop();
  };

  _proto._emit = function _emit(code) {
    this.codebuf.push(code);
  };

  _proto._emitLine = function _emitLine(code) {
    this._emit(code + '\n');
  };

  _proto._emitLines = function _emitLines() {
    var _this = this;

    for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
      lines[_key] = arguments[_key];
    }

    lines.forEach(function (line) {
      return _this._emitLine(line);
    });
  };

  _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
    this.buffer = 'output';
    this._scopeClosers = '';

    this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");

    this._emitLine("var lineno = " + node.lineno + ";");

    this._emitLine("var colno = " + node.colno + ";");

    this._emitLine("var " + this.buffer + " = \"\";");

    this._emitLine('try {');
  };

  _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
    if (!noReturn) {
      this._emitLine('cb(null, ' + this.buffer + ');');
    }

    this._closeScopeLevels();

    this._emitLine('} catch (e) {');

    this._emitLine('  cb(runtime.handleError(e, lineno, colno));');

    this._emitLine('}');

    this._emitLine('}');

    this.buffer = null;
  };

  _proto._addScopeLevel = function _addScopeLevel() {
    this._scopeClosers += '})';
  };

  _proto._closeScopeLevels = function _closeScopeLevels() {
    this._emitLine(this._scopeClosers + ';');

    this._scopeClosers = '';
  };

  _proto._withScopedSyntax = function _withScopedSyntax(func) {
    var _scopeClosers = this._scopeClosers;
    this._scopeClosers = '';
    func.call(this);

    this._closeScopeLevels();

    this._scopeClosers = _scopeClosers;
  };

  _proto._makeCallback = function _makeCallback(res) {
    var err = this._tmpid();

    return 'function(' + err + (res ? ',' + res : '') + ') {\n' + 'if(' + err + ') { cb(' + err + '); return; }';
  };

  _proto._tmpid = function _tmpid() {
    this.lastId++;
    return 't_' + this.lastId;
  };

  _proto._templateName = function _templateName() {
    return this.templateName == null ? 'undefined' : JSON.stringify(this.templateName);
  };

  _proto._compileChildren = function _compileChildren(node, frame) {
    var _this2 = this;

    node.children.forEach(function (child) {
      _this2.compile(child, frame);
    });
  };

  _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
    var _this3 = this;

    if (startChar) {
      this._emit(startChar);
    }

    node.children.forEach(function (child, i) {
      if (i > 0) {
        _this3._emit(',');
      }

      _this3.compile(child, frame);
    });

    if (endChar) {
      this._emit(endChar);
    }
  };

  _proto._compileExpression = function _compileExpression(node, frame) {
    // TODO: I'm not really sure if this type check is worth it or
    // not.
    this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
    this.compile(node, frame);
  };

  _proto.assertType = function assertType(node) {
    for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      types[_key2 - 1] = arguments[_key2];
    }

    if (!types.some(function (t) {
      return node instanceof t;
    })) {
      this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
    }
  };

  _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
    var _this4 = this;

    var args = node.args;
    var contentArgs = node.contentArgs;
    var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;

    if (!async) {
      this._emit(this.buffer + " += runtime.suppressValue(");
    }

    this._emit("env.getExtension(\"" + node.extName + "\")[\"" + node.prop + "\"](");

    this._emit('context');

    if (args || contentArgs) {
      this._emit(',');
    }

    if (args) {
      if (!(args instanceof nodes.NodeList)) {
        this.fail('compileCallExtension: arguments must be a NodeList, ' + 'use `parser.parseSignature`');
      }

      args.children.forEach(function (arg, i) {
        // Tag arguments are passed normally to the call. Note
        // that keyword arguments are turned into a single js
        // object as the last argument, if they exist.
        _this4._compileExpression(arg, frame);

        if (i !== args.children.length - 1 || contentArgs.length) {
          _this4._emit(',');
        }
      });
    }

    if (contentArgs.length) {
      contentArgs.forEach(function (arg, i) {
        if (i > 0) {
          _this4._emit(',');
        }

        if (arg) {
          _this4._emitLine('function(cb) {');

          _this4._emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');

          var id = _this4._pushBuffer();

          _this4._withScopedSyntax(function () {
            _this4.compile(arg, frame);

            _this4._emitLine("cb(null, " + id + ");");
          });

          _this4._popBuffer();

          _this4._emitLine("return " + id + ";");

          _this4._emitLine('}');
        } else {
          _this4._emit('null');
        }
      });
    }

    if (async) {
      var res = this._tmpid();

      this._emitLine(', ' + this._makeCallback(res));

      this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");

      this._addScopeLevel();
    } else {
      this._emit(')');

      this._emit(", " + autoescape + " && env.opts.autoescape);\n");
    }
  };

  _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
    this.compileCallExtension(node, frame, true);
  };

  _proto.compileNodeList = function compileNodeList(node, frame) {
    this._compileChildren(node, frame);
  };

  _proto.compileLiteral = function compileLiteral(node) {
    if (typeof node.value === 'string') {
      var val = node.value.replace(/\\/g, '\\\\');
      val = val.replace(/"/g, '\\"');
      val = val.replace(/\n/g, '\\n');
      val = val.replace(/\r/g, '\\r');
      val = val.replace(/\t/g, '\\t');
      val = val.replace(/\u2028/g, "\\u2028");

      this._emit("\"" + val + "\"");
    } else if (node.value === null) {
      this._emit('null');
    } else {
      this._emit(node.value.toString());
    }
  };

  _proto.compileSymbol = function compileSymbol(node, frame) {
    var name = node.value;
    var v = frame.lookup(name);

    if (v) {
      this._emit(v);
    } else {
      this._emit('runtime.contextOrFrameLookup(' + 'context, frame, "' + name + '")');
    }
  };

  _proto.compileGroup = function compileGroup(node, frame) {
    this._compileAggregate(node, frame, '(', ')');
  };

  _proto.compileArray = function compileArray(node, frame) {
    this._compileAggregate(node, frame, '[', ']');
  };

  _proto.compileDict = function compileDict(node, frame) {
    this._compileAggregate(node, frame, '{', '}');
  };

  _proto.compilePair = function compilePair(node, frame) {
    var key = node.key;
    var val = node.value;

    if (key instanceof nodes.Symbol) {
      key = new nodes.Literal(key.lineno, key.colno, key.value);
    } else if (!(key instanceof nodes.Literal && typeof key.value === 'string')) {
      this.fail('compilePair: Dict keys must be strings or names', key.lineno, key.colno);
    }

    this.compile(key, frame);

    this._emit(': ');

    this._compileExpression(val, frame);
  };

  _proto.compileInlineIf = function compileInlineIf(node, frame) {
    this._emit('(');

    this.compile(node.cond, frame);

    this._emit('?');

    this.compile(node.body, frame);

    this._emit(':');

    if (node.else_ !== null) {
      this.compile(node.else_, frame);
    } else {
      this._emit('""');
    }

    this._emit(')');
  };

  _proto.compileIn = function compileIn(node, frame) {
    this._emit('runtime.inOperator(');

    this.compile(node.left, frame);

    this._emit(',');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compileIs = function compileIs(node, frame) {
    // first, we need to try to get the name of the test function, if it's a
    // callable (i.e., has args) and not a symbol.
    var right = node.right.name ? node.right.name.value // otherwise go with the symbol value
    : node.right.value;

    this._emit('env.getTest("' + right + '").call(context, ');

    this.compile(node.left, frame); // compile the arguments for the callable if they exist

    if (node.right.args) {
      this._emit(',');

      this.compile(node.right.args, frame);
    }

    this._emit(') === true');
  };

  _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
    this.compile(node.left, frame);

    this._emit(str);

    this.compile(node.right, frame);
  } // ensure concatenation instead of addition
  // by adding empty string in between
  ;

  _proto.compileOr = function compileOr(node, frame) {
    return this._binOpEmitter(node, frame, ' || ');
  };

  _proto.compileAnd = function compileAnd(node, frame) {
    return this._binOpEmitter(node, frame, ' && ');
  };

  _proto.compileAdd = function compileAdd(node, frame) {
    return this._binOpEmitter(node, frame, ' + ');
  };

  _proto.compileConcat = function compileConcat(node, frame) {
    return this._binOpEmitter(node, frame, ' + "" + ');
  };

  _proto.compileSub = function compileSub(node, frame) {
    return this._binOpEmitter(node, frame, ' - ');
  };

  _proto.compileMul = function compileMul(node, frame) {
    return this._binOpEmitter(node, frame, ' * ');
  };

  _proto.compileDiv = function compileDiv(node, frame) {
    return this._binOpEmitter(node, frame, ' / ');
  };

  _proto.compileMod = function compileMod(node, frame) {
    return this._binOpEmitter(node, frame, ' % ');
  };

  _proto.compileNot = function compileNot(node, frame) {
    this._emit('!');

    this.compile(node.target, frame);
  };

  _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
    this._emit('Math.floor(');

    this.compile(node.left, frame);

    this._emit(' / ');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compilePow = function compilePow(node, frame) {
    this._emit('Math.pow(');

    this.compile(node.left, frame);

    this._emit(', ');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compileNeg = function compileNeg(node, frame) {
    this._emit('-');

    this.compile(node.target, frame);
  };

  _proto.compilePos = function compilePos(node, frame) {
    this._emit('+');

    this.compile(node.target, frame);
  };

  _proto.compileCompare = function compileCompare(node, frame) {
    var _this5 = this;

    this.compile(node.expr, frame);
    node.ops.forEach(function (op) {
      _this5._emit(" " + compareOps[op.type] + " ");

      _this5.compile(op.expr, frame);
    });
  };

  _proto.compileLookupVal = function compileLookupVal(node, frame) {
    this._emit('runtime.memberLookup((');

    this._compileExpression(node.target, frame);

    this._emit('),');

    this._compileExpression(node.val, frame);

    this._emit(')');
  };

  _proto._getNodeName = function _getNodeName(node) {
    switch (node.typename) {
      case 'Symbol':
        return node.value;

      case 'FunCall':
        return 'the return value of (' + this._getNodeName(node.name) + ')';

      case 'LookupVal':
        return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';

      case 'Literal':
        return node.value.toString();

      default:
        return '--expression--';
    }
  };

  _proto.compileFunCall = function compileFunCall(node, frame) {
    // Keep track of line/col info at runtime by settings
    // variables within an expression. An expression in javascript
    // like (x, y, z) returns the last value, and x and y can be
    // anything
    this._emit('(lineno = ' + node.lineno + ', colno = ' + node.colno + ', ');

    this._emit('runtime.callWrap('); // Compile it as normal.


    this._compileExpression(node.name, frame); // Output the name of what we're calling so we can get friendly errors
    // if the lookup fails.


    this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');

    this._compileAggregate(node.args, frame, '[', '])');

    this._emit(')');
  };

  _proto.compileFilter = function compileFilter(node, frame) {
    var name = node.name;
    this.assertType(name, nodes.Symbol);

    this._emit('env.getFilter("' + name.value + '").call(context, ');

    this._compileAggregate(node.args, frame);

    this._emit(')');
  };

  _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
    var name = node.name;
    var symbol = node.symbol.value;
    this.assertType(name, nodes.Symbol);
    frame.set(symbol, symbol);

    this._emit('env.getFilter("' + name.value + '").call(context, ');

    this._compileAggregate(node.args, frame);

    this._emitLine(', ' + this._makeCallback(symbol));

    this._addScopeLevel();
  };

  _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
    this._emit('runtime.makeKeywordArgs(');

    this.compileDict(node, frame);

    this._emit(')');
  };

  _proto.compileSet = function compileSet(node, frame) {
    var _this6 = this;

    var ids = []; // Lookup the variable names for each identifier and create
    // new ones if necessary

    node.targets.forEach(function (target) {
      var name = target.value;
      var id = frame.lookup(name);

      if (id === null || id === undefined) {
        id = _this6._tmpid(); // Note: This relies on js allowing scope across
        // blocks, in case this is created inside an `if`

        _this6._emitLine('var ' + id + ';');
      }

      ids.push(id);
    });

    if (node.value) {
      this._emit(ids.join(' = ') + ' = ');

      this._compileExpression(node.value, frame);

      this._emitLine(';');
    } else {
      this._emit(ids.join(' = ') + ' = ');

      this.compile(node.body, frame);

      this._emitLine(';');
    }

    node.targets.forEach(function (target, i) {
      var id = ids[i];
      var name = target.value; // We are running this for every var, but it's very
      // uncommon to assign to multiple vars anyway

      _this6._emitLine("frame.set(\"" + name + "\", " + id + ", true);");

      _this6._emitLine('if(frame.topLevel) {');

      _this6._emitLine("context.setVariable(\"" + name + "\", " + id + ");");

      _this6._emitLine('}');

      if (name.charAt(0) !== '_') {
        _this6._emitLine('if(frame.topLevel) {');

        _this6._emitLine("context.addExport(\"" + name + "\", " + id + ");");

        _this6._emitLine('}');
      }
    });
  };

  _proto.compileSwitch = function compileSwitch(node, frame) {
    var _this7 = this;

    this._emit('switch (');

    this.compile(node.expr, frame);

    this._emit(') {');

    node.cases.forEach(function (c, i) {
      _this7._emit('case ');

      _this7.compile(c.cond, frame);

      _this7._emit(': ');

      _this7.compile(c.body, frame); // preserve fall-throughs


      if (c.body.children.length) {
        _this7._emitLine('break;');
      }
    });

    if (node.default) {
      this._emit('default:');

      this.compile(node.default, frame);
    }

    this._emit('}');
  };

  _proto.compileIf = function compileIf(node, frame, async) {
    var _this8 = this;

    this._emit('if(');

    this._compileExpression(node.cond, frame);

    this._emitLine(') {');

    this._withScopedSyntax(function () {
      _this8.compile(node.body, frame);

      if (async) {
        _this8._emit('cb()');
      }
    });

    if (node.else_) {
      this._emitLine('}\nelse {');

      this._withScopedSyntax(function () {
        _this8.compile(node.else_, frame);

        if (async) {
          _this8._emit('cb()');
        }
      });
    } else if (async) {
      this._emitLine('}\nelse {');

      this._emit('cb()');
    }

    this._emitLine('}');
  };

  _proto.compileIfAsync = function compileIfAsync(node, frame) {
    this._emit('(function(cb) {');

    this.compileIf(node, frame, true);

    this._emit('})(' + this._makeCallback());

    this._addScopeLevel();
  };

  _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i, len) {
    var _this9 = this;

    var bindings = [{
      name: 'index',
      val: i + " + 1"
    }, {
      name: 'index0',
      val: i
    }, {
      name: 'revindex',
      val: len + " - " + i
    }, {
      name: 'revindex0',
      val: len + " - " + i + " - 1"
    }, {
      name: 'first',
      val: i + " === 0"
    }, {
      name: 'last',
      val: i + " === " + len + " - 1"
    }, {
      name: 'length',
      val: len
    }];
    bindings.forEach(function (b) {
      _this9._emitLine("frame.set(\"loop." + b.name + "\", " + b.val + ");");
    });
  };

  _proto.compileFor = function compileFor(node, frame) {
    var _this10 = this;

    // Some of this code is ugly, but it keeps the generated code
    // as fast as possible. ForAsync also shares some of this, but
    // not much.
    var i = this._tmpid();

    var len = this._tmpid();

    var arr = this._tmpid();

    frame = frame.push();

    this._emitLine('frame = frame.push();');

    this._emit("var " + arr + " = ");

    this._compileExpression(node.arr, frame);

    this._emitLine(';');

    this._emit("if(" + arr + ") {");

    this._emitLine(arr + ' = runtime.fromIterator(' + arr + ');'); // If multiple names are passed, we need to bind them
    // appropriately


    if (node.name instanceof nodes.Array) {
      this._emitLine("var " + i + ";"); // The object could be an arroy or object. Note that the
      // body of the loop is duplicated for each condition, but
      // we are optimizing for speed over size.


      this._emitLine("if(runtime.isArray(" + arr + ")) {");

      this._emitLine("var " + len + " = " + arr + ".length;");

      this._emitLine("for(" + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {"); // Bind each declared var


      node.name.children.forEach(function (child, u) {
        var tid = _this10._tmpid();

        _this10._emitLine("var " + tid + " = " + arr + "[" + i + "][" + u + "];");

        _this10._emitLine("frame.set(\"" + child + "\", " + arr + "[" + i + "][" + u + "]);");

        frame.set(node.name.children[u].value, tid);
      });

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');

      this._emitLine('} else {'); // Iterate over the key/values of an object


      var _node$name$children = node.name.children,
          key = _node$name$children[0],
          val = _node$name$children[1];

      var k = this._tmpid();

      var v = this._tmpid();

      frame.set(key.value, k);
      frame.set(val.value, v);

      this._emitLine(i + " = -1;");

      this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");

      this._emitLine("for(var " + k + " in " + arr + ") {");

      this._emitLine(i + "++;");

      this._emitLine("var " + v + " = " + arr + "[" + k + "];");

      this._emitLine("frame.set(\"" + key.value + "\", " + k + ");");

      this._emitLine("frame.set(\"" + val.value + "\", " + v + ");");

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');

      this._emitLine('}');
    } else {
      // Generate a typical array iteration
      var _v = this._tmpid();

      frame.set(node.name.value, _v);

      this._emitLine("var " + len + " = " + arr + ".length;");

      this._emitLine("for(var " + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");

      this._emitLine("var " + _v + " = " + arr + "[" + i + "];");

      this._emitLine("frame.set(\"" + node.name.value + "\", " + _v + ");");

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');
    }

    this._emitLine('}');

    if (node.else_) {
      this._emitLine('if (!' + len + ') {');

      this.compile(node.else_, frame);

      this._emitLine('}');
    }

    this._emitLine('frame = frame.pop();');
  };

  _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
    var _this11 = this;

    // This shares some code with the For tag, but not enough to
    // worry about. This iterates across an object asynchronously,
    // but not in parallel.
    var i = this._tmpid();

    var len = this._tmpid();

    var arr = this._tmpid();

    var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';
    frame = frame.push();

    this._emitLine('frame = frame.push();');

    this._emit('var ' + arr + ' = runtime.fromIterator(');

    this._compileExpression(node.arr, frame);

    this._emitLine(');');

    if (node.name instanceof nodes.Array) {
      var arrayLen = node.name.children.length;

      this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");

      node.name.children.forEach(function (name) {
        _this11._emit(name.value + ",");
      });

      this._emit(i + ',' + len + ',next) {');

      node.name.children.forEach(function (name) {
        var id = name.value;
        frame.set(id, id);

        _this11._emitLine("frame.set(\"" + id + "\", " + id + ");");
      });
    } else {
      var id = node.name.value;

      this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i + ", " + len + ",next) {");

      this._emitLine('frame.set("' + id + '", ' + id + ');');

      frame.set(id, id);
    }

    this._emitLoopBindings(node, arr, i, len);

    this._withScopedSyntax(function () {
      var buf;

      if (parallel) {
        buf = _this11._pushBuffer();
      }

      _this11.compile(node.body, frame);

      _this11._emitLine('next(' + i + (buf ? ',' + buf : '') + ');');

      if (parallel) {
        _this11._popBuffer();
      }
    });

    var output = this._tmpid();

    this._emitLine('}, ' + this._makeCallback(output));

    this._addScopeLevel();

    if (parallel) {
      this._emitLine(this.buffer + ' += ' + output + ';');
    }

    if (node.else_) {
      this._emitLine('if (!' + arr + '.length) {');

      this.compile(node.else_, frame);

      this._emitLine('}');
    }

    this._emitLine('frame = frame.pop();');
  };

  _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
    this._compileAsyncLoop(node, frame);
  };

  _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
    this._compileAsyncLoop(node, frame, true);
  };

  _proto._compileMacro = function _compileMacro(node, frame) {
    var _this12 = this;

    var args = [];
    var kwargs = null;

    var funcId = 'macro_' + this._tmpid();

    var keepFrame = frame !== undefined; // Type check the definition of the args

    node.args.children.forEach(function (arg, i) {
      if (i === node.args.children.length - 1 && arg instanceof nodes.Dict) {
        kwargs = arg;
      } else {
        _this12.assertType(arg, nodes.Symbol);

        args.push(arg);
      }
    });
    var realNames = [].concat(args.map(function (n) {
      return "l_" + n.value;
    }), ['kwargs']); // Quoted argument names

    var argNames = args.map(function (n) {
      return "\"" + n.value + "\"";
    });
    var kwargNames = (kwargs && kwargs.children || []).map(function (n) {
      return "\"" + n.key.value + "\"";
    }); // We pass a function to makeMacro which destructures the
    // arguments so support setting positional args with keywords
    // args and passing keyword args as positional args
    // (essentially default values). See runtime.js.

    var currFrame;

    if (keepFrame) {
      currFrame = frame.push(true);
    } else {
      currFrame = new Frame();
    }

    this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(', ') + "], ", "[" + kwargNames.join(', ') + "], ", "function (" + realNames.join(', ') + ") {", 'var callerFrame = frame;', 'frame = ' + (keepFrame ? 'frame.push(true);' : 'new runtime.Frame();'), 'kwargs = kwargs || {};', 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }'); // Expose the arguments to the template. Don't need to use
    // random names because the function
    // will create a new run-time scope for us


    args.forEach(function (arg) {
      _this12._emitLine("frame.set(\"" + arg.value + "\", l_" + arg.value + ");");

      currFrame.set(arg.value, "l_" + arg.value);
    }); // Expose the keyword arguments

    if (kwargs) {
      kwargs.children.forEach(function (pair) {
        var name = pair.key.value;

        _this12._emit("frame.set(\"" + name + "\", ");

        _this12._emit("Object.prototype.hasOwnProperty.call(kwargs, \"" + name + "\")");

        _this12._emit(" ? kwargs[\"" + name + "\"] : ");

        _this12._compileExpression(pair.value, currFrame);

        _this12._emit(');');
      });
    }

    var bufferId = this._pushBuffer();

    this._withScopedSyntax(function () {
      _this12.compile(node.body, currFrame);
    });

    this._emitLine('frame = ' + (keepFrame ? 'frame.pop();' : 'callerFrame;'));

    this._emitLine("return new runtime.SafeString(" + bufferId + ");");

    this._emitLine('});');

    this._popBuffer();

    return funcId;
  };

  _proto.compileMacro = function compileMacro(node, frame) {
    var funcId = this._compileMacro(node); // Expose the macro to the templates


    var name = node.name.value;
    frame.set(name, funcId);

    if (frame.parent) {
      this._emitLine("frame.set(\"" + name + "\", " + funcId + ");");
    } else {
      if (node.name.value.charAt(0) !== '_') {
        this._emitLine("context.addExport(\"" + name + "\");");
      }

      this._emitLine("context.setVariable(\"" + name + "\", " + funcId + ");");
    }
  };

  _proto.compileCaller = function compileCaller(node, frame) {
    // basically an anonymous "macro expression"
    this._emit('(function (){');

    var funcId = this._compileMacro(node, frame);

    this._emit("return " + funcId + ";})()");
  };

  _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
    var parentTemplateId = this._tmpid();

    var parentName = this._templateName();

    var cb = this._makeCallback(parentTemplateId);

    var eagerCompileArg = eagerCompile ? 'true' : 'false';
    var ignoreMissingArg = ignoreMissing ? 'true' : 'false';

    this._emit('env.getTemplate(');

    this._compileExpression(node.template, frame);

    this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);

    return parentTemplateId;
  };

  _proto.compileImport = function compileImport(node, frame) {
    var target = node.target.value;

    var id = this._compileGetTemplate(node, frame, false, false);

    this._addScopeLevel();

    this._emitLine(id + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(id));

    this._addScopeLevel();

    frame.set(target, id);

    if (frame.parent) {
      this._emitLine("frame.set(\"" + target + "\", " + id + ");");
    } else {
      this._emitLine("context.setVariable(\"" + target + "\", " + id + ");");
    }
  };

  _proto.compileFromImport = function compileFromImport(node, frame) {
    var _this13 = this;

    var importedId = this._compileGetTemplate(node, frame, false, false);

    this._addScopeLevel();

    this._emitLine(importedId + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(importedId));

    this._addScopeLevel();

    node.names.children.forEach(function (nameNode) {
      var name;
      var alias;

      var id = _this13._tmpid();

      if (nameNode instanceof nodes.Pair) {
        name = nameNode.key.value;
        alias = nameNode.value.value;
      } else {
        name = nameNode.value;
        alias = name;
      }

      _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ", \"" + name + "\")) {");

      _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");

      _this13._emitLine('} else {');

      _this13._emitLine("cb(new Error(\"cannot import '" + name + "'\")); return;");

      _this13._emitLine('}');

      frame.set(alias, id);

      if (frame.parent) {
        _this13._emitLine("frame.set(\"" + alias + "\", " + id + ");");
      } else {
        _this13._emitLine("context.setVariable(\"" + alias + "\", " + id + ");");
      }
    });
  };

  _proto.compileBlock = function compileBlock(node) {
    var id = this._tmpid(); // If we are executing outside a block (creating a top-level
    // block), we really don't want to execute its code because it
    // will execute twice: once when the child template runs and
    // again when the parent template runs. Note that blocks
    // within blocks will *always* execute immediately *and*
    // wherever else they are invoked (like used in a parent
    // template). This may have behavioral differences from jinja
    // because blocks can have side effects, but it seems like a
    // waste of performance to always execute huge top-level
    // blocks twice


    if (!this.inBlock) {
      this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
    }

    this._emit("context.getBlock(\"" + node.name.value + "\")");

    if (!this.inBlock) {
      this._emit(')');
    }

    this._emitLine('(env, context, frame, runtime, ' + this._makeCallback(id));

    this._emitLine(this.buffer + " += " + id + ";");

    this._addScopeLevel();
  };

  _proto.compileSuper = function compileSuper(node, frame) {
    var name = node.blockName.value;
    var id = node.symbol.value;

    var cb = this._makeCallback(id);

    this._emitLine("context.getSuper(env, \"" + name + "\", b_" + name + ", frame, runtime, " + cb);

    this._emitLine(id + " = runtime.markSafe(" + id + ");");

    this._addScopeLevel();

    frame.set(id, id);
  };

  _proto.compileExtends = function compileExtends(node, frame) {
    var k = this._tmpid();

    var parentTemplateId = this._compileGetTemplate(node, frame, true, false); // extends is a dynamic tag and can occur within a block like
    // `if`, so if this happens we need to capture the parent
    // template in the top-level scope


    this._emitLine("parentTemplate = " + parentTemplateId);

    this._emitLine("for(var " + k + " in parentTemplate.blocks) {");

    this._emitLine("context.addBlock(" + k + ", parentTemplate.blocks[" + k + "]);");

    this._emitLine('}');

    this._addScopeLevel();
  };

  _proto.compileInclude = function compileInclude(node, frame) {
    this._emitLine('var tasks = [];');

    this._emitLine('tasks.push(');

    this._emitLine('function(callback) {');

    var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);

    this._emitLine("callback(null," + id + ");});");

    this._emitLine('});');

    var id2 = this._tmpid();

    this._emitLine('tasks.push(');

    this._emitLine('function(template, callback){');

    this._emitLine('template.render(context.getVariables(), frame, ' + this._makeCallback(id2));

    this._emitLine('callback(null,' + id2 + ');});');

    this._emitLine('});');

    this._emitLine('tasks.push(');

    this._emitLine('function(result, callback){');

    this._emitLine(this.buffer + " += result;");

    this._emitLine('callback(null);');

    this._emitLine('});');

    this._emitLine('env.waterfall(tasks, function(){');

    this._addScopeLevel();
  };

  _proto.compileTemplateData = function compileTemplateData(node, frame) {
    this.compileLiteral(node, frame);
  };

  _proto.compileCapture = function compileCapture(node, frame) {
    var _this14 = this;

    // we need to temporarily override the current buffer id as 'output'
    // so the set block writes to the capture output instead of the buffer
    var buffer = this.buffer;
    this.buffer = 'output';

    this._emitLine('(function() {');

    this._emitLine('var output = "";');

    this._withScopedSyntax(function () {
      _this14.compile(node.body, frame);
    });

    this._emitLine('return output;');

    this._emitLine('})()'); // and of course, revert back to the old buffer id


    this.buffer = buffer;
  };

  _proto.compileOutput = function compileOutput(node, frame) {
    var _this15 = this;

    var children = node.children;
    children.forEach(function (child) {
      // TemplateData is a special case because it is never
      // autoescaped, so simply output it for optimization
      if (child instanceof nodes.TemplateData) {
        if (child.value) {
          _this15._emit(_this15.buffer + " += ");

          _this15.compileLiteral(child, frame);

          _this15._emitLine(';');
        }
      } else {
        _this15._emit(_this15.buffer + " += runtime.suppressValue(");

        if (_this15.throwOnUndefined) {
          _this15._emit('runtime.ensureDefined(');
        }

        _this15.compile(child, frame);

        if (_this15.throwOnUndefined) {
          _this15._emit("," + node.lineno + "," + node.colno + ")");
        }

        _this15._emit(', env.opts.autoescape);\n');
      }
    });
  };

  _proto.compileRoot = function compileRoot(node, frame) {
    var _this16 = this;

    if (frame) {
      this.fail('compileRoot: root node can\'t have frame');
    }

    frame = new Frame();

    this._emitFuncBegin(node, 'root');

    this._emitLine('var parentTemplate = null;');

    this._compileChildren(node, frame);

    this._emitLine('if(parentTemplate) {');

    this._emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');

    this._emitLine('} else {');

    this._emitLine("cb(null, " + this.buffer + ");");

    this._emitLine('}');

    this._emitFuncEnd(true);

    this.inBlock = true;
    var blockNames = [];
    var blocks = node.findAll(nodes.Block);
    blocks.forEach(function (block, i) {
      var name = block.name.value;

      if (blockNames.indexOf(name) !== -1) {
        throw new Error("Block \"" + name + "\" defined more than once.");
      }

      blockNames.push(name);

      _this16._emitFuncBegin(block, "b_" + name);

      var tmpFrame = new Frame();

      _this16._emitLine('var frame = frame.push(true);');

      _this16.compile(block.body, tmpFrame);

      _this16._emitFuncEnd();
    });

    this._emitLine('return {');

    blocks.forEach(function (block, i) {
      var blockName = "b_" + block.name.value;

      _this16._emitLine(blockName + ": " + blockName + ",");
    });

    this._emitLine('root: root\n};');
  };

  _proto.compile = function compile(node, frame) {
    var _compile = this['compile' + node.typename];

    if (_compile) {
      _compile.call(this, node, frame);
    } else {
      this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
    }
  };

  _proto.getCode = function getCode() {
    return this.codebuf.join('');
  };

  return Compiler;
}(Obj);

module.exports = {
  compile: function compile(src, asyncFilters, extensions, name, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var c = new Compiler(name, opts.throwOnUndefined); // Run the extension preprocessors against the source.

    var preprocessors = (extensions || []).map(function (ext) {
      return ext.preprocess;
    }).filter(function (f) {
      return !!f;
    });
    var processedSrc = preprocessors.reduce(function (s, processor) {
      return processor(s);
    }, src);
    c.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
    return c.getCode();
  },
  Compiler: Compiler
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var path = __webpack_require__(4);

var _require = __webpack_require__(1),
    EmitterObj = _require.EmitterObj;

module.exports = /*#__PURE__*/function (_EmitterObj) {
  _inheritsLoose(Loader, _EmitterObj);

  function Loader() {
    return _EmitterObj.apply(this, arguments) || this;
  }

  var _proto = Loader.prototype;

  _proto.resolve = function resolve(from, to) {
    return path.resolve(path.dirname(from), to);
  };

  _proto.isRelative = function isRelative(filename) {
    return filename.indexOf('./') === 0 || filename.indexOf('../') === 0;
  };

  return Loader;
}(EmitterObj);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var asap = __webpack_require__(12);

var _waterfall = __webpack_require__(15);

var lib = __webpack_require__(0);

var compiler = __webpack_require__(5);

var filters = __webpack_require__(18);

var _require = __webpack_require__(10),
    FileSystemLoader = _require.FileSystemLoader,
    WebLoader = _require.WebLoader,
    PrecompiledLoader = _require.PrecompiledLoader;

var tests = __webpack_require__(20);

var globals = __webpack_require__(21);

var _require2 = __webpack_require__(1),
    Obj = _require2.Obj,
    EmitterObj = _require2.EmitterObj;

var globalRuntime = __webpack_require__(2);

var handleError = globalRuntime.handleError,
    Frame = globalRuntime.Frame;

var expressApp = __webpack_require__(22); // If the user is using the async API, *always* call it
// asynchronously even if the template was synchronous.


function callbackAsap(cb, err, res) {
  asap(function () {
    cb(err, res);
  });
}
/**
 * A no-op template, for use with {% include ignore missing %}
 */


var noopTmplSrc = {
  type: 'code',
  obj: {
    root: function root(env, context, frame, runtime, cb) {
      try {
        cb(null, '');
      } catch (e) {
        cb(handleError(e, null, null));
      }
    }
  }
};

var Environment = /*#__PURE__*/function (_EmitterObj) {
  _inheritsLoose(Environment, _EmitterObj);

  function Environment() {
    return _EmitterObj.apply(this, arguments) || this;
  }

  var _proto = Environment.prototype;

  _proto.init = function init(loaders, opts) {
    var _this = this;

    // The dev flag determines the trace that'll be shown on errors.
    // If set to true, returns the full trace from the error point,
    // otherwise will return trace starting from Template.render
    // (the full trace from within nunjucks may confuse developers using
    //  the library)
    // defaults to false
    opts = this.opts = opts || {};
    this.opts.dev = !!opts.dev; // The autoescape flag sets global autoescaping. If true,
    // every string variable will be escaped by default.
    // If false, strings can be manually escaped using the `escape` filter.
    // defaults to true

    this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true; // If true, this will make the system throw errors if trying
    // to output a null or undefined value

    this.opts.throwOnUndefined = !!opts.throwOnUndefined;
    this.opts.trimBlocks = !!opts.trimBlocks;
    this.opts.lstripBlocks = !!opts.lstripBlocks;
    this.loaders = [];

    if (!loaders) {
      // The filesystem loader is only available server-side
      if (FileSystemLoader) {
        this.loaders = [new FileSystemLoader('views')];
      } else if (WebLoader) {
        this.loaders = [new WebLoader('/views')];
      }
    } else {
      this.loaders = lib.isArray(loaders) ? loaders : [loaders];
    } // It's easy to use precompiled templates: just include them
    // before you configure nunjucks and this will automatically
    // pick it up and use it


    if (typeof window !== 'undefined' && window.nunjucksPrecompiled) {
      this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
    }

    this._initLoaders();

    this.globals = globals();
    this.filters = {};
    this.tests = {};
    this.asyncFilters = [];
    this.extensions = {};
    this.extensionsList = [];

    lib._entries(filters).forEach(function (_ref) {
      var name = _ref[0],
          filter = _ref[1];
      return _this.addFilter(name, filter);
    });

    lib._entries(tests).forEach(function (_ref2) {
      var name = _ref2[0],
          test = _ref2[1];
      return _this.addTest(name, test);
    });
  };

  _proto._initLoaders = function _initLoaders() {
    var _this2 = this;

    this.loaders.forEach(function (loader) {
      // Caching and cache busting
      loader.cache = {};

      if (typeof loader.on === 'function') {
        loader.on('update', function (name, fullname) {
          loader.cache[name] = null;

          _this2.emit('update', name, fullname, loader);
        });
        loader.on('load', function (name, source) {
          _this2.emit('load', name, source, loader);
        });
      }
    });
  };

  _proto.invalidateCache = function invalidateCache() {
    this.loaders.forEach(function (loader) {
      loader.cache = {};
    });
  };

  _proto.addExtension = function addExtension(name, extension) {
    extension.__name = name;
    this.extensions[name] = extension;
    this.extensionsList.push(extension);
    return this;
  };

  _proto.removeExtension = function removeExtension(name) {
    var extension = this.getExtension(name);

    if (!extension) {
      return;
    }

    this.extensionsList = lib.without(this.extensionsList, extension);
    delete this.extensions[name];
  };

  _proto.getExtension = function getExtension(name) {
    return this.extensions[name];
  };

  _proto.hasExtension = function hasExtension(name) {
    return !!this.extensions[name];
  };

  _proto.addGlobal = function addGlobal(name, value) {
    this.globals[name] = value;
    return this;
  };

  _proto.getGlobal = function getGlobal(name) {
    if (typeof this.globals[name] === 'undefined') {
      throw new Error('global not found: ' + name);
    }

    return this.globals[name];
  };

  _proto.addFilter = function addFilter(name, func, async) {
    var wrapped = func;

    if (async) {
      this.asyncFilters.push(name);
    }

    this.filters[name] = wrapped;
    return this;
  };

  _proto.getFilter = function getFilter(name) {
    if (!this.filters[name]) {
      throw new Error('filter not found: ' + name);
    }

    return this.filters[name];
  };

  _proto.addTest = function addTest(name, func) {
    this.tests[name] = func;
    return this;
  };

  _proto.getTest = function getTest(name) {
    if (!this.tests[name]) {
      throw new Error('test not found: ' + name);
    }

    return this.tests[name];
  };

  _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
    var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
    return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
  };

  _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
    var _this3 = this;

    var that = this;
    var tmpl = null;

    if (name && name.raw) {
      // this fixes autoescape for templates referenced in symbols
      name = name.raw;
    }

    if (lib.isFunction(parentName)) {
      cb = parentName;
      parentName = null;
      eagerCompile = eagerCompile || false;
    }

    if (lib.isFunction(eagerCompile)) {
      cb = eagerCompile;
      eagerCompile = false;
    }

    if (name instanceof Template) {
      tmpl = name;
    } else if (typeof name !== 'string') {
      throw new Error('template names must be a string: ' + name);
    } else {
      for (var i = 0; i < this.loaders.length; i++) {
        var loader = this.loaders[i];
        tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];

        if (tmpl) {
          break;
        }
      }
    }

    if (tmpl) {
      if (eagerCompile) {
        tmpl.compile();
      }

      if (cb) {
        cb(null, tmpl);
        return undefined;
      } else {
        return tmpl;
      }
    }

    var syncResult;

    var createTemplate = function createTemplate(err, info) {
      if (!info && !err && !ignoreMissing) {
        err = new Error('template not found: ' + name);
      }

      if (err) {
        if (cb) {
          cb(err);
          return;
        } else {
          throw err;
        }
      }

      var newTmpl;

      if (!info) {
        newTmpl = new Template(noopTmplSrc, _this3, '', eagerCompile);
      } else {
        newTmpl = new Template(info.src, _this3, info.path, eagerCompile);

        if (!info.noCache) {
          info.loader.cache[name] = newTmpl;
        }
      }

      if (cb) {
        cb(null, newTmpl);
      } else {
        syncResult = newTmpl;
      }
    };

    lib.asyncIter(this.loaders, function (loader, i, next, done) {
      function handle(err, src) {
        if (err) {
          done(err);
        } else if (src) {
          src.loader = loader;
          done(null, src);
        } else {
          next();
        }
      } // Resolve name relative to parentName


      name = that.resolveTemplate(loader, parentName, name);

      if (loader.async) {
        loader.getSource(name, handle);
      } else {
        handle(null, loader.getSource(name));
      }
    }, createTemplate);
    return syncResult;
  };

  _proto.express = function express(app) {
    return expressApp(this, app);
  };

  _proto.render = function render(name, ctx, cb) {
    if (lib.isFunction(ctx)) {
      cb = ctx;
      ctx = null;
    } // We support a synchronous API to make it easier to migrate
    // existing code to async. This works because if you don't do
    // anything async work, the whole thing is actually run
    // synchronously.


    var syncResult = null;
    this.getTemplate(name, function (err, tmpl) {
      if (err && cb) {
        callbackAsap(cb, err);
      } else if (err) {
        throw err;
      } else {
        syncResult = tmpl.render(ctx, cb);
      }
    });
    return syncResult;
  };

  _proto.renderString = function renderString(src, ctx, opts, cb) {
    if (lib.isFunction(opts)) {
      cb = opts;
      opts = {};
    }

    opts = opts || {};
    var tmpl = new Template(src, this, opts.path);
    return tmpl.render(ctx, cb);
  };

  _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
    return _waterfall(tasks, callback, forceAsync);
  };

  return Environment;
}(EmitterObj);

var Context = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Context, _Obj);

  function Context() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto2 = Context.prototype;

  _proto2.init = function init(ctx, blocks, env) {
    var _this4 = this;

    // Has to be tied to an environment so we can tap into its globals.
    this.env = env || new Environment(); // Make a duplicate of ctx

    this.ctx = lib.extend({}, ctx);
    this.blocks = {};
    this.exported = [];
    lib.keys(blocks).forEach(function (name) {
      _this4.addBlock(name, blocks[name]);
    });
  };

  _proto2.lookup = function lookup(name) {
    // This is one of the most called functions, so optimize for
    // the typical case where the name isn't in the globals
    if (name in this.env.globals && !(name in this.ctx)) {
      return this.env.globals[name];
    } else {
      return this.ctx[name];
    }
  };

  _proto2.setVariable = function setVariable(name, val) {
    this.ctx[name] = val;
  };

  _proto2.getVariables = function getVariables() {
    return this.ctx;
  };

  _proto2.addBlock = function addBlock(name, block) {
    this.blocks[name] = this.blocks[name] || [];
    this.blocks[name].push(block);
    return this;
  };

  _proto2.getBlock = function getBlock(name) {
    if (!this.blocks[name]) {
      throw new Error('unknown block "' + name + '"');
    }

    return this.blocks[name][0];
  };

  _proto2.getSuper = function getSuper(env, name, block, frame, runtime, cb) {
    var idx = lib.indexOf(this.blocks[name] || [], block);
    var blk = this.blocks[name][idx + 1];
    var context = this;

    if (idx === -1 || !blk) {
      throw new Error('no super block available for "' + name + '"');
    }

    blk(env, context, frame, runtime, cb);
  };

  _proto2.addExport = function addExport(name) {
    this.exported.push(name);
  };

  _proto2.getExported = function getExported() {
    var _this5 = this;

    var exported = {};
    this.exported.forEach(function (name) {
      exported[name] = _this5.ctx[name];
    });
    return exported;
  };

  return Context;
}(Obj);

var Template = /*#__PURE__*/function (_Obj2) {
  _inheritsLoose(Template, _Obj2);

  function Template() {
    return _Obj2.apply(this, arguments) || this;
  }

  var _proto3 = Template.prototype;

  _proto3.init = function init(src, env, path, eagerCompile) {
    this.env = env || new Environment();

    if (lib.isObject(src)) {
      switch (src.type) {
        case 'code':
          this.tmplProps = src.obj;
          break;

        case 'string':
          this.tmplStr = src.obj;
          break;

        default:
          throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
      }
    } else if (lib.isString(src)) {
      this.tmplStr = src;
    } else {
      throw new Error('src must be a string or an object describing the source');
    }

    this.path = path;

    if (eagerCompile) {
      try {
        this._compile();
      } catch (err) {
        throw lib._prettifyError(this.path, this.env.opts.dev, err);
      }
    } else {
      this.compiled = false;
    }
  };

  _proto3.render = function render(ctx, parentFrame, cb) {
    var _this6 = this;

    if (typeof ctx === 'function') {
      cb = ctx;
      ctx = {};
    } else if (typeof parentFrame === 'function') {
      cb = parentFrame;
      parentFrame = null;
    } // If there is a parent frame, we are being called from internal
    // code of another template, and the internal system
    // depends on the sync/async nature of the parent template
    // to be inherited, so force an async callback


    var forceAsync = !parentFrame; // Catch compile errors for async rendering

    try {
      this.compile();
    } catch (e) {
      var err = lib._prettifyError(this.path, this.env.opts.dev, e);

      if (cb) {
        return callbackAsap(cb, err);
      } else {
        throw err;
      }
    }

    var context = new Context(ctx || {}, this.blocks, this.env);
    var frame = parentFrame ? parentFrame.push(true) : new Frame();
    frame.topLevel = true;
    var syncResult = null;
    var didError = false;
    this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err, res) {
      // TODO: this is actually a bug in the compiled template (because waterfall
      // tasks are both not passing errors up the chain of callbacks AND are not
      // causing a return from the top-most render function). But fixing that
      // will require a more substantial change to the compiler.
      if (didError && cb && typeof res !== 'undefined') {
        // prevent multiple calls to cb
        return;
      }

      if (err) {
        err = lib._prettifyError(_this6.path, _this6.env.opts.dev, err);
        didError = true;
      }

      if (cb) {
        if (forceAsync) {
          callbackAsap(cb, err, res);
        } else {
          cb(err, res);
        }
      } else {
        if (err) {
          throw err;
        }

        syncResult = res;
      }
    });
    return syncResult;
  };

  _proto3.getExported = function getExported(ctx, parentFrame, cb) {
    // eslint-disable-line consistent-return
    if (typeof ctx === 'function') {
      cb = ctx;
      ctx = {};
    }

    if (typeof parentFrame === 'function') {
      cb = parentFrame;
      parentFrame = null;
    } // Catch compile errors for async rendering


    try {
      this.compile();
    } catch (e) {
      if (cb) {
        return cb(e);
      } else {
        throw e;
      }
    }

    var frame = parentFrame ? parentFrame.push() : new Frame();
    frame.topLevel = true; // Run the rootRenderFunc to populate the context with exported vars

    var context = new Context(ctx || {}, this.blocks, this.env);
    this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err) {
      if (err) {
        cb(err, null);
      } else {
        cb(null, context.getExported());
      }
    });
  };

  _proto3.compile = function compile() {
    if (!this.compiled) {
      this._compile();
    }
  };

  _proto3._compile = function _compile() {
    var props;

    if (this.tmplProps) {
      props = this.tmplProps;
    } else {
      var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
      var func = new Function(source); // eslint-disable-line no-new-func

      props = func();
    }

    this.blocks = this._getBlocks(props);
    this.rootRenderFunc = props.root;
    this.compiled = true;
  };

  _proto3._getBlocks = function _getBlocks(props) {
    var blocks = {};
    lib.keys(props).forEach(function (k) {
      if (k.slice(0, 2) === 'b_') {
        blocks[k.slice(2)] = props[k];
      }
    });
    return blocks;
  };

  return Template;
}(Obj);

module.exports = {
  Environment: Environment,
  Template: Template
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var lexer = __webpack_require__(9);

var nodes = __webpack_require__(3);

var Obj = __webpack_require__(1).Obj;

var lib = __webpack_require__(0);

var Parser = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Parser, _Obj);

  function Parser() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Parser.prototype;

  _proto.init = function init(tokens) {
    this.tokens = tokens;
    this.peeked = null;
    this.breakOnBlocks = null;
    this.dropLeadingWhitespace = false;
    this.extensions = [];
  };

  _proto.nextToken = function nextToken(withWhitespace) {
    var tok;

    if (this.peeked) {
      if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
        this.peeked = null;
      } else {
        tok = this.peeked;
        this.peeked = null;
        return tok;
      }
    }

    tok = this.tokens.nextToken();

    if (!withWhitespace) {
      while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
        tok = this.tokens.nextToken();
      }
    }

    return tok;
  };

  _proto.peekToken = function peekToken() {
    this.peeked = this.peeked || this.nextToken();
    return this.peeked;
  };

  _proto.pushToken = function pushToken(tok) {
    if (this.peeked) {
      throw new Error('pushToken: can only push one token on between reads');
    }

    this.peeked = tok;
  };

  _proto.error = function error(msg, lineno, colno) {
    if (lineno === undefined || colno === undefined) {
      var tok = this.peekToken() || {};
      lineno = tok.lineno;
      colno = tok.colno;
    }

    if (lineno !== undefined) {
      lineno += 1;
    }

    if (colno !== undefined) {
      colno += 1;
    }

    return new lib.TemplateError(msg, lineno, colno);
  };

  _proto.fail = function fail(msg, lineno, colno) {
    throw this.error(msg, lineno, colno);
  };

  _proto.skip = function skip(type) {
    var tok = this.nextToken();

    if (!tok || tok.type !== type) {
      this.pushToken(tok);
      return false;
    }

    return true;
  };

  _proto.expect = function expect(type) {
    var tok = this.nextToken();

    if (tok.type !== type) {
      this.fail('expected ' + type + ', got ' + tok.type, tok.lineno, tok.colno);
    }

    return tok;
  };

  _proto.skipValue = function skipValue(type, val) {
    var tok = this.nextToken();

    if (!tok || tok.type !== type || tok.value !== val) {
      this.pushToken(tok);
      return false;
    }

    return true;
  };

  _proto.skipSymbol = function skipSymbol(val) {
    return this.skipValue(lexer.TOKEN_SYMBOL, val);
  };

  _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
    var tok;

    if (!name) {
      tok = this.peekToken();

      if (!tok) {
        this.fail('unexpected end of file');
      }

      if (tok.type !== lexer.TOKEN_SYMBOL) {
        this.fail('advanceAfterBlockEnd: expected symbol token or ' + 'explicit name to be passed');
      }

      name = this.nextToken().value;
    }

    tok = this.nextToken();

    if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
      if (tok.value.charAt(0) === '-') {
        this.dropLeadingWhitespace = true;
      }
    } else {
      this.fail('expected block end in ' + name + ' statement');
    }

    return tok;
  };

  _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
    var tok = this.nextToken();

    if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
      this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === '-';
    } else {
      this.pushToken(tok);
      this.fail('expected variable end');
    }
  };

  _proto.parseFor = function parseFor() {
    var forTok = this.peekToken();
    var node;
    var endBlock;

    if (this.skipSymbol('for')) {
      node = new nodes.For(forTok.lineno, forTok.colno);
      endBlock = 'endfor';
    } else if (this.skipSymbol('asyncEach')) {
      node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
      endBlock = 'endeach';
    } else if (this.skipSymbol('asyncAll')) {
      node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
      endBlock = 'endall';
    } else {
      this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);
    }

    node.name = this.parsePrimary();

    if (!(node.name instanceof nodes.Symbol)) {
      this.fail('parseFor: variable name expected for loop');
    }

    var type = this.peekToken().type;

    if (type === lexer.TOKEN_COMMA) {
      // key/value iteration
      var key = node.name;
      node.name = new nodes.Array(key.lineno, key.colno);
      node.name.addChild(key);

      while (this.skip(lexer.TOKEN_COMMA)) {
        var prim = this.parsePrimary();
        node.name.addChild(prim);
      }
    }

    if (!this.skipSymbol('in')) {
      this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
    }

    node.arr = this.parseExpression();
    this.advanceAfterBlockEnd(forTok.value);
    node.body = this.parseUntilBlocks(endBlock, 'else');

    if (this.skipSymbol('else')) {
      this.advanceAfterBlockEnd('else');
      node.else_ = this.parseUntilBlocks(endBlock);
    }

    this.advanceAfterBlockEnd();
    return node;
  };

  _proto.parseMacro = function parseMacro() {
    var macroTok = this.peekToken();

    if (!this.skipSymbol('macro')) {
      this.fail('expected macro');
    }

    var name = this.parsePrimary(true);
    var args = this.parseSignature();
    var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
    this.advanceAfterBlockEnd(macroTok.value);
    node.body = this.parseUntilBlocks('endmacro');
    this.advanceAfterBlockEnd();
    return node;
  };

  _proto.parseCall = function parseCall() {
    // a call block is parsed as a normal FunCall, but with an added
    // 'caller' kwarg which is a Caller node.
    var callTok = this.peekToken();

    if (!this.skipSymbol('call')) {
      this.fail('expected call');
    }

    var callerArgs = this.parseSignature(true) || new nodes.NodeList();
    var macroCall = this.parsePrimary();
    this.advanceAfterBlockEnd(callTok.value);
    var body = this.parseUntilBlocks('endcall');
    this.advanceAfterBlockEnd();
    var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, 'caller');
    var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body); // add the additional caller kwarg, adding kwargs if necessary

    var args = macroCall.args.children;

    if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
      args.push(new nodes.KeywordArgs());
    }

    var kwargs = args[args.length - 1];
    kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
    return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
  };

  _proto.parseWithContext = function parseWithContext() {
    var tok = this.peekToken();
    var withContext = null;

    if (this.skipSymbol('with')) {
      withContext = true;
    } else if (this.skipSymbol('without')) {
      withContext = false;
    }

    if (withContext !== null) {
      if (!this.skipSymbol('context')) {
        this.fail('parseFrom: expected context after with/without', tok.lineno, tok.colno);
      }
    }

    return withContext;
  };

  _proto.parseImport = function parseImport() {
    var importTok = this.peekToken();

    if (!this.skipSymbol('import')) {
      this.fail('parseImport: expected import', importTok.lineno, importTok.colno);
    }

    var template = this.parseExpression();

    if (!this.skipSymbol('as')) {
      this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
    }

    var target = this.parseExpression();
    var withContext = this.parseWithContext();
    var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
    this.advanceAfterBlockEnd(importTok.value);
    return node;
  };

  _proto.parseFrom = function parseFrom() {
    var fromTok = this.peekToken();

    if (!this.skipSymbol('from')) {
      this.fail('parseFrom: expected from');
    }

    var template = this.parseExpression();

    if (!this.skipSymbol('import')) {
      this.fail('parseFrom: expected import', fromTok.lineno, fromTok.colno);
    }

    var names = new nodes.NodeList();
    var withContext;

    while (1) {
      // eslint-disable-line no-constant-condition
      var nextTok = this.peekToken();

      if (nextTok.type === lexer.TOKEN_BLOCK_END) {
        if (!names.children.length) {
          this.fail('parseFrom: Expected at least one import name', fromTok.lineno, fromTok.colno);
        } // Since we are manually advancing past the block end,
        // need to keep track of whitespace control (normally
        // this is done in `advanceAfterBlockEnd`


        if (nextTok.value.charAt(0) === '-') {
          this.dropLeadingWhitespace = true;
        }

        this.nextToken();
        break;
      }

      if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
        this.fail('parseFrom: expected comma', fromTok.lineno, fromTok.colno);
      }

      var name = this.parsePrimary();

      if (name.value.charAt(0) === '_') {
        this.fail('parseFrom: names starting with an underscore cannot be imported', name.lineno, name.colno);
      }

      if (this.skipSymbol('as')) {
        var alias = this.parsePrimary();
        names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
      } else {
        names.addChild(name);
      }

      withContext = this.parseWithContext();
    }

    return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
  };

  _proto.parseBlock = function parseBlock() {
    var tag = this.peekToken();

    if (!this.skipSymbol('block')) {
      this.fail('parseBlock: expected block', tag.lineno, tag.colno);
    }

    var node = new nodes.Block(tag.lineno, tag.colno);
    node.name = this.parsePrimary();

    if (!(node.name instanceof nodes.Symbol)) {
      this.fail('parseBlock: variable name expected', tag.lineno, tag.colno);
    }

    this.advanceAfterBlockEnd(tag.value);
    node.body = this.parseUntilBlocks('endblock');
    this.skipSymbol('endblock');
    this.skipSymbol(node.name.value);
    var tok = this.peekToken();

    if (!tok) {
      this.fail('parseBlock: expected endblock, got end of file');
    }

    this.advanceAfterBlockEnd(tok.value);
    return node;
  };

  _proto.parseExtends = function parseExtends() {
    var tagName = 'extends';
    var tag = this.peekToken();

    if (!this.skipSymbol(tagName)) {
      this.fail('parseTemplateRef: expected ' + tagName);
    }

    var node = new nodes.Extends(tag.lineno, tag.colno);
    node.template = this.parseExpression();
    this.advanceAfterBlockEnd(tag.value);
    return node;
  };

  _proto.parseInclude = function parseInclude() {
    var tagName = 'include';
    var tag = this.peekToken();

    if (!this.skipSymbol(tagName)) {
      this.fail('parseInclude: expected ' + tagName);
    }

    var node = new nodes.Include(tag.lineno, tag.colno);
    node.template = this.parseExpression();

    if (this.skipSymbol('ignore') && this.skipSymbol('missing')) {
      node.ignoreMissing = true;
    }

    this.advanceAfterBlockEnd(tag.value);
    return node;
  };

  _proto.parseIf = function parseIf() {
    var tag = this.peekToken();
    var node;

    if (this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {
      node = new nodes.If(tag.lineno, tag.colno);
    } else if (this.skipSymbol('ifAsync')) {
      node = new nodes.IfAsync(tag.lineno, tag.colno);
    } else {
      this.fail('parseIf: expected if, elif, or elseif', tag.lineno, tag.colno);
    }

    node.cond = this.parseExpression();
    this.advanceAfterBlockEnd(tag.value);
    node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');
    var tok = this.peekToken();

    switch (tok && tok.value) {
      case 'elseif':
      case 'elif':
        node.else_ = this.parseIf();
        break;

      case 'else':
        this.advanceAfterBlockEnd();
        node.else_ = this.parseUntilBlocks('endif');
        this.advanceAfterBlockEnd();
        break;

      case 'endif':
        node.else_ = null;
        this.advanceAfterBlockEnd();
        break;

      default:
        this.fail('parseIf: expected elif, else, or endif, got end of file');
    }

    return node;
  };

  _proto.parseSet = function parseSet() {
    var tag = this.peekToken();

    if (!this.skipSymbol('set')) {
      this.fail('parseSet: expected set', tag.lineno, tag.colno);
    }

    var node = new nodes.Set(tag.lineno, tag.colno, []);
    var target;

    while (target = this.parsePrimary()) {
      node.targets.push(target);

      if (!this.skip(lexer.TOKEN_COMMA)) {
        break;
      }
    }

    if (!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
      if (!this.skip(lexer.TOKEN_BLOCK_END)) {
        this.fail('parseSet: expected = or block end in set tag', tag.lineno, tag.colno);
      } else {
        node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks('endset'));
        node.value = null;
        this.advanceAfterBlockEnd();
      }
    } else {
      node.value = this.parseExpression();
      this.advanceAfterBlockEnd(tag.value);
    }

    return node;
  };

  _proto.parseSwitch = function parseSwitch() {
    /*
     * Store the tag names in variables in case someone ever wants to
     * customize this.
     */
    var switchStart = 'switch';
    var switchEnd = 'endswitch';
    var caseStart = 'case';
    var caseDefault = 'default'; // Get the switch tag.

    var tag = this.peekToken(); // fail early if we get some unexpected tag.

    if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
      this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
    } // parse the switch expression


    var expr = this.parseExpression(); // advance until a start of a case, a default case or an endswitch.

    this.advanceAfterBlockEnd(switchStart);
    this.parseUntilBlocks(caseStart, caseDefault, switchEnd); // this is the first case. it could also be an endswitch, we'll check.

    var tok = this.peekToken(); // create new variables for our cases and default case.

    var cases = [];
    var defaultCase; // while we're dealing with new cases nodes...

    do {
      // skip the start symbol and get the case expression
      this.skipSymbol(caseStart);
      var cond = this.parseExpression();
      this.advanceAfterBlockEnd(switchStart); // get the body of the case node and add it to the array of cases.

      var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
      cases.push(new nodes.Case(tok.line, tok.col, cond, body)); // get our next case

      tok = this.peekToken();
    } while (tok && tok.value === caseStart); // we either have a default case or a switch end.


    switch (tok.value) {
      case caseDefault:
        this.advanceAfterBlockEnd();
        defaultCase = this.parseUntilBlocks(switchEnd);
        this.advanceAfterBlockEnd();
        break;

      case switchEnd:
        this.advanceAfterBlockEnd();
        break;

      default:
        // otherwise bail because EOF
        this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
    } // and return the switch node.


    return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
  };

  _proto.parseStatement = function parseStatement() {
    var tok = this.peekToken();
    var node;

    if (tok.type !== lexer.TOKEN_SYMBOL) {
      this.fail('tag name expected', tok.lineno, tok.colno);
    }

    if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
      return null;
    }

    switch (tok.value) {
      case 'raw':
        return this.parseRaw();

      case 'verbatim':
        return this.parseRaw('verbatim');

      case 'if':
      case 'ifAsync':
        return this.parseIf();

      case 'for':
      case 'asyncEach':
      case 'asyncAll':
        return this.parseFor();

      case 'block':
        return this.parseBlock();

      case 'extends':
        return this.parseExtends();

      case 'include':
        return this.parseInclude();

      case 'set':
        return this.parseSet();

      case 'macro':
        return this.parseMacro();

      case 'call':
        return this.parseCall();

      case 'import':
        return this.parseImport();

      case 'from':
        return this.parseFrom();

      case 'filter':
        return this.parseFilterStatement();

      case 'switch':
        return this.parseSwitch();

      default:
        if (this.extensions.length) {
          for (var i = 0; i < this.extensions.length; i++) {
            var ext = this.extensions[i];

            if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
              return ext.parse(this, nodes, lexer);
            }
          }
        }

        this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);
    }

    return node;
  };

  _proto.parseRaw = function parseRaw(tagName) {
    tagName = tagName || 'raw';
    var endTagName = 'end' + tagName; // Look for upcoming raw blocks (ignore all other kinds of blocks)

    var rawBlockRegex = new RegExp('([\\s\\S]*?){%\\s*(' + tagName + '|' + endTagName + ')\\s*(?=%})%}');
    var rawLevel = 1;
    var str = '';
    var matches = null; // Skip opening raw token
    // Keep this token to track line and column numbers

    var begun = this.advanceAfterBlockEnd(); // Exit when there's nothing to match
    // or when we've found the matching "endraw" block

    while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
      var all = matches[0];
      var pre = matches[1];
      var blockName = matches[2]; // Adjust rawlevel

      if (blockName === tagName) {
        rawLevel += 1;
      } else if (blockName === endTagName) {
        rawLevel -= 1;
      } // Add to str


      if (rawLevel === 0) {
        // We want to exclude the last "endraw"
        str += pre; // Move tokenizer to beginning of endraw block

        this.tokens.backN(all.length - pre.length);
      } else {
        str += all;
      }
    }

    return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
  };

  _proto.parsePostfix = function parsePostfix(node) {
    var lookup;
    var tok = this.peekToken();

    while (tok) {
      if (tok.type === lexer.TOKEN_LEFT_PAREN) {
        // Function call
        node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
      } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
        // Reference
        lookup = this.parseAggregate();

        if (lookup.children.length > 1) {
          this.fail('invalid index');
        }

        node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
      } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {
        // Reference
        this.nextToken();
        var val = this.nextToken();

        if (val.type !== lexer.TOKEN_SYMBOL) {
          this.fail('expected name as lookup value, got ' + val.value, val.lineno, val.colno);
        } // Make a literal string because it's not a variable
        // reference


        lookup = new nodes.Literal(val.lineno, val.colno, val.value);
        node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
      } else {
        break;
      }

      tok = this.peekToken();
    }

    return node;
  };

  _proto.parseExpression = function parseExpression() {
    var node = this.parseInlineIf();
    return node;
  };

  _proto.parseInlineIf = function parseInlineIf() {
    var node = this.parseOr();

    if (this.skipSymbol('if')) {
      var condNode = this.parseOr();
      var bodyNode = node;
      node = new nodes.InlineIf(node.lineno, node.colno);
      node.body = bodyNode;
      node.cond = condNode;

      if (this.skipSymbol('else')) {
        node.else_ = this.parseOr();
      } else {
        node.else_ = null;
      }
    }

    return node;
  };

  _proto.parseOr = function parseOr() {
    var node = this.parseAnd();

    while (this.skipSymbol('or')) {
      var node2 = this.parseAnd();
      node = new nodes.Or(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseAnd = function parseAnd() {
    var node = this.parseNot();

    while (this.skipSymbol('and')) {
      var node2 = this.parseNot();
      node = new nodes.And(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseNot = function parseNot() {
    var tok = this.peekToken();

    if (this.skipSymbol('not')) {
      return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
    }

    return this.parseIn();
  };

  _proto.parseIn = function parseIn() {
    var node = this.parseIs();

    while (1) {
      // eslint-disable-line no-constant-condition
      // check if the next token is 'not'
      var tok = this.nextToken();

      if (!tok) {
        break;
      }

      var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not'; // if it wasn't 'not', put it back

      if (!invert) {
        this.pushToken(tok);
      }

      if (this.skipSymbol('in')) {
        var node2 = this.parseIs();
        node = new nodes.In(node.lineno, node.colno, node, node2);

        if (invert) {
          node = new nodes.Not(node.lineno, node.colno, node);
        }
      } else {
        // if we'd found a 'not' but this wasn't an 'in', put back the 'not'
        if (invert) {
          this.pushToken(tok);
        }

        break;
      }
    }

    return node;
  } // I put this right after "in" in the operator precedence stack. That can
  // obviously be changed to be closer to Jinja.
  ;

  _proto.parseIs = function parseIs() {
    var node = this.parseCompare(); // look for an is

    if (this.skipSymbol('is')) {
      // look for a not
      var not = this.skipSymbol('not'); // get the next node

      var node2 = this.parseCompare(); // create an Is node using the next node and the info from our Is node.

      node = new nodes.Is(node.lineno, node.colno, node, node2); // if we have a Not, create a Not node from our Is node.

      if (not) {
        node = new nodes.Not(node.lineno, node.colno, node);
      }
    } // return the node.


    return node;
  };

  _proto.parseCompare = function parseCompare() {
    var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];
    var expr = this.parseConcat();
    var ops = [];

    while (1) {
      // eslint-disable-line no-constant-condition
      var tok = this.nextToken();

      if (!tok) {
        break;
      } else if (compareOps.indexOf(tok.value) !== -1) {
        ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
      } else {
        this.pushToken(tok);
        break;
      }
    }

    if (ops.length) {
      return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
    } else {
      return expr;
    }
  } // finds the '~' for string concatenation
  ;

  _proto.parseConcat = function parseConcat() {
    var node = this.parseAdd();

    while (this.skipValue(lexer.TOKEN_TILDE, '~')) {
      var node2 = this.parseAdd();
      node = new nodes.Concat(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseAdd = function parseAdd() {
    var node = this.parseSub();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
      var node2 = this.parseSub();
      node = new nodes.Add(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseSub = function parseSub() {
    var node = this.parseMul();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
      var node2 = this.parseMul();
      node = new nodes.Sub(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseMul = function parseMul() {
    var node = this.parseDiv();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '*')) {
      var node2 = this.parseDiv();
      node = new nodes.Mul(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseDiv = function parseDiv() {
    var node = this.parseFloorDiv();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '/')) {
      var node2 = this.parseFloorDiv();
      node = new nodes.Div(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseFloorDiv = function parseFloorDiv() {
    var node = this.parseMod();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '//')) {
      var node2 = this.parseMod();
      node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseMod = function parseMod() {
    var node = this.parsePow();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '%')) {
      var node2 = this.parsePow();
      node = new nodes.Mod(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parsePow = function parsePow() {
    var node = this.parseUnary();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '**')) {
      var node2 = this.parseUnary();
      node = new nodes.Pow(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseUnary = function parseUnary(noFilters) {
    var tok = this.peekToken();
    var node;

    if (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
      node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
    } else if (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
      node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
    } else {
      node = this.parsePrimary();
    }

    if (!noFilters) {
      node = this.parseFilter(node);
    }

    return node;
  };

  _proto.parsePrimary = function parsePrimary(noPostfix) {
    var tok = this.nextToken();
    var val;
    var node = null;

    if (!tok) {
      this.fail('expected expression, got end of file');
    } else if (tok.type === lexer.TOKEN_STRING) {
      val = tok.value;
    } else if (tok.type === lexer.TOKEN_INT) {
      val = parseInt(tok.value, 10);
    } else if (tok.type === lexer.TOKEN_FLOAT) {
      val = parseFloat(tok.value);
    } else if (tok.type === lexer.TOKEN_BOOLEAN) {
      if (tok.value === 'true') {
        val = true;
      } else if (tok.value === 'false') {
        val = false;
      } else {
        this.fail('invalid boolean: ' + tok.value, tok.lineno, tok.colno);
      }
    } else if (tok.type === lexer.TOKEN_NONE) {
      val = null;
    } else if (tok.type === lexer.TOKEN_REGEX) {
      val = new RegExp(tok.value.body, tok.value.flags);
    }

    if (val !== undefined) {
      node = new nodes.Literal(tok.lineno, tok.colno, val);
    } else if (tok.type === lexer.TOKEN_SYMBOL) {
      node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
    } else {
      // See if it's an aggregate type, we need to push the
      // current delimiter token back on
      this.pushToken(tok);
      node = this.parseAggregate();
    }

    if (!noPostfix) {
      node = this.parsePostfix(node);
    }

    if (node) {
      return node;
    } else {
      throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
    }
  };

  _proto.parseFilterName = function parseFilterName() {
    var tok = this.expect(lexer.TOKEN_SYMBOL);
    var name = tok.value;

    while (this.skipValue(lexer.TOKEN_OPERATOR, '.')) {
      name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;
    }

    return new nodes.Symbol(tok.lineno, tok.colno, name);
  };

  _proto.parseFilterArgs = function parseFilterArgs(node) {
    if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
      // Get a FunCall node and add the parameters to the
      // filter
      var call = this.parsePostfix(node);
      return call.args.children;
    }

    return [];
  };

  _proto.parseFilter = function parseFilter(node) {
    while (this.skip(lexer.TOKEN_PIPE)) {
      var name = this.parseFilterName();
      node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
    }

    return node;
  };

  _proto.parseFilterStatement = function parseFilterStatement() {
    var filterTok = this.peekToken();

    if (!this.skipSymbol('filter')) {
      this.fail('parseFilterStatement: expected filter');
    }

    var name = this.parseFilterName();
    var args = this.parseFilterArgs(name);
    this.advanceAfterBlockEnd(filterTok.value);
    var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks('endfilter'));
    this.advanceAfterBlockEnd();
    var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
    return new nodes.Output(name.lineno, name.colno, [node]);
  };

  _proto.parseAggregate = function parseAggregate() {
    var tok = this.nextToken();
    var node;

    switch (tok.type) {
      case lexer.TOKEN_LEFT_PAREN:
        node = new nodes.Group(tok.lineno, tok.colno);
        break;

      case lexer.TOKEN_LEFT_BRACKET:
        node = new nodes.Array(tok.lineno, tok.colno);
        break;

      case lexer.TOKEN_LEFT_CURLY:
        node = new nodes.Dict(tok.lineno, tok.colno);
        break;

      default:
        return null;
    }

    while (1) {
      // eslint-disable-line no-constant-condition
      var type = this.peekToken().type;

      if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
        this.nextToken();
        break;
      }

      if (node.children.length > 0) {
        if (!this.skip(lexer.TOKEN_COMMA)) {
          this.fail('parseAggregate: expected comma after expression', tok.lineno, tok.colno);
        }
      }

      if (node instanceof nodes.Dict) {
        // TODO: check for errors
        var key = this.parsePrimary(); // We expect a key/value pair for dicts, separated by a
        // colon

        if (!this.skip(lexer.TOKEN_COLON)) {
          this.fail('parseAggregate: expected colon after dict key', tok.lineno, tok.colno);
        } // TODO: check for errors


        var value = this.parseExpression();
        node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
      } else {
        // TODO: check for errors
        var expr = this.parseExpression();
        node.addChild(expr);
      }
    }

    return node;
  };

  _proto.parseSignature = function parseSignature(tolerant, noParens) {
    var tok = this.peekToken();

    if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
      if (tolerant) {
        return null;
      } else {
        this.fail('expected arguments', tok.lineno, tok.colno);
      }
    }

    if (tok.type === lexer.TOKEN_LEFT_PAREN) {
      tok = this.nextToken();
    }

    var args = new nodes.NodeList(tok.lineno, tok.colno);
    var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
    var checkComma = false;

    while (1) {
      // eslint-disable-line no-constant-condition
      tok = this.peekToken();

      if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
        this.nextToken();
        break;
      } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
        break;
      }

      if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
        this.fail('parseSignature: expected comma after expression', tok.lineno, tok.colno);
      } else {
        var arg = this.parseExpression();

        if (this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
          kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
        } else {
          args.addChild(arg);
        }
      }

      checkComma = true;
    }

    if (kwargs.children.length) {
      args.addChild(kwargs);
    }

    return args;
  };

  _proto.parseUntilBlocks = function parseUntilBlocks() {
    var prev = this.breakOnBlocks;

    for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
      blockNames[_key] = arguments[_key];
    }

    this.breakOnBlocks = blockNames;
    var ret = this.parse();
    this.breakOnBlocks = prev;
    return ret;
  };

  _proto.parseNodes = function parseNodes() {
    var tok;
    var buf = [];

    while (tok = this.nextToken()) {
      if (tok.type === lexer.TOKEN_DATA) {
        var data = tok.value;
        var nextToken = this.peekToken();
        var nextVal = nextToken && nextToken.value; // If the last token has "-" we need to trim the
        // leading whitespace of the data. This is marked with
        // the `dropLeadingWhitespace` variable.

        if (this.dropLeadingWhitespace) {
          // TODO: this could be optimized (don't use regex)
          data = data.replace(/^\s*/, '');
          this.dropLeadingWhitespace = false;
        } // Same for the succeeding block start token


        if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === '-' || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === '-' || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === '-')) {
          // TODO: this could be optimized (don't use regex)
          data = data.replace(/\s*$/, '');
        }

        buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
      } else if (tok.type === lexer.TOKEN_BLOCK_START) {
        this.dropLeadingWhitespace = false;
        var n = this.parseStatement();

        if (!n) {
          break;
        }

        buf.push(n);
      } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
        var e = this.parseExpression();
        this.dropLeadingWhitespace = false;
        this.advanceAfterVariableEnd();
        buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
      } else if (tok.type === lexer.TOKEN_COMMENT) {
        this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === '-';
      } else {
        // Ignore comments, otherwise this should be an error
        this.fail('Unexpected token at top-level: ' + tok.type, tok.lineno, tok.colno);
      }
    }

    return buf;
  };

  _proto.parse = function parse() {
    return new nodes.NodeList(0, 0, this.parseNodes());
  };

  _proto.parseAsRoot = function parseAsRoot() {
    return new nodes.Root(0, 0, this.parseNodes());
  };

  return Parser;
}(Obj); // var util = require('util');
// var l = lexer.lex('{%- if x -%}\n hello {% endif %}');
// var t;
// while((t = l.nextToken())) {
//     console.log(util.inspect(t));
// }
// var p = new Parser(lexer.lex('hello {% filter title %}' +
//                              'Hello madam how are you' +
//                              '{% endfilter %}'));
// var n = p.parseAsRoot();
// nodes.printNodes(n);


module.exports = {
  parse: function parse(src, extensions, opts) {
    var p = new Parser(lexer.lex(src, opts));

    if (extensions !== undefined) {
      p.extensions = extensions;
    }

    return p.parseAsRoot();
  },
  Parser: Parser
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var lib = __webpack_require__(0);

var whitespaceChars = " \n\t\r\xA0";
var delimChars = '()[]{}%*-+~/#,:|.<>=!';
var intChars = '0123456789';
var BLOCK_START = '{%';
var BLOCK_END = '%}';
var VARIABLE_START = '{{';
var VARIABLE_END = '}}';
var COMMENT_START = '{#';
var COMMENT_END = '#}';
var TOKEN_STRING = 'string';
var TOKEN_WHITESPACE = 'whitespace';
var TOKEN_DATA = 'data';
var TOKEN_BLOCK_START = 'block-start';
var TOKEN_BLOCK_END = 'block-end';
var TOKEN_VARIABLE_START = 'variable-start';
var TOKEN_VARIABLE_END = 'variable-end';
var TOKEN_COMMENT = 'comment';
var TOKEN_LEFT_PAREN = 'left-paren';
var TOKEN_RIGHT_PAREN = 'right-paren';
var TOKEN_LEFT_BRACKET = 'left-bracket';
var TOKEN_RIGHT_BRACKET = 'right-bracket';
var TOKEN_LEFT_CURLY = 'left-curly';
var TOKEN_RIGHT_CURLY = 'right-curly';
var TOKEN_OPERATOR = 'operator';
var TOKEN_COMMA = 'comma';
var TOKEN_COLON = 'colon';
var TOKEN_TILDE = 'tilde';
var TOKEN_PIPE = 'pipe';
var TOKEN_INT = 'int';
var TOKEN_FLOAT = 'float';
var TOKEN_BOOLEAN = 'boolean';
var TOKEN_NONE = 'none';
var TOKEN_SYMBOL = 'symbol';
var TOKEN_SPECIAL = 'special';
var TOKEN_REGEX = 'regex';

function token(type, value, lineno, colno) {
  return {
    type: type,
    value: value,
    lineno: lineno,
    colno: colno
  };
}

var Tokenizer = /*#__PURE__*/function () {
  function Tokenizer(str, opts) {
    this.str = str;
    this.index = 0;
    this.len = str.length;
    this.lineno = 0;
    this.colno = 0;
    this.in_code = false;
    opts = opts || {};
    var tags = opts.tags || {};
    this.tags = {
      BLOCK_START: tags.blockStart || BLOCK_START,
      BLOCK_END: tags.blockEnd || BLOCK_END,
      VARIABLE_START: tags.variableStart || VARIABLE_START,
      VARIABLE_END: tags.variableEnd || VARIABLE_END,
      COMMENT_START: tags.commentStart || COMMENT_START,
      COMMENT_END: tags.commentEnd || COMMENT_END
    };
    this.trimBlocks = !!opts.trimBlocks;
    this.lstripBlocks = !!opts.lstripBlocks;
  }

  var _proto = Tokenizer.prototype;

  _proto.nextToken = function nextToken() {
    var lineno = this.lineno;
    var colno = this.colno;
    var tok;

    if (this.in_code) {
      // Otherwise, if we are in a block parse it as code
      var cur = this.current();

      if (this.isFinished()) {
        // We have nothing else to parse
        return null;
      } else if (cur === '"' || cur === '\'') {
        // We've hit a string
        return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
      } else if (tok = this._extract(whitespaceChars)) {
        // We hit some whitespace
        return token(TOKEN_WHITESPACE, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString('-' + this.tags.BLOCK_END))) {
        // Special check for the block end tag
        //
        // It is a requirement that start and end tags are composed of
        // delimiter characters (%{}[] etc), and our code always
        // breaks on delimiters so we can assume the token parsing
        // doesn't consume these elsewhere
        this.in_code = false;

        if (this.trimBlocks) {
          cur = this.current();

          if (cur === '\n') {
            // Skip newline
            this.forward();
          } else if (cur === '\r') {
            // Skip CRLF newline
            this.forward();
            cur = this.current();

            if (cur === '\n') {
              this.forward();
            } else {
              // Was not a CRLF, so go back
              this.back();
            }
          }
        }

        return token(TOKEN_BLOCK_END, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString('-' + this.tags.VARIABLE_END))) {
        // Special check for variable end tag (see above)
        this.in_code = false;
        return token(TOKEN_VARIABLE_END, tok, lineno, colno);
      } else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {
        // Skip past 'r/'.
        this.forwardN(2); // Extract until the end of the regex -- / ends it, \/ does not.

        var regexBody = '';

        while (!this.isFinished()) {
          if (this.current() === '/' && this.previous() !== '\\') {
            this.forward();
            break;
          } else {
            regexBody += this.current();
            this.forward();
          }
        } // Check for flags.
        // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)


        var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];
        var regexFlags = '';

        while (!this.isFinished()) {
          var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;

          if (isCurrentAFlag) {
            regexFlags += this.current();
            this.forward();
          } else {
            break;
          }
        }

        return token(TOKEN_REGEX, {
          body: regexBody,
          flags: regexFlags
        }, lineno, colno);
      } else if (delimChars.indexOf(cur) !== -1) {
        // We've hit a delimiter (a special char like a bracket)
        this.forward();
        var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];
        var curComplex = cur + this.current();
        var type;

        if (lib.indexOf(complexOps, curComplex) !== -1) {
          this.forward();
          cur = curComplex; // See if this is a strict equality/inequality comparator

          if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
            cur = curComplex + this.current();
            this.forward();
          }
        }

        switch (cur) {
          case '(':
            type = TOKEN_LEFT_PAREN;
            break;

          case ')':
            type = TOKEN_RIGHT_PAREN;
            break;

          case '[':
            type = TOKEN_LEFT_BRACKET;
            break;

          case ']':
            type = TOKEN_RIGHT_BRACKET;
            break;

          case '{':
            type = TOKEN_LEFT_CURLY;
            break;

          case '}':
            type = TOKEN_RIGHT_CURLY;
            break;

          case ',':
            type = TOKEN_COMMA;
            break;

          case ':':
            type = TOKEN_COLON;
            break;

          case '~':
            type = TOKEN_TILDE;
            break;

          case '|':
            type = TOKEN_PIPE;
            break;

          default:
            type = TOKEN_OPERATOR;
        }

        return token(type, cur, lineno, colno);
      } else {
        // We are not at whitespace or a delimiter, so extract the
        // text and parse it
        tok = this._extractUntil(whitespaceChars + delimChars);

        if (tok.match(/^[-+]?[0-9]+$/)) {
          if (this.current() === '.') {
            this.forward();

            var dec = this._extract(intChars);

            return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);
          } else {
            return token(TOKEN_INT, tok, lineno, colno);
          }
        } else if (tok.match(/^(true|false)$/)) {
          return token(TOKEN_BOOLEAN, tok, lineno, colno);
        } else if (tok === 'none') {
          return token(TOKEN_NONE, tok, lineno, colno);
          /*
           * Added to make the test `null is null` evaluate truthily.
           * Otherwise, Nunjucks will look up null in the context and
           * return `undefined`, which is not what we want. This *may* have
           * consequences is someone is using null in their templates as a
           * variable.
           */
        } else if (tok === 'null') {
          return token(TOKEN_NONE, tok, lineno, colno);
        } else if (tok) {
          return token(TOKEN_SYMBOL, tok, lineno, colno);
        } else {
          throw new Error('Unexpected value while parsing: ' + tok);
        }
      }
    } else {
      // Parse out the template text, breaking on tag
      // delimiters because we need to look for block/variable start
      // tags (don't use the full delimChars for optimization)
      var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);

      if (this.isFinished()) {
        return null;
      } else if ((tok = this._extractString(this.tags.BLOCK_START + '-')) || (tok = this._extractString(this.tags.BLOCK_START))) {
        this.in_code = true;
        return token(TOKEN_BLOCK_START, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.VARIABLE_START + '-')) || (tok = this._extractString(this.tags.VARIABLE_START))) {
        this.in_code = true;
        return token(TOKEN_VARIABLE_START, tok, lineno, colno);
      } else {
        tok = '';
        var data;
        var inComment = false;

        if (this._matches(this.tags.COMMENT_START)) {
          inComment = true;
          tok = this._extractString(this.tags.COMMENT_START);
        } // Continually consume text, breaking on the tag delimiter
        // characters and checking to see if it's a start tag.
        //
        // We could hit the end of the template in the middle of
        // our looping, so check for the null return value from
        // _extractUntil


        while ((data = this._extractUntil(beginChars)) !== null) {
          tok += data;

          if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
            if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
              var lastLine = tok.slice(-this.colno);

              if (/^\s+$/.test(lastLine)) {
                // Remove block leading whitespace from beginning of the string
                tok = tok.slice(0, -this.colno);

                if (!tok.length) {
                  // All data removed, collapse to avoid unnecessary nodes
                  // by returning next token (block start)
                  return this.nextToken();
                }
              }
            } // If it is a start tag, stop looping


            break;
          } else if (this._matches(this.tags.COMMENT_END)) {
            if (!inComment) {
              throw new Error('unexpected end of comment');
            }

            tok += this._extractString(this.tags.COMMENT_END);
            break;
          } else {
            // It does not match any tag, so add the character and
            // carry on
            tok += this.current();
            this.forward();
          }
        }

        if (data === null && inComment) {
          throw new Error('expected end of comment, got end of file');
        }

        return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
      }
    }
  };

  _proto._parseString = function _parseString(delimiter) {
    this.forward();
    var str = '';

    while (!this.isFinished() && this.current() !== delimiter) {
      var cur = this.current();

      if (cur === '\\') {
        this.forward();

        switch (this.current()) {
          case 'n':
            str += '\n';
            break;

          case 't':
            str += '\t';
            break;

          case 'r':
            str += '\r';
            break;

          default:
            str += this.current();
        }

        this.forward();
      } else {
        str += cur;
        this.forward();
      }
    }

    this.forward();
    return str;
  };

  _proto._matches = function _matches(str) {
    if (this.index + str.length > this.len) {
      return null;
    }

    var m = this.str.slice(this.index, this.index + str.length);
    return m === str;
  };

  _proto._extractString = function _extractString(str) {
    if (this._matches(str)) {
      this.forwardN(str.length);
      return str;
    }

    return null;
  };

  _proto._extractUntil = function _extractUntil(charString) {
    // Extract all non-matching chars, with the default matching set
    // to everything
    return this._extractMatching(true, charString || '');
  };

  _proto._extract = function _extract(charString) {
    // Extract all matching chars (no default, so charString must be
    // explicit)
    return this._extractMatching(false, charString);
  };

  _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
    // Pull out characters until a breaking char is hit.
    // If breakOnMatch is false, a non-matching char stops it.
    // If breakOnMatch is true, a matching char stops it.
    if (this.isFinished()) {
      return null;
    }

    var first = charString.indexOf(this.current()); // Only proceed if the first character doesn't meet our condition

    if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
      var t = this.current();
      this.forward(); // And pull out all the chars one at a time until we hit a
      // breaking char

      var idx = charString.indexOf(this.current());

      while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
        t += this.current();
        this.forward();
        idx = charString.indexOf(this.current());
      }

      return t;
    }

    return '';
  };

  _proto._extractRegex = function _extractRegex(regex) {
    var matches = this.currentStr().match(regex);

    if (!matches) {
      return null;
    } // Move forward whatever was matched


    this.forwardN(matches[0].length);
    return matches;
  };

  _proto.isFinished = function isFinished() {
    return this.index >= this.len;
  };

  _proto.forwardN = function forwardN(n) {
    for (var i = 0; i < n; i++) {
      this.forward();
    }
  };

  _proto.forward = function forward() {
    this.index++;

    if (this.previous() === '\n') {
      this.lineno++;
      this.colno = 0;
    } else {
      this.colno++;
    }
  };

  _proto.backN = function backN(n) {
    for (var i = 0; i < n; i++) {
      this.back();
    }
  };

  _proto.back = function back() {
    this.index--;

    if (this.current() === '\n') {
      this.lineno--;
      var idx = this.src.lastIndexOf('\n', this.index - 1);

      if (idx === -1) {
        this.colno = this.index;
      } else {
        this.colno = this.index - idx;
      }
    } else {
      this.colno--;
    }
  } // current returns current character
  ;

  _proto.current = function current() {
    if (!this.isFinished()) {
      return this.str.charAt(this.index);
    }

    return '';
  } // currentStr returns what's left of the unparsed string
  ;

  _proto.currentStr = function currentStr() {
    if (!this.isFinished()) {
      return this.str.substr(this.index);
    }

    return '';
  };

  _proto.previous = function previous() {
    return this.str.charAt(this.index - 1);
  };

  return Tokenizer;
}();

module.exports = {
  lex: function lex(src, opts) {
    return new Tokenizer(src, opts);
  },
  TOKEN_STRING: TOKEN_STRING,
  TOKEN_WHITESPACE: TOKEN_WHITESPACE,
  TOKEN_DATA: TOKEN_DATA,
  TOKEN_BLOCK_START: TOKEN_BLOCK_START,
  TOKEN_BLOCK_END: TOKEN_BLOCK_END,
  TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,
  TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,
  TOKEN_COMMENT: TOKEN_COMMENT,
  TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,
  TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,
  TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,
  TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,
  TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,
  TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,
  TOKEN_OPERATOR: TOKEN_OPERATOR,
  TOKEN_COMMA: TOKEN_COMMA,
  TOKEN_COLON: TOKEN_COLON,
  TOKEN_TILDE: TOKEN_TILDE,
  TOKEN_PIPE: TOKEN_PIPE,
  TOKEN_INT: TOKEN_INT,
  TOKEN_FLOAT: TOKEN_FLOAT,
  TOKEN_BOOLEAN: TOKEN_BOOLEAN,
  TOKEN_NONE: TOKEN_NONE,
  TOKEN_SYMBOL: TOKEN_SYMBOL,
  TOKEN_SPECIAL: TOKEN_SPECIAL,
  TOKEN_REGEX: TOKEN_REGEX
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Loader = __webpack_require__(6);

var _require = __webpack_require__(19),
    PrecompiledLoader = _require.PrecompiledLoader;

var WebLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(WebLoader, _Loader);

  function WebLoader(baseURL, opts) {
    var _this;

    _this = _Loader.call(this) || this;
    _this.baseURL = baseURL || '.';
    opts = opts || {}; // By default, the cache is turned off because there's no way
    // to "watch" templates over HTTP, so they are re-downloaded
    // and compiled each time. (Remember, PRECOMPILE YOUR
    // TEMPLATES in production!)

    _this.useCache = !!opts.useCache; // We default `async` to false so that the simple synchronous
    // API can be used when you aren't doing anything async in
    // your templates (which is most of the time). This performs a
    // sync ajax request, but that's ok because it should *only*
    // happen in development. PRECOMPILE YOUR TEMPLATES.

    _this.async = !!opts.async;
    return _this;
  }

  var _proto = WebLoader.prototype;

  _proto.resolve = function resolve(from, to) {
    throw new Error('relative templates not support in the browser yet');
  };

  _proto.getSource = function getSource(name, cb) {
    var _this2 = this;

    var useCache = this.useCache;
    var result;
    this.fetch(this.baseURL + '/' + name, function (err, src) {
      if (err) {
        if (cb) {
          cb(err.content);
        } else if (err.status === 404) {
          result = null;
        } else {
          throw err.content;
        }
      } else {
        result = {
          src: src,
          path: name,
          noCache: !useCache
        };

        _this2.emit('load', name, result);

        if (cb) {
          cb(null, result);
        }
      }
    }); // if this WebLoader isn't running asynchronously, the
    // fetch above would actually run sync and we'll have a
    // result here

    return result;
  };

  _proto.fetch = function fetch(url, cb) {
    // Only in the browser please
    if (typeof window === 'undefined') {
      throw new Error('WebLoader can only by used in a browser');
    }

    var ajax = new XMLHttpRequest();
    var loading = true;

    ajax.onreadystatechange = function () {
      if (ajax.readyState === 4 && loading) {
        loading = false;

        if (ajax.status === 0 || ajax.status === 200) {
          cb(null, ajax.responseText);
        } else {
          cb({
            status: ajax.status,
            content: ajax.responseText
          });
        }
      }
    };

    url += (url.indexOf('?') === -1 ? '?' : '&') + 's=' + new Date().getTime();
    ajax.open('GET', url, this.async);
    ajax.send();
  };

  return WebLoader;
}(Loader);

module.exports = {
  WebLoader: WebLoader,
  PrecompiledLoader: PrecompiledLoader
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var lib = __webpack_require__(0);

var _require = __webpack_require__(7),
    Environment = _require.Environment,
    Template = _require.Template;

var Loader = __webpack_require__(6);

var loaders = __webpack_require__(10);

var precompile = __webpack_require__(23);

var compiler = __webpack_require__(5);

var parser = __webpack_require__(8);

var lexer = __webpack_require__(9);

var runtime = __webpack_require__(2);

var nodes = __webpack_require__(3);

var installJinjaCompat = __webpack_require__(25); // A single instance of an environment, since this is so commonly used


var e;

function configure(templatesPath, opts) {
  opts = opts || {};

  if (lib.isObject(templatesPath)) {
    opts = templatesPath;
    templatesPath = null;
  }

  var TemplateLoader;

  if (loaders.FileSystemLoader) {
    TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
      watch: opts.watch,
      noCache: opts.noCache
    });
  } else if (loaders.WebLoader) {
    TemplateLoader = new loaders.WebLoader(templatesPath, {
      useCache: opts.web && opts.web.useCache,
      async: opts.web && opts.web.async
    });
  }

  e = new Environment(TemplateLoader, opts);

  if (opts && opts.express) {
    e.express(opts.express);
  }

  return e;
}

module.exports = {
  Environment: Environment,
  Template: Template,
  Loader: Loader,
  FileSystemLoader: loaders.FileSystemLoader,
  NodeResolveLoader: loaders.NodeResolveLoader,
  PrecompiledLoader: loaders.PrecompiledLoader,
  WebLoader: loaders.WebLoader,
  compiler: compiler,
  parser: parser,
  lexer: lexer,
  runtime: runtime,
  lib: lib,
  nodes: nodes,
  installJinjaCompat: installJinjaCompat,
  configure: configure,
  reset: function reset() {
    e = undefined;
  },
  compile: function compile(src, env, path, eagerCompile) {
    if (!e) {
      configure();
    }

    return new Template(src, env, path, eagerCompile);
  },
  render: function render(name, ctx, cb) {
    if (!e) {
      configure();
    }

    return e.render(name, ctx, cb);
  },
  renderString: function renderString(src, ctx, cb) {
    if (!e) {
      configure();
    }

    return e.renderString(src, ctx, cb);
  },
  precompile: precompile ? precompile.precompile : undefined,
  precompileString: precompile ? precompile.precompileString : undefined
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// rawAsap provides everything we need except exception management.
var rawAsap = __webpack_require__(13);
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

/* globals self */
var scope = typeof global !== "undefined" ? global : self;
var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.jss
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 14 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// MIT license (by Elan Shanker).
(function(globals) {
  'use strict';

  var executeSync = function(){
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'function'){
      args[0].apply(null, args.splice(1));
    }
  };

  var executeAsync = function(fn){
    if (typeof setImmediate === 'function') {
      setImmediate(fn);
    } else if (typeof process !== 'undefined' && process.nextTick) {
      process.nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  };

  var makeIterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return (index < tasks.length - 1) ? makeCallback(index + 1): null;
      };
      return fn;
    };
    return makeCallback(0);
  };
  
  var _isArray = Array.isArray || function(maybeArray){
    return Object.prototype.toString.call(maybeArray) === '[object Array]';
  };

  var waterfall = function (tasks, callback, forceAsync) {
    var nextTick = forceAsync ? executeAsync : executeSync;
    callback = callback || function () {};
    if (!_isArray(tasks)) {
      var err = new Error('First argument to waterfall must be an array of functions');
      return callback(err);
    }
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);
          callback = function () {};
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          } else {
            args.push(callback);
          }
          nextTick(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(makeIterator(tasks))();
  };

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return waterfall;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = waterfall; // CommonJS
  } else {
    globals.waterfall = waterfall; // <script>
  }
})(this);


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nodes = __webpack_require__(3);

var lib = __webpack_require__(0);

var sym = 0;

function gensym() {
  return 'hole_' + sym++;
} // copy-on-write version of map


function mapCOW(arr, func) {
  var res = null;

  for (var i = 0; i < arr.length; i++) {
    var item = func(arr[i]);

    if (item !== arr[i]) {
      if (!res) {
        res = arr.slice();
      }

      res[i] = item;
    }
  }

  return res || arr;
}

function walk(ast, func, depthFirst) {
  if (!(ast instanceof nodes.Node)) {
    return ast;
  }

  if (!depthFirst) {
    var astT = func(ast);

    if (astT && astT !== ast) {
      return astT;
    }
  }

  if (ast instanceof nodes.NodeList) {
    var children = mapCOW(ast.children, function (node) {
      return walk(node, func, depthFirst);
    });

    if (children !== ast.children) {
      ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
    }
  } else if (ast instanceof nodes.CallExtension) {
    var args = walk(ast.args, func, depthFirst);
    var contentArgs = mapCOW(ast.contentArgs, function (node) {
      return walk(node, func, depthFirst);
    });

    if (args !== ast.args || contentArgs !== ast.contentArgs) {
      ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
    }
  } else {
    var props = ast.fields.map(function (field) {
      return ast[field];
    });
    var propsT = mapCOW(props, function (prop) {
      return walk(prop, func, depthFirst);
    });

    if (propsT !== props) {
      ast = new nodes[ast.typename](ast.lineno, ast.colno);
      propsT.forEach(function (prop, i) {
        ast[ast.fields[i]] = prop;
      });
    }
  }

  return depthFirst ? func(ast) || ast : ast;
}

function depthWalk(ast, func) {
  return walk(ast, func, true);
}

function _liftFilters(node, asyncFilters, prop) {
  var children = [];
  var walked = depthWalk(prop ? node[prop] : node, function (descNode) {
    var symbol;

    if (descNode instanceof nodes.Block) {
      return descNode;
    } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
      symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
      children.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
    }

    return symbol;
  });

  if (prop) {
    node[prop] = walked;
  } else {
    node = walked;
  }

  if (children.length) {
    children.push(node);
    return new nodes.NodeList(node.lineno, node.colno, children);
  } else {
    return node;
  }
}

function liftFilters(ast, asyncFilters) {
  return depthWalk(ast, function (node) {
    if (node instanceof nodes.Output) {
      return _liftFilters(node, asyncFilters);
    } else if (node instanceof nodes.Set) {
      return _liftFilters(node, asyncFilters, 'value');
    } else if (node instanceof nodes.For) {
      return _liftFilters(node, asyncFilters, 'arr');
    } else if (node instanceof nodes.If) {
      return _liftFilters(node, asyncFilters, 'cond');
    } else if (node instanceof nodes.CallExtension) {
      return _liftFilters(node, asyncFilters, 'args');
    } else {
      return undefined;
    }
  });
}

function liftSuper(ast) {
  return walk(ast, function (blockNode) {
    if (!(blockNode instanceof nodes.Block)) {
      return;
    }

    var hasSuper = false;
    var symbol = gensym();
    blockNode.body = walk(blockNode.body, function (node) {
      // eslint-disable-line consistent-return
      if (node instanceof nodes.FunCall && node.name.value === 'super') {
        hasSuper = true;
        return new nodes.Symbol(node.lineno, node.colno, symbol);
      }
    });

    if (hasSuper) {
      blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
    }
  });
}

function convertStatements(ast) {
  return depthWalk(ast, function (node) {
    if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
      return undefined;
    }

    var async = false;
    walk(node, function (child) {
      if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
        async = true; // Stop iterating by returning the node

        return child;
      }

      return undefined;
    });

    if (async) {
      if (node instanceof nodes.If) {
        return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
      } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
        return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
      }
    }

    return undefined;
  });
}

function cps(ast, asyncFilters) {
  return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
}

function transform(ast, asyncFilters) {
  return cps(ast, asyncFilters || []);
} // var parser = require('./parser');
// var src = 'hello {% foo %}{% endfoo %} end';
// var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);
// nodes.printNodes(ast);


module.exports = {
  transform: transform
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var lib = __webpack_require__(0);

var r = __webpack_require__(2);

var exports = module.exports = {};

function normalize(value, defaultValue) {
  if (value === null || value === undefined || value === false) {
    return defaultValue;
  }

  return value;
}

exports.abs = Math.abs;

function isNaN(num) {
  return num !== num; // eslint-disable-line no-self-compare
}

function batch(arr, linecount, fillWith) {
  var i;
  var res = [];
  var tmp = [];

  for (i = 0; i < arr.length; i++) {
    if (i % linecount === 0 && tmp.length) {
      res.push(tmp);
      tmp = [];
    }

    tmp.push(arr[i]);
  }

  if (tmp.length) {
    if (fillWith) {
      for (i = tmp.length; i < linecount; i++) {
        tmp.push(fillWith);
      }
    }

    res.push(tmp);
  }

  return res;
}

exports.batch = batch;

function capitalize(str) {
  str = normalize(str, '');
  var ret = str.toLowerCase();
  return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
}

exports.capitalize = capitalize;

function center(str, width) {
  str = normalize(str, '');
  width = width || 80;

  if (str.length >= width) {
    return str;
  }

  var spaces = width - str.length;
  var pre = lib.repeat(' ', spaces / 2 - spaces % 2);
  var post = lib.repeat(' ', spaces / 2);
  return r.copySafeness(str, pre + str + post);
}

exports.center = center;

function default_(val, def, bool) {
  if (bool) {
    return val || def;
  } else {
    return val !== undefined ? val : def;
  }
} // TODO: it is confusing to export something called 'default'


exports['default'] = default_; // eslint-disable-line dot-notation

function dictsort(val, caseSensitive, by) {
  if (!lib.isObject(val)) {
    throw new lib.TemplateError('dictsort filter: val must be an object');
  }

  var array = []; // deliberately include properties from the object's prototype

  for (var k in val) {
    // eslint-disable-line guard-for-in, no-restricted-syntax
    array.push([k, val[k]]);
  }

  var si;

  if (by === undefined || by === 'key') {
    si = 0;
  } else if (by === 'value') {
    si = 1;
  } else {
    throw new lib.TemplateError('dictsort filter: You can only sort by either key or value');
  }

  array.sort(function (t1, t2) {
    var a = t1[si];
    var b = t2[si];

    if (!caseSensitive) {
      if (lib.isString(a)) {
        a = a.toUpperCase();
      }

      if (lib.isString(b)) {
        b = b.toUpperCase();
      }
    }

    return a > b ? 1 : a === b ? 0 : -1; // eslint-disable-line no-nested-ternary
  });
  return array;
}

exports.dictsort = dictsort;

function dump(obj, spaces) {
  return JSON.stringify(obj, null, spaces);
}

exports.dump = dump;

function escape(str) {
  if (str instanceof r.SafeString) {
    return str;
  }

  str = str === null || str === undefined ? '' : str;
  return r.markSafe(lib.escape(str.toString()));
}

exports.escape = escape;

function safe(str) {
  if (str instanceof r.SafeString) {
    return str;
  }

  str = str === null || str === undefined ? '' : str;
  return r.markSafe(str.toString());
}

exports.safe = safe;

function first(arr) {
  return arr[0];
}

exports.first = first;

function forceescape(str) {
  str = str === null || str === undefined ? '' : str;
  return r.markSafe(lib.escape(str.toString()));
}

exports.forceescape = forceescape;

function groupby(arr, attr) {
  return lib.groupBy(arr, attr, this.env.opts.throwOnUndefined);
}

exports.groupby = groupby;

function indent(str, width, indentfirst) {
  str = normalize(str, '');

  if (str === '') {
    return '';
  }

  width = width || 4; // let res = '';

  var lines = str.split('\n');
  var sp = lib.repeat(' ', width);
  var res = lines.map(function (l, i) {
    return i === 0 && !indentfirst ? l : "" + sp + l;
  }).join('\n');
  return r.copySafeness(str, res);
}

exports.indent = indent;

function join(arr, del, attr) {
  del = del || '';

  if (attr) {
    arr = lib.map(arr, function (v) {
      return v[attr];
    });
  }

  return arr.join(del);
}

exports.join = join;

function last(arr) {
  return arr[arr.length - 1];
}

exports.last = last;

function lengthFilter(val) {
  var value = normalize(val, '');

  if (value !== undefined) {
    if (typeof Map === 'function' && value instanceof Map || typeof Set === 'function' && value instanceof Set) {
      // ECMAScript 2015 Maps and Sets
      return value.size;
    }

    if (lib.isObject(value) && !(value instanceof r.SafeString)) {
      // Objects (besides SafeStrings), non-primative Arrays
      return lib.keys(value).length;
    }

    return value.length;
  }

  return 0;
}

exports.length = lengthFilter;

function list(val) {
  if (lib.isString(val)) {
    return val.split('');
  } else if (lib.isObject(val)) {
    return lib._entries(val || {}).map(function (_ref) {
      var key = _ref[0],
          value = _ref[1];
      return {
        key: key,
        value: value
      };
    });
  } else if (lib.isArray(val)) {
    return val;
  } else {
    throw new lib.TemplateError('list filter: type not iterable');
  }
}

exports.list = list;

function lower(str) {
  str = normalize(str, '');
  return str.toLowerCase();
}

exports.lower = lower;

function nl2br(str) {
  if (str === null || str === undefined) {
    return '';
  }

  return r.copySafeness(str, str.replace(/\r\n|\n/g, '<br />\n'));
}

exports.nl2br = nl2br;

function random(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

exports.random = random;
/**
 * Construct select or reject filter
 *
 * @param {boolean} expectedTestResult
 * @returns {function(array, string, *): array}
 */

function getSelectOrReject(expectedTestResult) {
  function filter(arr, testName, secondArg) {
    if (testName === void 0) {
      testName = 'truthy';
    }

    var context = this;
    var test = context.env.getTest(testName);
    return lib.toArray(arr).filter(function examineTestResult(item) {
      return test.call(context, item, secondArg) === expectedTestResult;
    });
  }

  return filter;
}

exports.reject = getSelectOrReject(false);

function rejectattr(arr, attr) {
  return arr.filter(function (item) {
    return !item[attr];
  });
}

exports.rejectattr = rejectattr;
exports.select = getSelectOrReject(true);

function selectattr(arr, attr) {
  return arr.filter(function (item) {
    return !!item[attr];
  });
}

exports.selectattr = selectattr;

function replace(str, old, new_, maxCount) {
  var originalStr = str;

  if (old instanceof RegExp) {
    return str.replace(old, new_);
  }

  if (typeof maxCount === 'undefined') {
    maxCount = -1;
  }

  var res = ''; // Output
  // Cast Numbers in the search term to string

  if (typeof old === 'number') {
    old = '' + old;
  } else if (typeof old !== 'string') {
    // If it is something other than number or string,
    // return the original string
    return str;
  } // Cast numbers in the replacement to string


  if (typeof str === 'number') {
    str = '' + str;
  } // If by now, we don't have a string, throw it back


  if (typeof str !== 'string' && !(str instanceof r.SafeString)) {
    return str;
  } // ShortCircuits


  if (old === '') {
    // Mimic the python behaviour: empty string is replaced
    // by replacement e.g. "abc"|replace("", ".") -> .a.b.c.
    res = new_ + str.split('').join(new_) + new_;
    return r.copySafeness(str, res);
  }

  var nextIndex = str.indexOf(old); // if # of replacements to perform is 0, or the string to does
  // not contain the old value, return the string

  if (maxCount === 0 || nextIndex === -1) {
    return str;
  }

  var pos = 0;
  var count = 0; // # of replacements made

  while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
    // Grab the next chunk of src string and add it with the
    // replacement, to the result
    res += str.substring(pos, nextIndex) + new_; // Increment our pointer in the src string

    pos = nextIndex + old.length;
    count++; // See if there are any more replacements to be made

    nextIndex = str.indexOf(old, pos);
  } // We've either reached the end, or done the max # of
  // replacements, tack on any remaining string


  if (pos < str.length) {
    res += str.substring(pos);
  }

  return r.copySafeness(originalStr, res);
}

exports.replace = replace;

function reverse(val) {
  var arr;

  if (lib.isString(val)) {
    arr = list(val);
  } else {
    // Copy it
    arr = lib.map(val, function (v) {
      return v;
    });
  }

  arr.reverse();

  if (lib.isString(val)) {
    return r.copySafeness(val, arr.join(''));
  }

  return arr;
}

exports.reverse = reverse;

function round(val, precision, method) {
  precision = precision || 0;
  var factor = Math.pow(10, precision);
  var rounder;

  if (method === 'ceil') {
    rounder = Math.ceil;
  } else if (method === 'floor') {
    rounder = Math.floor;
  } else {
    rounder = Math.round;
  }

  return rounder(val * factor) / factor;
}

exports.round = round;

function slice(arr, slices, fillWith) {
  var sliceLength = Math.floor(arr.length / slices);
  var extra = arr.length % slices;
  var res = [];
  var offset = 0;

  for (var i = 0; i < slices; i++) {
    var start = offset + i * sliceLength;

    if (i < extra) {
      offset++;
    }

    var end = offset + (i + 1) * sliceLength;
    var currSlice = arr.slice(start, end);

    if (fillWith && i >= extra) {
      currSlice.push(fillWith);
    }

    res.push(currSlice);
  }

  return res;
}

exports.slice = slice;

function sum(arr, attr, start) {
  if (start === void 0) {
    start = 0;
  }

  if (attr) {
    arr = lib.map(arr, function (v) {
      return v[attr];
    });
  }

  return start + arr.reduce(function (a, b) {
    return a + b;
  }, 0);
}

exports.sum = sum;
exports.sort = r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function sortFilter(arr, reversed, caseSens, attr) {
  var _this = this;

  // Copy it
  var array = lib.map(arr, function (v) {
    return v;
  });
  var getAttribute = lib.getAttrGetter(attr);
  array.sort(function (a, b) {
    var x = attr ? getAttribute(a) : a;
    var y = attr ? getAttribute(b) : b;

    if (_this.env.opts.throwOnUndefined && attr && (x === undefined || y === undefined)) {
      throw new TypeError("sort: attribute \"" + attr + "\" resolved to undefined");
    }

    if (!caseSens && lib.isString(x) && lib.isString(y)) {
      x = x.toLowerCase();
      y = y.toLowerCase();
    }

    if (x < y) {
      return reversed ? 1 : -1;
    } else if (x > y) {
      return reversed ? -1 : 1;
    } else {
      return 0;
    }
  });
  return array;
});

function string(obj) {
  return r.copySafeness(obj, obj);
}

exports.string = string;

function striptags(input, preserveLinebreaks) {
  input = normalize(input, '');
  var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
  var trimmedInput = trim(input.replace(tags, ''));
  var res = '';

  if (preserveLinebreaks) {
    res = trimmedInput.replace(/^ +| +$/gm, '') // remove leading and trailing spaces
    .replace(/ +/g, ' ') // squash adjacent spaces
    .replace(/(\r\n)/g, '\n') // normalize linebreaks (CRLF -> LF)
    .replace(/\n\n\n+/g, '\n\n'); // squash abnormal adjacent linebreaks
  } else {
    res = trimmedInput.replace(/\s+/gi, ' ');
  }

  return r.copySafeness(input, res);
}

exports.striptags = striptags;

function title(str) {
  str = normalize(str, '');
  var words = str.split(' ').map(function (word) {
    return capitalize(word);
  });
  return r.copySafeness(str, words.join(' '));
}

exports.title = title;

function trim(str) {
  return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ''));
}

exports.trim = trim;

function truncate(input, length, killwords, end) {
  var orig = input;
  input = normalize(input, '');
  length = length || 255;

  if (input.length <= length) {
    return input;
  }

  if (killwords) {
    input = input.substring(0, length);
  } else {
    var idx = input.lastIndexOf(' ', length);

    if (idx === -1) {
      idx = length;
    }

    input = input.substring(0, idx);
  }

  input += end !== undefined && end !== null ? end : '...';
  return r.copySafeness(orig, input);
}

exports.truncate = truncate;

function upper(str) {
  str = normalize(str, '');
  return str.toUpperCase();
}

exports.upper = upper;

function urlencode(obj) {
  var enc = encodeURIComponent;

  if (lib.isString(obj)) {
    return enc(obj);
  } else {
    var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
    return keyvals.map(function (_ref2) {
      var k = _ref2[0],
          v = _ref2[1];
      return enc(k) + "=" + enc(v);
    }).join('&');
  }
}

exports.urlencode = urlencode; // For the jinja regexp, see
// https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23

var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/; // from http://blog.gerv.net/2011/05/html5_email_address_regexp/

var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
var httpHttpsRe = /^https?:\/\/.*$/;
var wwwRe = /^www\./;
var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;

function urlize(str, length, nofollow) {
  if (isNaN(length)) {
    length = Infinity;
  }

  var noFollowAttr = nofollow === true ? ' rel="nofollow"' : '';
  var words = str.split(/(\s+)/).filter(function (word) {
    // If the word has no length, bail. This can happen for str with
    // trailing whitespace.
    return word && word.length;
  }).map(function (word) {
    var matches = word.match(puncRe);
    var possibleUrl = matches ? matches[1] : word;
    var shortUrl = possibleUrl.substr(0, length); // url that starts with http or https

    if (httpHttpsRe.test(possibleUrl)) {
      return "<a href=\"" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    } // url that starts with www.


    if (wwwRe.test(possibleUrl)) {
      return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    } // an email address of the form username@domain.tld


    if (emailRe.test(possibleUrl)) {
      return "<a href=\"mailto:" + possibleUrl + "\">" + possibleUrl + "</a>";
    } // url that ends in .com, .org or .net that is not an email address


    if (tldRe.test(possibleUrl)) {
      return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    }

    return word;
  });
  return words.join('');
}

exports.urlize = urlize;

function wordcount(str) {
  str = normalize(str, '');
  var words = str ? str.match(/\w+/g) : null;
  return words ? words.length : null;
}

exports.wordcount = wordcount;

function float(val, def) {
  var res = parseFloat(val);
  return isNaN(res) ? def : res;
}

exports.float = float;
var intFilter = r.makeMacro(['value', 'default', 'base'], [], function doInt(value, defaultValue, base) {
  if (base === void 0) {
    base = 10;
  }

  var res = parseInt(value, base);
  return isNaN(res) ? defaultValue : res;
});
exports.int = intFilter; // Aliases

exports.d = exports.default;
exports.e = exports.escape;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Loader = __webpack_require__(6);

var PrecompiledLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(PrecompiledLoader, _Loader);

  function PrecompiledLoader(compiledTemplates) {
    var _this;

    _this = _Loader.call(this) || this;
    _this.precompiled = compiledTemplates || {};
    return _this;
  }

  var _proto = PrecompiledLoader.prototype;

  _proto.getSource = function getSource(name) {
    if (this.precompiled[name]) {
      return {
        src: {
          type: 'code',
          obj: this.precompiled[name]
        },
        path: name
      };
    }

    return null;
  };

  return PrecompiledLoader;
}(Loader);

module.exports = {
  PrecompiledLoader: PrecompiledLoader
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SafeString = __webpack_require__(2).SafeString;
/**
 * Returns `true` if the object is a function, otherwise `false`.
 * @param { any } value
 * @returns { boolean }
 */


function callable(value) {
  return typeof value === 'function';
}

exports.callable = callable;
/**
 * Returns `true` if the object is strictly not `undefined`.
 * @param { any } value
 * @returns { boolean }
 */

function defined(value) {
  return value !== undefined;
}

exports.defined = defined;
/**
 * Returns `true` if the operand (one) is divisble by the test's argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function divisibleby(one, two) {
  return one % two === 0;
}

exports.divisibleby = divisibleby;
/**
 * Returns true if the string has been escaped (i.e., is a SafeString).
 * @param { any } value
 * @returns { boolean }
 */

function escaped(value) {
  return value instanceof SafeString;
}

exports.escaped = escaped;
/**
 * Returns `true` if the arguments are strictly equal.
 * @param { any } one
 * @param { any } two
 */

function equalto(one, two) {
  return one === two;
}

exports.equalto = equalto; // Aliases

exports.eq = exports.equalto;
exports.sameas = exports.equalto;
/**
 * Returns `true` if the value is evenly divisible by 2.
 * @param { number } value
 * @returns { boolean }
 */

function even(value) {
  return value % 2 === 0;
}

exports.even = even;
/**
 * Returns `true` if the value is falsy - if I recall correctly, '', 0, false,
 * undefined, NaN or null. I don't know if we should stick to the default JS
 * behavior or attempt to replicate what Python believes should be falsy (i.e.,
 * empty arrays, empty dicts, not 0...).
 * @param { any } value
 * @returns { boolean }
 */

function falsy(value) {
  return !value;
}

exports.falsy = falsy;
/**
 * Returns `true` if the operand (one) is greater or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function ge(one, two) {
  return one >= two;
}

exports.ge = ge;
/**
 * Returns `true` if the operand (one) is greater than the test's argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function greaterthan(one, two) {
  return one > two;
}

exports.greaterthan = greaterthan; // alias

exports.gt = exports.greaterthan;
/**
 * Returns `true` if the operand (one) is less than or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function le(one, two) {
  return one <= two;
}

exports.le = le;
/**
 * Returns `true` if the operand (one) is less than the test's passed argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function lessthan(one, two) {
  return one < two;
}

exports.lessthan = lessthan; // alias

exports.lt = exports.lessthan;
/**
 * Returns `true` if the string is lowercased.
 * @param { string } value
 * @returns { boolean }
 */

function lower(value) {
  return value.toLowerCase() === value;
}

exports.lower = lower;
/**
 * Returns `true` if the operand (one) is less than or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function ne(one, two) {
  return one !== two;
}

exports.ne = ne;
/**
 * Returns true if the value is strictly equal to `null`.
 * @param { any }
 * @returns { boolean }
 */

function nullTest(value) {
  return value === null;
}

exports.null = nullTest;
/**
 * Returns true if value is a number.
 * @param { any }
 * @returns { boolean }
 */

function number(value) {
  return typeof value === 'number';
}

exports.number = number;
/**
 * Returns `true` if the value is *not* evenly divisible by 2.
 * @param { number } value
 * @returns { boolean }
 */

function odd(value) {
  return value % 2 === 1;
}

exports.odd = odd;
/**
 * Returns `true` if the value is a string, `false` if not.
 * @param { any } value
 * @returns { boolean }
 */

function string(value) {
  return typeof value === 'string';
}

exports.string = string;
/**
 * Returns `true` if the value is not in the list of things considered falsy:
 * '', null, undefined, 0, NaN and false.
 * @param { any } value
 * @returns { boolean }
 */

function truthy(value) {
  return !!value;
}

exports.truthy = truthy;
/**
 * Returns `true` if the value is undefined.
 * @param { any } value
 * @returns { boolean }
 */

function undefinedTest(value) {
  return value === undefined;
}

exports.undefined = undefinedTest;
/**
 * Returns `true` if the string is uppercased.
 * @param { string } value
 * @returns { boolean }
 */

function upper(value) {
  return value.toUpperCase() === value;
}

exports.upper = upper;
/**
 * If ES6 features are available, returns `true` if the value implements the
 * `Symbol.iterator` method. If not, it's a string or Array.
 *
 * Could potentially cause issues if a browser exists that has Set and Map but
 * not Symbol.
 *
 * @param { any } value
 * @returns { boolean }
 */

function iterable(value) {
  if (typeof Symbol !== 'undefined') {
    return !!value[Symbol.iterator];
  } else {
    return Array.isArray(value) || typeof value === 'string';
  }
}

exports.iterable = iterable;
/**
 * If ES6 features are available, returns `true` if the value is an object hash
 * or an ES6 Map. Otherwise just return if it's an object hash.
 * @param { any } value
 * @returns { boolean }
 */

function mapping(value) {
  // only maps and object hashes
  var bool = value !== null && value !== undefined && typeof value === 'object' && !Array.isArray(value);

  if (Set) {
    return bool && !(value instanceof Set);
  } else {
    return bool;
  }
}

exports.mapping = mapping;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _cycler(items) {
  var index = -1;
  return {
    current: null,
    reset: function reset() {
      index = -1;
      this.current = null;
    },
    next: function next() {
      index++;

      if (index >= items.length) {
        index = 0;
      }

      this.current = items[index];
      return this.current;
    }
  };
}

function _joiner(sep) {
  sep = sep || ',';
  var first = true;
  return function () {
    var val = first ? '' : sep;
    first = false;
    return val;
  };
} // Making this a function instead so it returns a new object
// each time it's called. That way, if something like an environment
// uses it, they will each have their own copy.


function globals() {
  return {
    range: function range(start, stop, step) {
      if (typeof stop === 'undefined') {
        stop = start;
        start = 0;
        step = 1;
      } else if (!step) {
        step = 1;
      }

      var arr = [];

      if (step > 0) {
        for (var i = start; i < stop; i += step) {
          arr.push(i);
        }
      } else {
        for (var _i = start; _i > stop; _i += step) {
          // eslint-disable-line for-direction
          arr.push(_i);
        }
      }

      return arr;
    },
    cycler: function cycler() {
      return _cycler(Array.prototype.slice.call(arguments));
    },
    joiner: function joiner(sep) {
      return _joiner(sep);
    }
  };
}

module.exports = globals;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(4);

module.exports = function express(env, app) {
  function NunjucksView(name, opts) {
    this.name = name;
    this.path = name;
    this.defaultEngine = opts.defaultEngine;
    this.ext = path.extname(name);

    if (!this.ext && !this.defaultEngine) {
      throw new Error('No default engine was specified and no extension was provided.');
    }

    if (!this.ext) {
      this.name += this.ext = (this.defaultEngine[0] !== '.' ? '.' : '') + this.defaultEngine;
    }
  }

  NunjucksView.prototype.render = function render(opts, cb) {
    env.render(this.name, opts, cb);
  };

  app.set('view', NunjucksView);
  app.set('nunjucksEnv', env);
  return env;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(4);

var path = __webpack_require__(4);

var _require = __webpack_require__(0),
    _prettifyError = _require._prettifyError;

var compiler = __webpack_require__(5);

var _require2 = __webpack_require__(7),
    Environment = _require2.Environment;

var precompileGlobal = __webpack_require__(24);

function match(filename, patterns) {
  if (!Array.isArray(patterns)) {
    return false;
  }

  return patterns.some(function (pattern) {
    return filename.match(pattern);
  });
}

function precompileString(str, opts) {
  opts = opts || {};
  opts.isString = true;
  var env = opts.env || new Environment([]);
  var wrapper = opts.wrapper || precompileGlobal;

  if (!opts.name) {
    throw new Error('the "name" option is required when compiling a string');
  }

  return wrapper([_precompile(str, opts.name, env)], opts);
}

function precompile(input, opts) {
  // The following options are available:
  //
  // * name: name of the template (auto-generated when compiling a directory)
  // * isString: input is a string, not a file path
  // * asFunction: generate a callable function
  // * force: keep compiling on error
  // * env: the Environment to use (gets extensions and async filters from it)
  // * include: which file/folders to include (folders are auto-included, files are auto-excluded)
  // * exclude: which file/folders to exclude (folders are auto-included, files are auto-excluded)
  // * wrapper: function(templates, opts) {...}
  //       Customize the output format to store the compiled template.
  //       By default, templates are stored in a global variable used by the runtime.
  //       A custom loader will be necessary to load your custom wrapper.
  opts = opts || {};
  var env = opts.env || new Environment([]);
  var wrapper = opts.wrapper || precompileGlobal;

  if (opts.isString) {
    return precompileString(input, opts);
  }

  var pathStats = fs.existsSync(input) && fs.statSync(input);
  var precompiled = [];
  var templates = [];

  function addTemplates(dir) {
    fs.readdirSync(dir).forEach(function (file) {
      var filepath = path.join(dir, file);
      var subpath = filepath.substr(path.join(input, '/').length);
      var stat = fs.statSync(filepath);

      if (stat && stat.isDirectory()) {
        subpath += '/';

        if (!match(subpath, opts.exclude)) {
          addTemplates(filepath);
        }
      } else if (match(subpath, opts.include)) {
        templates.push(filepath);
      }
    });
  }

  if (pathStats.isFile()) {
    precompiled.push(_precompile(fs.readFileSync(input, 'utf-8'), opts.name || input, env));
  } else if (pathStats.isDirectory()) {
    addTemplates(input);

    for (var i = 0; i < templates.length; i++) {
      var name = templates[i].replace(path.join(input, '/'), '');

      try {
        precompiled.push(_precompile(fs.readFileSync(templates[i], 'utf-8'), name, env));
      } catch (e) {
        if (opts.force) {
          // Don't stop generating the output if we're
          // forcing compilation.
          console.error(e); // eslint-disable-line no-console
        } else {
          throw e;
        }
      }
    }
  }

  return wrapper(precompiled, opts);
}

function _precompile(str, name, env) {
  env = env || new Environment([]);
  var asyncFilters = env.asyncFilters;
  var extensions = env.extensionsList;
  var template;
  name = name.replace(/\\/g, '/');

  try {
    template = compiler.compile(str, asyncFilters, extensions, name, env.opts);
  } catch (err) {
    throw _prettifyError(name, false, err);
  }

  return {
    name: name,
    template: template
  };
}

module.exports = {
  precompile: precompile,
  precompileString: precompileString
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function precompileGlobal(templates, opts) {
  var out = '';
  opts = opts || {};

  for (var i = 0; i < templates.length; i++) {
    var name = JSON.stringify(templates[i].name);
    var template = templates[i].template;
    out += '(function() {' + '(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})' + '[' + name + '] = (function() {\n' + template + '\n})();\n';

    if (opts.asFunction) {
      out += 'return function(ctx, cb) { return nunjucks.render(' + name + ', ctx, cb); }\n';
    }

    out += '})();\n';
  }

  return out;
}

module.exports = precompileGlobal;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

function installCompat() {
  'use strict';
  /* eslint-disable camelcase */
  // This must be called like `nunjucks.installCompat` so that `this`
  // references the nunjucks instance

  var runtime = this.runtime;
  var lib = this.lib; // Handle slim case where these 'modules' are excluded from the built source

  var Compiler = this.compiler.Compiler;
  var Parser = this.parser.Parser;
  var nodes = this.nodes;
  var lexer = this.lexer;
  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
  var orig_memberLookup = runtime.memberLookup;
  var orig_Compiler_assertType;
  var orig_Parser_parseAggregate;

  if (Compiler) {
    orig_Compiler_assertType = Compiler.prototype.assertType;
  }

  if (Parser) {
    orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
  }

  function uninstall() {
    runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
    runtime.memberLookup = orig_memberLookup;

    if (Compiler) {
      Compiler.prototype.assertType = orig_Compiler_assertType;
    }

    if (Parser) {
      Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
    }
  }

  runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
    var val = orig_contextOrFrameLookup.apply(this, arguments);

    if (val !== undefined) {
      return val;
    }

    switch (key) {
      case 'True':
        return true;

      case 'False':
        return false;

      case 'None':
        return null;

      default:
        return undefined;
    }
  };

  function getTokensState(tokens) {
    return {
      index: tokens.index,
      lineno: tokens.lineno,
      colno: tokens.colno
    };
  }

  if ("STD" !== 'SLIM' && nodes && Compiler && Parser) {
    // i.e., not slim mode
    var Slice = nodes.Node.extend('Slice', {
      fields: ['start', 'stop', 'step'],
      init: function init(lineno, colno, start, stop, step) {
        start = start || new nodes.Literal(lineno, colno, null);
        stop = stop || new nodes.Literal(lineno, colno, null);
        step = step || new nodes.Literal(lineno, colno, 1);
        this.parent(lineno, colno, start, stop, step);
      }
    });

    Compiler.prototype.assertType = function assertType(node) {
      if (node instanceof Slice) {
        return;
      }

      orig_Compiler_assertType.apply(this, arguments);
    };

    Compiler.prototype.compileSlice = function compileSlice(node, frame) {
      this._emit('(');

      this._compileExpression(node.start, frame);

      this._emit('),(');

      this._compileExpression(node.stop, frame);

      this._emit('),(');

      this._compileExpression(node.step, frame);

      this._emit(')');
    };

    Parser.prototype.parseAggregate = function parseAggregate() {
      var _this = this;

      var origState = getTokensState(this.tokens); // Set back one accounting for opening bracket/parens

      origState.colno--;
      origState.index--;

      try {
        return orig_Parser_parseAggregate.apply(this);
      } catch (e) {
        var errState = getTokensState(this.tokens);

        var rethrow = function rethrow() {
          lib._assign(_this.tokens, errState);

          return e;
        }; // Reset to state before original parseAggregate called


        lib._assign(this.tokens, origState);

        this.peeked = false;
        var tok = this.peekToken();

        if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
          throw rethrow();
        } else {
          this.nextToken();
        }

        var node = new Slice(tok.lineno, tok.colno); // If we don't encounter a colon while parsing, this is not a slice,
        // so re-raise the original exception.

        var isSlice = false;

        for (var i = 0; i <= node.fields.length; i++) {
          if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
            break;
          }

          if (i === node.fields.length) {
            if (isSlice) {
              this.fail('parseSlice: too many slice components', tok.lineno, tok.colno);
            } else {
              break;
            }
          }

          if (this.skip(lexer.TOKEN_COLON)) {
            isSlice = true;
          } else {
            var field = node.fields[i];
            node[field] = this.parseExpression();
            isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
          }
        }

        if (!isSlice) {
          throw rethrow();
        }

        return new nodes.Array(tok.lineno, tok.colno, [node]);
      }
    };
  }

  function sliceLookup(obj, start, stop, step) {
    obj = obj || [];

    if (start === null) {
      start = step < 0 ? obj.length - 1 : 0;
    }

    if (stop === null) {
      stop = step < 0 ? -1 : obj.length;
    } else if (stop < 0) {
      stop += obj.length;
    }

    if (start < 0) {
      start += obj.length;
    }

    var results = [];

    for (var i = start;; i += step) {
      if (i < 0 || i > obj.length) {
        break;
      }

      if (step > 0 && i >= stop) {
        break;
      }

      if (step < 0 && i <= stop) {
        break;
      }

      results.push(runtime.memberLookup(obj, i));
    }

    return results;
  }

  function hasOwnProp(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  var ARRAY_MEMBERS = {
    pop: function pop(index) {
      if (index === undefined) {
        return this.pop();
      }

      if (index >= this.length || index < 0) {
        throw new Error('KeyError');
      }

      return this.splice(index, 1);
    },
    append: function append(element) {
      return this.push(element);
    },
    remove: function remove(element) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] === element) {
          return this.splice(i, 1);
        }
      }

      throw new Error('ValueError');
    },
    count: function count(element) {
      var count = 0;

      for (var i = 0; i < this.length; i++) {
        if (this[i] === element) {
          count++;
        }
      }

      return count;
    },
    index: function index(element) {
      var i;

      if ((i = this.indexOf(element)) === -1) {
        throw new Error('ValueError');
      }

      return i;
    },
    find: function find(element) {
      return this.indexOf(element);
    },
    insert: function insert(index, elem) {
      return this.splice(index, 0, elem);
    }
  };
  var OBJECT_MEMBERS = {
    items: function items() {
      return lib._entries(this);
    },
    values: function values() {
      return lib._values(this);
    },
    keys: function keys() {
      return lib.keys(this);
    },
    get: function get(key, def) {
      var output = this[key];

      if (output === undefined) {
        output = def;
      }

      return output;
    },
    has_key: function has_key(key) {
      return hasOwnProp(this, key);
    },
    pop: function pop(key, def) {
      var output = this[key];

      if (output === undefined && def !== undefined) {
        output = def;
      } else if (output === undefined) {
        throw new Error('KeyError');
      } else {
        delete this[key];
      }

      return output;
    },
    popitem: function popitem() {
      var keys = lib.keys(this);

      if (!keys.length) {
        throw new Error('KeyError');
      }

      var k = keys[0];
      var val = this[k];
      delete this[k];
      return [k, val];
    },
    setdefault: function setdefault(key, def) {
      if (def === void 0) {
        def = null;
      }

      if (!(key in this)) {
        this[key] = def;
      }

      return this[key];
    },
    update: function update(kwargs) {
      lib._assign(this, kwargs);

      return null; // Always returns None
    }
  };
  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;

  runtime.memberLookup = function memberLookup(obj, val, autoescape) {
    if (arguments.length === 4) {
      return sliceLookup.apply(this, arguments);
    }

    obj = obj || {}; // If the object is an object, return any of the methods that Python would
    // otherwise provide.

    if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
      return ARRAY_MEMBERS[val].bind(obj);
    }

    if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
      return OBJECT_MEMBERS[val].bind(obj);
    }

    return orig_memberLookup.apply(this, arguments);
  };

  return uninstall;
}

module.exports = installCompat;

/***/ })
/******/ ]);
});

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)
},{"_process":237,"timers":256}],2:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define('parseXsdDuration', ['exports'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.parseXsdDuration = mod.exports;
  }
})(this, function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _emptyPeriod, _emptyTime;

  var UNITS = {
    YEAR: 31536000,
    MONTH: 2628000,
    DAY: 86400,
    HOUR: 3600,
    MINUTE: 60,
    SECOND: 1
  };

  var YEAR_UNIT = 'years';
  var MONTH_UNIT = 'months';
  var DAY_UNIT = 'days';
  var HOUR_UNIT = 'hours';
  var MINUTE_UNIT = 'minutes';
  var SECOND_UNIT = 'seconds';
  var IS_NEGATIVE_UNIT = 'isNegative';

  var emptyPeriod = (_emptyPeriod = {}, _emptyPeriod[YEAR_UNIT] = 0, _emptyPeriod[MONTH_UNIT] = 0, _emptyPeriod[DAY_UNIT] = 0, _emptyPeriod);

  var emptyTime = (_emptyTime = {}, _emptyTime[HOUR_UNIT] = 0, _emptyTime[MINUTE_UNIT] = 0, _emptyTime[SECOND_UNIT] = 0, _emptyTime);

  // Regex taken from https://www.w3.org/TR/xmlschema11-2/#duration-lexical-space
  var isValidXsdDuration = function isValidXsdDuration(str) {
    return (/^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\.[0-9]+)?S)?|([0-9]+(\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\.[0-9]+)?S)?|([0-9]+(\.[0-9]+)?S))))$/.test(str)
    );
  };
  var isNonEmptyString = function isNonEmptyString(input) {
    return typeof input === 'string' && input.length > 0;
  };
  var isNegative = function isNegative(str) {
    return str[0] === '-';
  };
  var stripFirstChar = function stripFirstChar(str) {
    return str.slice(1);
  };
  var unitToSeconds = function unitToSeconds(unit, amount) {
    return UNITS[unit.toUpperCase()] * amount;
  };

  var parseUnit = function parseUnit(unit, amount) {
    var amt = getNumber(amount);
    return unitToSeconds(unit, amt);
  };

  var getNumber = function getNumber(amount) {
    var amt = parseFloat(amount);
    if (isNaN(amt)) return 0;
    return amt;
  };

  var parsePeriod = function parsePeriod(period) {
    var _ref = /^(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?$/g.exec(period) || [],
        year = _ref[1],
        month = _ref[2],
        day = _ref[3];

    return parseUnit('year', year) + parseUnit('month', month) + parseUnit('day', day);
  };

  var parsePeriodToObject = function parsePeriodToObject(period) {
    var _ref3;

    var _ref2 = /^(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?$/g.exec(period) || [],
        years = _ref2[1],
        months = _ref2[2],
        days = _ref2[3];

    return _ref3 = {}, _ref3[YEAR_UNIT] = getNumber(years), _ref3[MONTH_UNIT] = getNumber(months), _ref3[DAY_UNIT] = getNumber(days), _ref3;
  };

  var parseTime = function parseTime(time) {
    var _ref4 = /^(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?$/g.exec(time) || [],
        hour = _ref4[1],
        minute = _ref4[2],
        second = _ref4[3];

    return parseUnit('hour', hour) + parseUnit('minute', minute) + parseUnit('second', second);
  };

  var parseTimeToObject = function parseTimeToObject(time) {
    var _ref6;

    var _ref5 = /^(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?$/g.exec(time) || [],
        hours = _ref5[1],
        minutes = _ref5[2],
        seconds = _ref5[3];

    return _ref6 = {}, _ref6[HOUR_UNIT] = getNumber(hours), _ref6[MINUTE_UNIT] = getNumber(minutes), _ref6[SECOND_UNIT] = getNumber(seconds), _ref6;
  };

  var parse = function parse(str) {
    var neg = isNegative(str);
    var duration = neg ? stripFirstChar(str) : str;
    var splitDuration = duration.split('T');
    var period = stripFirstChar(splitDuration[0]);
    var time = splitDuration[1];

    var output = 0;
    if (isNonEmptyString(period)) output += parsePeriod(period);
    if (isNonEmptyString(time)) output += parseTime(time);
    return neg ? -output : output;
  };

  var convertToObject = exports.convertToObject = function convertToObject(str) {
    var _output;

    var neg = isNegative(str);
    var duration = neg ? stripFirstChar(str) : str;
    var splitDuration = duration.split('T');
    var period = stripFirstChar(splitDuration[0]);
    var time = splitDuration[1];

    var output = (_output = {}, _output[IS_NEGATIVE_UNIT] = neg, _output);
    output = isNonEmptyString(period) ? Object.assign(output, parsePeriodToObject(period)) : Object.assign(output, emptyPeriod);
    output = isNonEmptyString(time) ? Object.assign(output, parseTimeToObject(time)) : Object.assign(output, emptyTime);
    return output;
  };

  var out = function out(input) {
    var toObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    // Throw error for non-string input
    if (typeof input !== 'string') {
      throw new TypeError('expected input to be a string');
    }
    // Return null for invalid input
    if (!isValidXsdDuration(input)) return null;
    // Parse valid input
    return toObject ? convertToObject(input) : parse(input);
  };

  exports.default = function (input, toObject) {
    return out(input, toObject);
  };
});

},{}],3:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2021. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });

},{}],4:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });

},{}],5:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2021. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });

},{}],6:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonDomainVizConfiguration = void 0;
class JsonDomainVizConfiguration {
    constructor(configuration, customVisualizationScriptLoader, customVisualization) {
        this.configuration = configuration;
        this.customVisualizationScriptLoader = customVisualizationScriptLoader;
        this.customVisualization = customVisualization;
    }
    static withCustomVisualizationScript(configuration, customDomainVisualizationScript) {
        // set up the script loader callback, if the script is provided
        let customDomainVisualizationScriptLoader;
        if (customDomainVisualizationScript !== undefined) {
            customDomainVisualizationScriptLoader = () => customDomainVisualizationScript;
        }
        else {
            customDomainVisualizationScriptLoader = undefined;
        }
        return new JsonDomainVizConfiguration(configuration, customDomainVisualizationScriptLoader);
    }
    static withCustomVisualization(configuration, customDomainVisualization) {
        return new JsonDomainVizConfiguration(configuration, undefined, customDomainVisualization);
    }
    shouldDisplay(planStep) {
        var _a, _b, _c;
        return (_c = !((_b = (_a = this.configuration) === null || _a === void 0 ? void 0 : _a.excludeActions) === null || _b === void 0 ? void 0 : _b.some(pattern => this.matches(pattern, planStep.getActionName())))) !== null && _c !== void 0 ? _c : true;
    }
    shouldIgnoreActionParameter(actionName, parameterName) {
        var _a, _b;
        const applicableSetting = (_b = (_a = this.configuration) === null || _a === void 0 ? void 0 : _a.ignoreActionParameters) === null || _b === void 0 ? void 0 : _b.find(entry => this.matches(entry.action, actionName));
        if (!applicableSetting) {
            return false;
        }
        return parameterName.match(new RegExp(applicableSetting.parameterPattern, "i")) !== null;
    }
    matches(pattern, actionName) {
        return !!actionName.match(new RegExp(pattern, "i"));
    }
    getCustomVisualizationScriptPath() {
        var _a;
        return (_a = this.configuration) === null || _a === void 0 ? void 0 : _a.customVisualization;
    }
    getCustomVisualizationScript() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.customVisualizationScript !== undefined) {
                return this.customVisualizationScript;
            }
            else if (((_a = this.configuration) === null || _a === void 0 ? void 0 : _a.customVisualization) && this.customVisualizationScriptLoader) {
                return this.customVisualizationScript = yield this.customVisualizationScriptLoader((_b = this.configuration) === null || _b === void 0 ? void 0 : _b.customVisualization);
            }
            else {
                return undefined;
            }
        });
    }
    getCustomVisualization() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.customVisualization) {
                return this.customVisualization;
            }
            else {
                const script = yield this.getCustomVisualizationScript();
                if (script !== undefined) {
                    return this.customVisualization = eval(script);
                }
            }
            return undefined;
        });
    }
}
exports.JsonDomainVizConfiguration = JsonDomainVizConfiguration;

},{}],7:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.appendPlanView = exports.createPlanView = exports.px = exports.PlanView = exports.PLAN_VIEW_CLASS = exports.ATTR_PLAN = exports.View = exports.getHostElement = exports.DIGITS = void 0;
/* eslint-disable @typescript-eslint/no-use-before-define */
const vscode_uri_1 = require("vscode-uri");
const pddl_workspace_1 = require("pddl-workspace");
const pddl_workspace_2 = require("pddl-workspace");
const charts_1 = require("./charts");
const planCapitalization_1 = require("./planCapitalization");
const SwimLane_1 = require("./SwimLane");
exports.DIGITS = 4;
function getHostElement(hostElementId) {
    const host = document.getElementById(hostElementId);
    if (host === null) {
        throw new Error(`Element with id#${hostElementId} not found in the document.`);
    }
    return host;
}
exports.getHostElement = getHostElement;
class View {
    constructor(hostElement, options) {
        this.options = options;
        this.host = hostElement;
    }
    /**
     * Sets new display width. Does not trigger (re-)drawing.
     * @param displayWidth new width in pixels, the width is used to fit all gantt chart bars (not necessarily the labels next to them)
     */
    setDisplayWidth(displayWidth) {
        this.options.displayWidth = displayWidth;
    }
    getOrCreateBlankChildElement(className) {
        const el = this.host.querySelector('.' + className);
        if (el) {
            el.innerHTML = '';
        }
        return el !== null && el !== void 0 ? el : this.createChildElement(className);
    }
    createChildElement(className) {
        const child = document.createElement('div');
        child.className = className;
        return this.host.appendChild(child);
    }
}
exports.View = View;
const CUSTOM_PLAN_VIZ = 'planViz';
const GANTT = 'gantt';
const RESOURCE_UTILIZATION = 'resourceUtilization';
const LINE_CHARTS = 'lineCharts';
exports.ATTR_PLAN = "plan";
exports.PLAN_VIEW_CLASS = "planView";
/** Single-plan view. */
class PlanView extends View {
    constructor(hostElement, planIndex, options) {
        super(hostElement, options);
        this.planIndex = planIndex;
        this.planStepHeight = 20;
        this.linePlotsGenerated = false;
        this.visible = true;
        this.colors = ['#ff0000', '#ff4000', '#ff8000', '#ffbf00', '#ffff00', '#bfff00', '#80ff00', '#40ff00', '#00ff00', '#00ff40', '#00ff80', '#00ffbf', '#00ffff', '#00bfff', '#0080ff', '#0040ff', '#0000ff', '#4000ff', '#8000ff', '#bf00ff', '#ff00ff', '#ff00bf', '#ff0080', '#ff0040'];
        if (this.host.style.width.length == 0) {
            this.host.style.width = px(options.displayWidth + 100);
        }
    }
    clear() {
        this.getOrCreateBlankChildElement(CUSTOM_PLAN_VIZ);
        this.getOrCreateBlankChildElement(GANTT);
        this.getOrCreateBlankChildElement(RESOURCE_UTILIZATION);
        this.getOrCreateBlankChildElement(LINE_CHARTS);
        this.plan = undefined;
        this.customVisualization = undefined;
        this.deactivateLinePlotPlaceholder();
    }
    setVisible(visible) {
        if (this.visible !== visible) {
            this.visible = visible;
            const newDisplayStyle = visible ? "block" : "none";
            this.host.style.display = newDisplayStyle;
            if (!this.linePlotsGenerated && this.plan) {
                // line plots were not generated yet
                if (!visible) {
                    // unsubscribe scroll event
                    this.deactivateLinePlotPlaceholder();
                }
                else {
                    this.lineCharts && this.activateLinePlotPlaceholder(this.lineCharts, this.plan);
                }
            }
        }
    }
    showPlan(plan, configuration) {
        this.plan = plan = defaultDomain((0, planCapitalization_1.capitalize)(plan));
        const planVizDiv = this.getOrCreateBlankChildElement(CUSTOM_PLAN_VIZ);
        this.tryVisualizePlan(planVizDiv, plan, configuration);
        const stepsToDisplay = plan.steps
            .filter(step => PlanView.shouldDisplay(step, configuration));
        const ganttDiv = this.getOrCreateBlankChildElement(GANTT);
        this.showGantt(ganttDiv, plan, stepsToDisplay);
        const swimLanes = this.getOrCreateBlankChildElement(RESOURCE_UTILIZATION);
        this.showSwimLanes(swimLanes, plan, configuration);
        this.lineCharts = this.getOrCreateBlankChildElement(LINE_CHARTS);
        this.activateLinePlotPlaceholder(this.lineCharts, plan);
    }
    tryVisualizePlan(planVizDiv, plan, configuration) {
        var _a;
        try {
            this.visualizePlan(planVizDiv, plan, configuration);
        }
        catch (ex) {
            planVizDiv.style.width = px(this.options.displayWidth);
            const error = ex;
            this.addError(planVizDiv, (_a = error.message) !== null && _a !== void 0 ? _a : '' + error);
        }
    }
    addError(planVizDiv, ex) {
        const errorSpan = document.createElement('span');
        errorSpan.className = 'error';
        errorSpan.innerText = `Error: ` + ex;
        planVizDiv.appendChild(errorSpan);
    }
    visualizePlan(planVizDiv, plan, configuration) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.customVisualization = yield (configuration === null || configuration === void 0 ? void 0 : configuration.getCustomVisualization());
            if (this.customVisualization) {
                if (this.customVisualization.visualizePlanHtml) {
                    const vizHtml = this.customVisualization.visualizePlanHtml(plan, this.options.displayWidth);
                    planVizDiv.innerHTML = vizHtml;
                }
                else if (this.customVisualization.visualizePlanInDiv) {
                    this.customVisualization.visualizePlanInDiv(planVizDiv, plan, this.options.displayWidth);
                }
                else if (this.customVisualization.visualizePlanSvg) {
                    const vizSvg = this.customVisualization.visualizePlanSvg(plan, this.options.displayWidth);
                    planVizDiv.appendChild(vizSvg);
                }
                else if (this.customVisualization.visualizeStateHtml ||
                    this.customVisualization.visualizeStateInDiv ||
                    this.customVisualization.visualizeStateSvg) {
                    (_b = (_a = this.options).onFinalStateVisible) === null || _b === void 0 ? void 0 : _b.call(_a, this);
                }
            }
        });
    }
    showPlanLinePlots(title, yAxisUnit, objects, data) {
        if (this.lineCharts) {
            this.hideLinePlotLoadingProgress();
            this.addLinePlot(title, yAxisUnit, objects, data);
        }
    }
    showFinalState(finalState) {
        if (!this.customVisualization || !this.plan) {
            return;
        }
        const planVizDiv = this.getOrCreateBlankChildElement(CUSTOM_PLAN_VIZ);
        if (this.customVisualization.visualizeStateHtml) {
            const vizHtml = this.customVisualization.visualizeStateHtml(this.plan, finalState, this.options.displayWidth);
            planVizDiv.innerHTML = vizHtml;
        }
        else if (this.customVisualization.visualizeStateInDiv) {
            this.customVisualization.visualizeStateInDiv(planVizDiv, this.plan, finalState, this.options.displayWidth);
        }
        else if (this.customVisualization.visualizeStateSvg) {
            const vizSvg = this.customVisualization.visualizeStateSvg(this.plan, finalState, this.options.displayWidth);
            planVizDiv.appendChild(vizSvg);
        }
    }
    showGantt(ganttDiv, plan, stepsToDisplay) {
        // split this to two batches and insert helpful actions in between
        const planHeadSteps = stepsToDisplay
            .filter(step => this.isPlanHeadStep(step, plan.now));
        const relaxedPlanSteps = stepsToDisplay
            .filter(step => !this.isPlanHeadStep(step, plan.now));
        const oneIfHelpfulActionsPresent = (plan.hasHelpfulActions() ? 1 : 0);
        const relaxedPlanStepIndexOffset = planHeadSteps.length + oneIfHelpfulActionsPresent;
        const ganttChartHeight = (stepsToDisplay.length + oneIfHelpfulActionsPresent) * this.planStepHeight;
        ganttDiv.style.height = px(ganttChartHeight);
        planHeadSteps
            .map((step, stepIndex) => this.renderGanttStep(ganttDiv, step, stepIndex, plan));
        this.renderHelpfulActions(ganttDiv, plan, planHeadSteps.length);
        relaxedPlanSteps
            .map((step, stepIndex) => this.renderGanttStep(ganttDiv, step, stepIndex + relaxedPlanStepIndexOffset, plan));
    }
    renderGanttStep(ganttDiv, step, index, plan) {
        const fromTop = index * this.planStepHeight;
        const fromLeft = this.computeLeftOffset(step, plan);
        const planHeadDuration = this.computePlanHeadDuration(step, plan);
        const width = this.computeWidth(planHeadDuration, plan);
        const widthRelaxed = this.computeRelaxedWidth(planHeadDuration, step, plan);
        const actionColor = plan.domain ? this.getActionColor(step, plan.domain) : 'gray';
        const actionIterations = step.getIterations() > 1 ? `${step.getIterations()}x` : '';
        const planStep = document.createElement('div');
        planStep.id = "plan${planIndex}step${index}";
        planStep.className = "planstep";
        planStep.style.left = px(fromLeft);
        planStep.style.top = px(fromTop);
        const planStepBar = document.createElement('div');
        planStepBar.className = "planstep-bar";
        planStepBar.title = this.toActionTooltipPlain(step);
        planStepBar.style.width = px(width);
        planStepBar.style.backgroundColor = actionColor;
        const planStepBarRelaxed = document.createElement('div');
        planStepBarRelaxed.className = "planstep-bar-relaxed whitecarbon";
        planStepBarRelaxed.style.width = px(widthRelaxed);
        const actionLink = this.toActionLink(step.getActionName(), plan);
        const text = document.createTextNode(` ${step.getObjects().join(' ')} ${actionIterations}`);
        planStep.append(planStepBar, planStepBarRelaxed, actionLink, text);
        ganttDiv.appendChild(planStep);
    }
    renderHelpfulActions(ganttDiv, plan, planHeadLength) {
        var _a;
        if (plan.hasHelpfulActions()) {
            const fromTop = planHeadLength * this.planStepHeight;
            const fromLeft = this.toViewCoordinates(plan.now, plan);
            const helpfulActions = document.createElement("div");
            helpfulActions.className = "planstep";
            helpfulActions.style.top = px(fromTop);
            helpfulActions.style.left = px(fromLeft);
            helpfulActions.style.marginTop = px(3);
            const arrow = document.createTextNode(` `);
            helpfulActions.appendChild(arrow);
            (_a = plan.helpfulActions) === null || _a === void 0 ? void 0 : _a.forEach((helpfulAction, index) => this.renderHelpfulAction(helpfulActions, index, helpfulAction));
            ganttDiv.appendChild(helpfulActions);
        }
    }
    renderHelpfulAction(helpfulActions, index, helpfulAction) {
        const suffix = PlanView.getActionSuffix(helpfulAction);
        const beautifiedName = `${helpfulAction.actionName}<sub>${suffix}</sub> `;
        helpfulActions.appendChild(document.createTextNode(`${index + 1}. `));
        const a = document.createElement("a");
        a.className = "action";
        a.onclick = () => { var _a, _b; return (_b = (_a = this.options).onHelpfulActionSelected) === null || _b === void 0 ? void 0 : _b.call(_a, helpfulAction.actionName); };
        a.innerHTML = beautifiedName;
        helpfulActions.appendChild(a);
    }
    static getActionSuffix(helpfulAction) {
        switch (helpfulAction.kind) {
            case pddl_workspace_2.HappeningType.START:
                return '';
            case pddl_workspace_2.HappeningType.END:
                return '';
        }
        return '';
    }
    computeLeftOffset(step, plan) {
        return this.toViewCoordinates(step.getStartTime(), plan);
    }
    /** Converts the _time_ argument to view coordinates */
    toViewCoordinates(time, plan) {
        return (time !== null && time !== void 0 ? time : 0) / (plan.makespan + this.options.epsilon) * this.options.displayWidth;
    }
    toActionLink(actionName, plan) {
        if (this.options.selfContained || !plan.domain) {
            return document.createTextNode(actionName);
        }
        else {
            const a = document.createElement("a");
            a.className = "action";
            a.onclick = () => { var _a, _b; return (_b = (_a = this.options).onActionSelected) === null || _b === void 0 ? void 0 : _b.call(_a, actionName); };
            a.title = `Reveal '${actionName}' action in the domain file`;
            a.innerText = actionName;
            return a;
        }
    }
    toActionTooltip(tooltipHost, step) {
        var _a, _b;
        const table = document.createElement("table");
        {
            const tr = document.createElement("tr");
            const th = document.createElement("th");
            th.className = "actionToolTip";
            th.setAttribute("colspan", "" + 2);
            th.innerText = `${step.getActionName()} ${step.getObjects().join(' ')}`;
            tr.appendChild(th);
            table.appendChild(tr);
        }
        {
            const tr = document.createElement("tr");
            {
                const td = document.createElement("td");
                td.className = "actionToolTip";
                td.style.width = px(50);
                td.innerText = "Start: ";
                tr.appendChild(td);
            }
            {
                const td = document.createElement("td");
                td.className = "actionToolTip";
                td.innerText = `${step.getStartTime().toFixed(exports.DIGITS)}`;
                tr.appendChild(td);
            }
            table.appendChild(tr);
        }
        if (step.isDurative && step.getDuration() !== undefined) {
            {
                const tr = document.createElement("tr");
                {
                    const td = document.createElement("td");
                    td.className = "actionToolTip";
                    td.innerText = "Duration: ";
                    tr.appendChild(td);
                }
                {
                    const td = document.createElement("td");
                    td.className = "actionToolTip";
                    td.innerText = (_b = (_a = step.getDuration()) === null || _a === void 0 ? void 0 : _a.toFixed(exports.DIGITS)) !== null && _b !== void 0 ? _b : '';
                    tr.appendChild(td);
                }
                table.appendChild(tr);
            }
            {
                const tr = document.createElement("tr");
                {
                    const td = document.createElement("td");
                    td.className = "actionToolTip";
                    td.innerText = "End: ";
                    tr.appendChild(td);
                }
                {
                    const td = document.createElement("td");
                    td.className = "actionToolTip";
                    td.innerText = step.getEndTime().toFixed(exports.DIGITS);
                    tr.appendChild(td);
                }
                table.appendChild(tr);
            }
        }
        tooltipHost.appendChild(table);
    }
    toActionTooltipPlain(step) {
        var _a;
        const durationRow = step.isDurative && step.getDuration() !== undefined ?
            `Duration: ${(_a = step.getDuration()) === null || _a === void 0 ? void 0 : _a.toFixed(exports.DIGITS)}, End: ${step.getEndTime().toFixed(exports.DIGITS)}` :
            '';
        const startTime = step.getStartTime() !== undefined ?
            `, Start: ${step.getStartTime().toFixed(exports.DIGITS)}` :
            '';
        return `${step.getActionName()} ${step.getObjects().join(' ')}${startTime} ${durationRow}`;
    }
    computePlanHeadDuration(step, plan) {
        var _a, _b, _c;
        if (plan.now === undefined) {
            return (_a = step.getDuration()) !== null && _a !== void 0 ? _a : this.options.epsilon;
        }
        else if (step.getEndTime() < plan.now) {
            if (step.commitment === undefined || step.commitment === pddl_workspace_2.PlanStepCommitment.Committed) {
                return (_b = step.getDuration()) !== null && _b !== void 0 ? _b : this.options.epsilon;
            }
            else {
                return 0;
            } // the end was not committed yet
        }
        else if (step.getStartTime() >= plan.now) {
            return 0;
        }
        else {
            switch (step.commitment) {
                case undefined:
                case pddl_workspace_2.PlanStepCommitment.Committed:
                    return (_c = step.getDuration()) !== null && _c !== void 0 ? _c : this.options.epsilon;
                case pddl_workspace_2.PlanStepCommitment.EndsInRelaxedPlan:
                    return 0;
                case pddl_workspace_2.PlanStepCommitment.StartsInRelaxedPlan:
                    return plan.now - step.getStartTime();
                default:
                    return 0; // should not happen
            }
        }
    }
    computeWidth(planHeadDuration, plan) {
        // remove the part of the planStep duration that belongs to the relaxed plan
        return Math.max(1, this.toViewCoordinates(planHeadDuration, plan));
    }
    computeRelaxedWidth(planHeadDuration, step, plan) {
        var _a;
        // remove the part of the planStep duration that belongs to the planhead part
        const relaxedDuration = ((_a = step.getDuration()) !== null && _a !== void 0 ? _a : this.options.epsilon) - planHeadDuration;
        return this.toViewCoordinates(relaxedDuration, plan);
    }
    isPlanHeadStep(step, timeNow) {
        return timeNow === undefined ||
            step.commitment === undefined ||
            step.commitment === pddl_workspace_2.PlanStepCommitment.Committed ||
            step.commitment === pddl_workspace_2.PlanStepCommitment.EndsInRelaxedPlan;
    }
    static shouldDisplay(planStep, configuration) {
        var _a;
        return (_a = configuration === null || configuration === void 0 ? void 0 : configuration.shouldDisplay(planStep)) !== null && _a !== void 0 ? _a : true;
    }
    static shouldDisplayObject(step, obj, domain, configuration) {
        var _a;
        if (!(PlanView.shouldDisplay(step, configuration))) {
            return false;
        }
        const liftedAction = domain === null || domain === void 0 ? void 0 : domain.getActions().find(a => a.getNameOrEmpty().toLowerCase() === step.getActionName().toLowerCase());
        if (!liftedAction) {
            console.debug('Unexpected plan action: ' + step.getActionName());
            return step.getObjects().includes(obj);
        }
        let fromArgument = 0; // search from this argument positional index
        do {
            const indexOfArgument = step.getObjects().indexOf(obj, fromArgument);
            fromArgument = indexOfArgument + 1;
            if (indexOfArgument > -1 && indexOfArgument < liftedAction.parameters.length) {
                const parameter = liftedAction.parameters[indexOfArgument];
                const shouldIgnoreThisArgument = configuration === null || configuration === void 0 ? void 0 : configuration.shouldIgnoreActionParameter((_a = liftedAction.name) !== null && _a !== void 0 ? _a : 'unnamed', parameter.name);
                if (!shouldIgnoreThisArgument) {
                    return true;
                }
            }
        } while (fromArgument > 0);
        return false;
    }
    getActionColor(step, domain) {
        const actionIndex = domain === null || domain === void 0 ? void 0 : domain.getActions().findIndex(action => action.getNameOrEmpty().toLowerCase() === step.getActionName().toLowerCase());
        if (actionIndex === undefined || actionIndex < 0) {
            return 'gray';
        }
        else {
            return this.colors[actionIndex * 7 % this.colors.length];
        }
    }
    showSwimLanes(swimLanes, plan, configuration) {
        if (this.options.disableSwimlanes || !plan.domain || !plan.problem) {
            swimLanes.remove();
            return;
        }
        const allTypeObjects = plan.domain.getConstants().merge(plan.problem.getObjectsTypeMap());
        const table = document.createElement("table");
        plan.domain.getTypesInclObject()
            .filter(type => { var _a, _b; return type !== "object" || ((_b = (_a = allTypeObjects.getTypeCaseInsensitive(type)) === null || _a === void 0 ? void 0 : _a.getObjects().length) !== null && _b !== void 0 ? _b : 0) > 0; })
            .forEach(type => {
            const typeObjects = allTypeObjects.getTypeCaseInsensitive(type);
            typeObjects && this.renderTypeSwimLanes(table, type, typeObjects.getObjects(), plan, configuration);
        });
        swimLanes.appendChild(table);
    }
    renderTypeSwimLanes(table, type, objects, plan, configuration) {
        const tr = document.createElement("tr");
        const tableHeaderTypeName = document.createElement("th");
        tableHeaderTypeName.innerText = type;
        const tableHeaderFill = document.createElement("th");
        tableHeaderFill.style.width = px(this.options.displayWidth);
        tr.append(tableHeaderTypeName, tableHeaderFill);
        table.appendChild(tr);
        objects.forEach(obj => this.renderObjectSwimLane(table, obj, plan, configuration));
    }
    renderObjectSwimLane(table, obj, plan, configuration) {
        const subLanes = new SwimLane_1.SwimLane(1);
        const tr = document.createElement("tr");
        const tdName = document.createElement("td");
        tdName.className = "objectName";
        tdName.innerText = obj;
        const tdLane = document.createElement("td");
        tdLane.style.position = "relative";
        plan.steps
            .filter(step => PlanView.shouldDisplayObject(step, obj, plan.domain, configuration))
            .forEach(step => this.renderSwimLaneStep(tdLane, step, plan, obj, subLanes));
        // now size the row appropriately
        tdLane.style.height = px(subLanes.laneCount() * this.planStepHeight);
        tr.append(tdName, tdLane);
        table.appendChild(tr);
    }
    renderSwimLaneStep(tdLane, step, plan, thisObj, swimLanes) {
        const actionColor = this.getActionColor(step, plan.domain);
        const leftOffset = this.computeLeftOffset(step, plan);
        const planHeadDuration = this.computePlanHeadDuration(step, plan);
        const width = this.computeWidth(planHeadDuration, plan) + this.computeRelaxedWidth(planHeadDuration, step, plan);
        const objects = step.getObjects()
            .map(obj => obj.toLowerCase() === thisObj.toLowerCase() ? '@' : obj)
            .join(' ');
        const availableLane = swimLanes.placeNext(leftOffset, width);
        const fromTop = availableLane * this.planStepHeight + 1;
        const div = document.createElement("div");
        div.className = "resourceTaskTooltip";
        div.style.backgroundColor = actionColor;
        div.style.left = px(leftOffset);
        div.style.width = px(width);
        div.style.top = px(fromTop);
        const tooltipText = document.createElement("span");
        tooltipText.className = "resourceTaskTooltipText";
        this.toActionTooltip(tooltipText, step);
        div.append(`${step.getActionName()} ${objects}`, tooltipText);
        tdLane.appendChild(div);
    }
    /**
     * Line plots get populated lazily, when they get scrolled to the view.
     * @param lineCharts line chart element
     * @param plan plan being displayed
     */
    activateLinePlotPlaceholder(lineCharts, plan) {
        var _a, _b;
        if (this.options.disableLinePlots || !plan.domain || !plan.problem) {
            return;
        }
        this.deactivateLinePlotPlaceholder();
        if ((0, charts_1.isInViewport)(lineCharts)) {
            // load charts immediately
            (_b = (_a = this.options).onLinePlotsVisible) === null || _b === void 0 ? void 0 : _b.call(_a, this);
        }
        else {
            // defer chart loading
            // show loader
            this.addLoader(lineCharts);
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const planView = this;
            const scrollHandler = function handleScrollEvent() {
                var _a, _b;
                const lineChartVisible = (0, charts_1.isInViewport)(lineCharts);
                if (lineChartVisible) {
                    (_b = (_a = planView.options).onLinePlotsVisible) === null || _b === void 0 ? void 0 : _b.call(_a, planView);
                    // unsubscribe the scroll events
                    planView.deactivateLinePlotPlaceholder();
                }
            };
            document.addEventListener('scroll', scrollHandler, { passive: true });
            document.addEventListener("resize", scrollHandler, { passive: true });
            // also sign-up to the mouse over, in case the window gets expanded without the content scrolling
            lineCharts.addEventListener("mouseenter", scrollHandler);
            // retain the handler, so it may be cleared along with the plan
            this.handleScrollEvent = scrollHandler;
        }
    }
    /** Removes the scroll events to avoid generating charts for plans that have been cleared from the view */
    deactivateLinePlotPlaceholder() {
        var _a;
        if (this.handleScrollEvent !== undefined) {
            document.removeEventListener("scroll", this.handleScrollEvent);
            document.removeEventListener("resize", this.handleScrollEvent);
            (_a = this.lineCharts) === null || _a === void 0 ? void 0 : _a.removeEventListener("mouseenter", this.handleScrollEvent);
            this.handleScrollEvent = undefined;
        }
    }
    addLoader(lineCharts) {
        // <div class="loader"></div>
        if (!lineCharts.querySelector("div.loader")) {
            // only ever add one loader, even if the scroll handler is activated/deactivated many times
            const loader = document.createElement("div");
            loader.className = "loader";
            lineCharts.appendChild(loader);
        }
    }
    hideLinePlotLoadingProgress() {
        var _a, _b;
        (_b = (_a = this.lineCharts) === null || _a === void 0 ? void 0 : _a.querySelector(".loader")) === null || _b === void 0 ? void 0 : _b.remove();
    }
    addLinePlot(title, yAxisUnit, objects, data) {
        var _a;
        this.linePlotsGenerated = true;
        const linePlot = document.createElement("div");
        linePlot.className = "lineChart";
        linePlot.style.width = px(this.options.displayWidth + 100);
        linePlot.style.height = px(Math.round(this.options.displayWidth / 2));
        (_a = this.lineCharts) === null || _a === void 0 ? void 0 : _a.appendChild(linePlot);
        if (!this.options.selfContained) {
            (0, charts_1.drawChart)(linePlot, title, yAxisUnit, objects, data);
        }
        else {
            console.error("Line plots are not implemented in self-contained mode.");
            // todo: lineChartScripts += `        drawChart('${chartDivId}', '${chartTitleWithUnit}', '', ${JSON.stringify(values.legend)}, ${JSON.stringify(values.values)}, ${this.options.displayWidth});\n`;
        }
    }
}
exports.PlanView = PlanView;
function px(valueInPx) {
    return `${valueInPx}px`;
}
exports.px = px;
function createPlanView(hostElementId, options) {
    const hostElement = getHostElement(hostElementId);
    return new PlanView(hostElement, 0, options);
}
exports.createPlanView = createPlanView;
function appendPlanView(parent, planIndex, options) {
    const hostElement = document.createElement('div');
    hostElement.setAttribute(exports.ATTR_PLAN, planIndex.toString());
    hostElement.className = exports.PLAN_VIEW_CLASS;
    const planView = new PlanView(hostElement, planIndex, options);
    parent.appendChild(hostElement);
    return planView;
}
exports.appendPlanView = appendPlanView;
/** Creates a default domain and problem, if the plan does not have one associated. */
function defaultDomain(plan) {
    if (plan.domain === undefined && plan.problem === undefined) {
        const defaultDomain = new pddl_workspace_2.DomainInfo(vscode_uri_1.URI.parse('file:///mock/domain'), 0, 'mock', pddl_workspace_2.parser.PddlSyntaxTree.EMPTY, new pddl_workspace_2.SimpleDocumentPositionResolver(''));
        const actions = new Set(plan.steps.map(step => toDefaultAction(step)));
        defaultDomain.setActions([...actions]);
        defaultDomain.setTypeInheritance(new pddl_workspace_1.utils.DirectionalGraph().addEdge("object"));
        const defaultProblem = new pddl_workspace_2.ProblemInfo(vscode_uri_1.URI.parse('file:///mock/problem'), 0, 'mock', 'mock', pddl_workspace_2.parser.PddlSyntaxTree.EMPTY, new pddl_workspace_2.SimpleDocumentPositionResolver(''));
        const objectNames = plan.steps.map(step => step.getObjects()).reduce((prev, curr) => prev.concat(curr), []).sort();
        const objectMap = new pddl_workspace_2.TypeObjectMap().addAll('object', objectNames);
        defaultProblem.setObjects(objectMap);
        return new pddl_workspace_2.Plan(plan.steps, defaultDomain, defaultProblem, plan.now, plan.helpfulActions);
    }
    else {
        return plan;
    }
}
/** Creates a default action from the plan step. */
function toDefaultAction(planStep) {
    const parameters = planStep.getObjects().map((_o, index) => new pddl_workspace_2.Parameter("p" + index, "object"));
    if (planStep.isDurative) {
        return new pddl_workspace_2.DurativeAction(planStep.getActionName(), parameters, pddl_workspace_2.PddlRange.createUnknown(), undefined);
    }
    else {
        return new pddl_workspace_2.InstantAction(planStep.getActionName(), parameters, pddl_workspace_2.PddlRange.createUnknown());
    }
}

},{"./SwimLane":9,"./charts":10,"./planCapitalization":12,"pddl-workspace":32,"vscode-uri":80}],8:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPlansView = exports.PlansView = void 0;
const PlanView_1 = require("./PlanView");
const PLAN_SELECTORS = "planSelectors";
const PLAN_SELECTOR = "planSelector";
const PLAN_SELECTOR_SELECTED = PLAN_SELECTOR + "-selected";
const PLAN_VIEWS = "planViews";
/** Multiple-plan view. */
class PlansView extends PlanView_1.View {
    constructor(hostElement, options) {
        super(hostElement, options);
        this.selectedPlan = -1;
        this.plans = [];
        this.planViews = [];
        this.onPlanSelected = options.onPlanSelected;
        this.clear();
    }
    clear() {
        this.showPlans([], -1);
    }
    /**
     * Get `PlanView` for the plan at given `planIndex`
     * @param planIndex plan index
     * @throws when planIndex is out of range
     */
    getView(planIndex) {
        return this.planViews[planIndex];
    }
    showPlans(plans, planId = -1, configuration) {
        this.selectedPlan = planId < 0 ? plans.length - 1 : planId;
        this.plans = plans;
        this.planViews = [];
        this.createPlanSelectors();
        this.createPlanViews(configuration);
    }
    addPlan(plan, configuration) {
        const planIndex = this.plans.push(plan) - 1;
        this.createPlanSelectors();
        this.planViewsEl && this.addPlanView(plan, planIndex, this.planViewsEl, configuration);
    }
    setSelectedPlan(newSelectedPlan) {
        var _a;
        if (this.selectedPlan != newSelectedPlan) {
            // remember the index of the plan that is being shown for later manipulation
            this.selectedPlan = newSelectedPlan;
            (_a = this.onPlanSelected) === null || _a === void 0 ? void 0 : _a.call(this, this.selectedPlan);
        }
    }
    createPlanSelectors() {
        const planSelectorsEl = this.getOrCreateBlankChildElement(PLAN_SELECTORS);
        planSelectorsEl.style.display = this.plans.length > 1 ? "flex" : "none";
        const maxMetric = Math.max(...this.plans.map(plan => { var _a; return (_a = plan.metric) !== null && _a !== void 0 ? _a : 0; }));
        this.plans.forEach((plan, planIndex) => this.createPlanSelector(plan, planIndex, this.selectedPlan, maxMetric, planSelectorsEl));
        this.scrollPlanSelectorIntoView(this.selectedPlan);
    }
    createPlanSelector(plan, planIndex, selectedPlan, maxMetric, parentEl) {
        var _a;
        const normalizedMetric = ((_a = plan.metric) !== null && _a !== void 0 ? _a : 0) / maxMetric * 100;
        const costRounded = plan.metric !== undefined ? plan.metric.toFixed(PlanView_1.DIGITS) : NaN.toString();
        const tooltip = `Plan #${planIndex}
Metric value / cost: ${plan.metric}
Makespan: ${plan.makespan}
States evaluated: ${plan.statesEvaluated}`;
        const planSelectorEl = document.createElement('div');
        planSelectorEl.className = PLAN_SELECTOR;
        if (planIndex === selectedPlan) {
            planSelectorEl.classList.add(PLAN_SELECTOR_SELECTED);
        }
        planSelectorEl.setAttribute(PlanView_1.ATTR_PLAN, planIndex.toString());
        planSelectorEl.onclick = () => this.showSelectedPlan(planIndex);
        const label = document.createElement("span");
        label.innerText = costRounded;
        planSelectorEl.appendChild(label);
        const bar = document.createElement("div");
        bar.className = "planMetricBar";
        bar.style.height = (0, PlanView_1.px)(normalizedMetric);
        bar.title = tooltip;
        planSelectorEl.appendChild(bar);
        parentEl.appendChild(planSelectorEl);
    }
    createPlanViews(configuration) {
        const planViesEl = this.planViewsEl = this.getOrCreateBlankChildElement(PLAN_VIEWS);
        this.plans.forEach((plan, planIndex) => this.addPlanView(plan, planIndex, planViesEl, configuration));
    }
    addPlanView(plan, planIndex, parent, configuration) {
        const newPlanView = (0, PlanView_1.appendPlanView)(parent, planIndex, this.options);
        newPlanView.showPlan(plan, configuration);
        this.showSelectedPlan(planIndex);
        this.planViews[planIndex] = newPlanView;
    }
    showSelectedPlan(selectedPlanIndex) {
        this.setSelectedPlan(selectedPlanIndex);
        this.planViews.forEach(planView => {
            planView.setVisible(planView.planIndex === selectedPlanIndex);
        });
        document.querySelectorAll("div." + PLAN_SELECTOR).forEach(div => {
            const planIdAsStr = div.getAttribute(PlanView_1.ATTR_PLAN);
            if (planIdAsStr !== null) {
                const planId = parseInt(planIdAsStr);
                if (selectedPlanIndex === planId) {
                    div.classList.add(PLAN_SELECTOR_SELECTED);
                }
                else {
                    div.classList.remove(PLAN_SELECTOR_SELECTED);
                }
            }
            else {
                console.warn(`planSelector element does not have the 'plan' attribute`);
            }
        });
    }
    /**
     * Ensures the plan selector with the given index is visible by scrolling the plan selectors div.
     * @param planIndex plan selector to scroll to
     */
    scrollPlanSelectorIntoView(planIndex) {
        document.querySelectorAll('div.' + PLAN_SELECTOR).forEach(div => {
            var _a;
            if (parseInt((_a = div.getAttribute(PlanView_1.ATTR_PLAN)) !== null && _a !== void 0 ? _a : "-1") === planIndex) {
                div.scrollIntoView();
            }
        });
    }
}
exports.PlansView = PlansView;
function createPlansView(hostElementId, options) {
    const hostElement = (0, PlanView_1.getHostElement)(hostElementId);
    return new PlansView(hostElement, options);
}
exports.createPlansView = createPlansView;

},{"./PlanView":7}],9:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwimLane = void 0;
/**
 * Swim lane visualization for activities that may run in sequence or in parallel.
 * This utility helps placing activities into the lane, so they do not overlap.
 */
class SwimLane {
    /**
     * Constructs the swim lane
     * @param separation separation enforced between bars in the sane lane (default is 0)
     */
    constructor(separation = 0) {
        this.separation = separation;
        /** Lanes and the width at which the last step in each of them ends. */
        this.subLaneEnds = [];
    }
    /**
     * Finds the first available lane that is not already occupied at offset leftOffset
     * @param leftOffset offset from the left for the new step to be placed
     * @param width step width
     */
    placeNext(leftOffset, width) {
        let availableLane = -1;
        for (let index = 0; index < this.subLaneEnds.length; index++) {
            if (this.subLaneEnds[index] + this.separation < leftOffset) {
                availableLane = index;
                break;
            }
        }
        if (availableLane < 0) {
            // no lane was available, must create a new one
            this.subLaneEnds.push(0);
            availableLane = this.subLaneEnds.length - 1;
        }
        // adjust the lane end to the end of the newly placed activity
        this.subLaneEnds[availableLane] = leftOffset + width;
        return availableLane;
    }
    laneCount() {
        return this.subLaneEnds.length;
    }
    laneEnd(idx) {
        if (idx >= this.subLaneEnds.length) {
            throw new Error('Lane does not exist');
        }
        return this.subLaneEnds[idx];
    }
}
exports.SwimLane = SwimLane;

},{}],10:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.drawChart = exports.isInViewport = void 0;
/**
 * Tests whether _any_ portion of the el is visible.
 * @param el HTML element
 */
function isInViewport(el) {
    if (["hidden", "collapse"].includes(el.style.visibility)) {
        return false;
    }
    const rect = el.getBoundingClientRect();
    return rect.bottom >= 0 &&
        rect.right >= 0 &&
        rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.left <= (window.innerWidth || document.documentElement.clientWidth);
}
exports.isInViewport = isInViewport;
let chartDefined = false;
try {
    google.charts.load('current', { packages: ['corechart', 'line'] });
    chartDefined = true;
}
catch (err) {
    const error = err;
    console.warn((_a = error.message) !== null && _a !== void 0 ? _a : error);
}
function drawChart(chartDiv, functionName, unit, objects, columnData) {
    if (!chartDefined) {
        return;
    }
    const data = new google.visualization.DataTable();
    data.addColumn('number', 'X');
    objects.forEach(obj => {
        data.addColumn('number', obj);
    });
    data.addRows(columnData);
    const options = {
        hAxis: {
            title: 'Time',
            minValue: 0
        },
        vAxis: {
            title: unit,
            scaleType: 'linear' //vAxisScaleType = 'log'
        },
        interpolateNulls: false,
        title: functionName
    };
    const chart = new google.visualization.LineChart(chartDiv);
    chart.draw(data, options);
}
exports.drawChart = drawChart;

},{}],11:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./PlanView"), exports);
__exportStar(require("./PlansView"), exports);
__exportStar(require("./DomainVizConfigurationSchema"), exports);
__exportStar(require("./JsonDomainVizConfiguration"), exports);
__exportStar(require("./DomainVizConfiguration"), exports);
__exportStar(require("./CustomVisualization"), exports);
__exportStar(require("./planCapitalization"), exports);

},{"./CustomVisualization":3,"./DomainVizConfiguration":4,"./DomainVizConfigurationSchema":5,"./JsonDomainVizConfiguration":6,"./PlanView":7,"./PlansView":8,"./planCapitalization":12}],12:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi 2020. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.capitalizeStep = exports.capitalize = void 0;
const pddl_workspace_1 = require("pddl-workspace");
/** Aligns action and object capitalization with the definitions in the domain and problem */
/* eslint-disable @typescript-eslint/no-use-before-define */
/**
 * Changes capitalization of the plan action names and object names to match the domain/problem.
 * This is assuming the case-insensitive PDDL treatment.
 * @param plan orig plan
 */
function capitalize(plan) {
    if (!plan.domain || !plan.problem) {
        return plan;
    }
    const actionNames = plan.domain.getActions().map(a => { var _a; return (_a = a.name) !== null && _a !== void 0 ? _a : ''; });
    const capitalizedSteps = plan.steps
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        .map(step => capitalizeStep(step, actionNames, plan.problem));
    const capitalizedPlan = new pddl_workspace_1.Plan(capitalizedSteps, plan.domain, plan.problem, plan.now, plan.helpfulActions);
    if (plan.isMetricDefined()) {
        capitalizedPlan.metric = plan.metric;
    }
    return capitalizedPlan;
}
exports.capitalize = capitalize;
function capitalizeStep(step, actionNames, problem) {
    var _a, _b, _c;
    let changed = false;
    let changedActionName = step.getActionName();
    if (!actionNames.includes(step.getActionName())) {
        const matchingDomainAction = actionNames.find(name => name.toLowerCase() === step.getActionName().toLowerCase());
        if (matchingDomainAction) {
            changed = true;
            changedActionName = matchingDomainAction;
        }
    }
    const changedObjects = [];
    for (let i = 0; i < step.getObjects().length; i++) {
        const origObject = step.getObjects()[i];
        const objectExists = (_a = problem.getObjectsTypeMap().getTypeOf(origObject)) === null || _a === void 0 ? void 0 : _a.hasObject(origObject);
        if (!objectExists) {
            const matchingObject = (_c = (_b = problem.getObjectsTypeMap().getTypeOfCaseInsensitive(origObject)) === null || _b === void 0 ? void 0 : _b.getObjects()) === null || _c === void 0 ? void 0 : _c.find(o => o.toLowerCase() === origObject.toLowerCase());
            if (matchingObject) {
                changed = true;
                changedObjects[i] = matchingObject;
            }
            else {
                changedObjects[i] = origObject;
            }
        }
        else {
            changedObjects[i] = origObject;
        }
    }
    if (changed) {
        let fullActionName = changedActionName;
        if (changedObjects.length) {
            fullActionName += ' ' + changedObjects.join(' ');
        }
        return new pddl_workspace_1.PlanStep(step.getStartTime(), fullActionName, step.isDurative, step.getDuration(), step.lineIndex, step.commitment, step.getIterations());
    }
    else {
        return step;
    }
}
exports.capitalizeStep = capitalizeStep;

},{"pddl-workspace":32}],13:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"_process":237,"dup":1,"timers":256}],14:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],15:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleDocumentPositionResolver = exports.DocumentPositionResolver = exports.PddlRange = exports.PddlPosition = void 0;
class PddlPosition {
    constructor(line, character) {
        this.line = line;
        this.character = character;
    }
    atOrBefore(other) {
        if (this.line === other.line) {
            return this.character <= other.character;
        }
        else {
            return this.line < other.line;
        }
    }
    toString() {
        return `${this.line}:${this.character}`;
    }
}
exports.PddlPosition = PddlPosition;
/**
 * This is a local version of the vscode Range class, but because the parser is used in both the extension (client)
 * and the language server, where the Range class is defined separately, we need a single proprietary implementation,
 * which is converted to the VS Code class specific to the two distinct client/server environment.
 */
class PddlRange {
    constructor(details) {
        this._start = details.start;
        this._end = details.end;
    }
    static createRange(details) {
        return new PddlRange({
            start: new PddlPosition(details.startLine, details.startCharacter),
            end: new PddlPosition(details.endLine, details.endCharacter)
        });
    }
    static createSingleCharacterRange(details) {
        const position = new PddlPosition(details.line, details.character);
        return new PddlRange({ start: position, end: position });
    }
    static createSingleLineRange(details) {
        var _a, _b, _c;
        if (((_a = details.end) !== null && _a !== void 0 ? _a : details.length) === undefined) {
            throw new Error("Either 'end' or 'length' must be specified.");
        }
        const start = new PddlPosition(details.line, details.start);
        const end = new PddlPosition(details.line, (_b = details.end) !== null && _b !== void 0 ? _b : details.start + ((_c = details.length) !== null && _c !== void 0 ? _c : 0));
        return new PddlRange({ start, end });
    }
    static createFullLineRange(line) {
        return new PddlRange({ start: new PddlPosition(line, 0), end: new PddlPosition(line, Number.MAX_VALUE) });
    }
    static createUnknown() {
        return this.createFullLineRange(Number.NaN);
    }
    includes(positionAtOffset) {
        return this.start.atOrBefore(positionAtOffset) && positionAtOffset.atOrBefore(this.end);
    }
    get start() {
        return this._start;
    }
    get end() {
        return this._end;
    }
    toString() {
        return `${this.start.toString()}~${this.end.toString()}`;
    }
}
exports.PddlRange = PddlRange;
/**
 * Abstract document position resolve. It translates document text offsets to Position or Range.
 */
class DocumentPositionResolver {
    resolveToRange(start, end) {
        return new PddlRange({ start: this.resolveToPosition(start), end: this.resolveToPosition(end) });
    }
    rangeIncludesOffset(range, offset) {
        const positionAtOffset = this.resolveToPosition(offset);
        return range.includes(positionAtOffset);
    }
    nodeToRange(node) {
        return this.resolveToRange(node.getStart(), node.getEnd());
    }
}
exports.DocumentPositionResolver = DocumentPositionResolver;
class SimpleDocumentPositionResolver extends DocumentPositionResolver {
    constructor(documentText) {
        super();
        this.documentText = documentText;
        this.lineLengths = this.documentText.split('\n')
            .map(line => line.length + 1);
    }
    resolveToPosition(offset) {
        let documentLengthAtCurrentLineStart = 0;
        let documentLengthAtCurrentLineEnd = 0;
        for (let lineIndex = 0; lineIndex < this.lineLengths.length; lineIndex++) {
            const currentLineLength = this.lineLengths[lineIndex];
            documentLengthAtCurrentLineEnd += currentLineLength;
            if (offset >= documentLengthAtCurrentLineStart && offset < documentLengthAtCurrentLineEnd) {
                const character = offset - documentLengthAtCurrentLineStart;
                return new PddlPosition(lineIndex, character);
            }
            documentLengthAtCurrentLineStart = documentLengthAtCurrentLineEnd;
        }
        throw new Error(`Offset ${offset} is outside the document.`);
    }
}
exports.SimpleDocumentPositionResolver = SimpleDocumentPositionResolver;

},{}],16:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnrecognizedStructure = exports.DurativeAction = exports.InstantAction = exports.Action = exports.PddlDomainConstruct = exports.DomainInfo = exports.TypeObjectMap = exports.TypeObjects = void 0;
const DirectionalGraph_1 = require("./utils/DirectionalGraph");
const serializationUtils_1 = require("./utils/serializationUtils");
const FileInfo_1 = require("./FileInfo");
const language_1 = require("./language");
const PddlSyntaxTree_1 = require("./parser/PddlSyntaxTree");
const DocumentPositionResolver_1 = require("./DocumentPositionResolver");
const PddlTokenizer_1 = require("./parser/PddlTokenizer");
/**
 * Holds objects belonging to the same type.
 */
class TypeObjects {
    constructor(type) {
        this.type = type;
        this.objects = new Set();
    }
    getObjects() {
        return [...this.objects.keys()];
    }
    addObject(obj) {
        this.objects.add(obj);
        return this;
    }
    addAllObjects(objects) {
        objects.forEach(o => this.addObject(o));
        return this;
    }
    hasObjectCaseInsensitive(objectName) {
        return [...this.objects.keys()]
            .some(o => o.toLowerCase() === objectName.toLowerCase());
    }
    hasObject(objectName) {
        return this.objects.has(objectName);
    }
    getObjectInstance(objectName) {
        return new language_1.ObjectInstance(objectName, this.type);
    }
}
exports.TypeObjects = TypeObjects;
class TypeObjectMap {
    constructor() {
        this.typeNameToTypeObjectMap = new Map();
        this.objectNameToTypeObjectMap = new Map();
        this.objectNameCaseInsensitiveToTypeObjectMap = new Map();
    }
    /**
     * Re-hydrates de-serialized type-object map
     * @param other de-serialized
     */
    static clone(other) {
        const map = new TypeObjectMap();
        const otherMap = (0, serializationUtils_1.objToStrMap)(other);
        otherMap.forEach((typeObjects) => {
            map.addAll(typeObjects.type, typeObjects.objects);
        });
        return map;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toJSON(_key) {
        return (0, serializationUtils_1.asSerializable)(this.typeNameToTypeObjectMap);
    }
    get length() {
        return this.typeNameToTypeObjectMap.size;
    }
    merge(other) {
        const mergedMap = new TypeObjectMap();
        this.valuesArray().concat(other.valuesArray())
            .forEach(typeObj => mergedMap.addAll(typeObj.type, typeObj.getObjects()));
        return mergedMap;
    }
    /**
     * Adds object to type.
     * @param type type name (currently case insensitive)
     * @param objectName object name (currently case sensitive)
     */
    add(type, objectName) {
        this._upsert(type, typeObjects => {
            typeObjects.addObject(objectName);
            // store map of object-to-type
            this.objectNameCaseInsensitiveToTypeObjectMap.set(objectName.toLowerCase(), typeObjects);
            this.objectNameToTypeObjectMap.set(objectName, typeObjects);
        });
        return this;
    }
    addAll(type, objects) {
        this._upsert(type, typeObjects => {
            typeObjects.addAllObjects(objects);
            // store map of object-to-type
            objects.forEach(objName => {
                this.objectNameCaseInsensitiveToTypeObjectMap.set(objName.toLowerCase(), typeObjects);
                this.objectNameToTypeObjectMap.set(objName, typeObjects);
            });
        });
        return this;
    }
    _upsert(type, inserter) {
        var _a;
        const typeFound = (_a = this.getTypeCaseInsensitive(type)) !== null && _a !== void 0 ? _a : new TypeObjects(type);
        inserter.apply(this, [typeFound]);
        this.typeNameToTypeObjectMap.set(type.toLowerCase(), typeFound);
    }
    valuesArray() {
        return [...this.typeNameToTypeObjectMap.values()];
    }
    /**
     * Returns the `TypeObjects` structure for the lower-cased `type` supplied.
     * @param type case-insensitive type name
     */
    getTypeCaseInsensitive(type) {
        return this.typeNameToTypeObjectMap.get(type.toLowerCase());
    }
    /**
     * Returns the `TypeObjects` structure for a type that has the `objectName` supplied.
     * @param objectName case-sensitive object name
     */
    getTypeOf(objectName) {
        return this.objectNameToTypeObjectMap.get(objectName);
    }
    /**
     * Returns the `TypeObjects` structure for a type that has lower-cased `objectName` supplied.
     * @param objectName case-insensitive object name
     */
    getTypeOfCaseInsensitive(objectName) {
        return this.objectNameCaseInsensitiveToTypeObjectMap.get(objectName.toLowerCase());
    }
}
exports.TypeObjectMap = TypeObjectMap;
/**
 * Domain file.
 */
class DomainInfo extends FileInfo_1.FileInfo {
    constructor(fileUri, version, domainName, syntaxTree, positionResolver) {
        super(fileUri, version, domainName, syntaxTree, positionResolver);
        this.syntaxTree = syntaxTree;
        this.predicates = [];
        this.functions = [];
        this.derived = [];
        this.actions = [];
        this.typeInheritance = new DirectionalGraph_1.DirectionalGraph();
        this.typeLocations = new Map();
        this.constants = new TypeObjectMap();
        this.constraints = [];
        this.TYPES_SECTION_START = "(:types";
    }
    /**
     * Copy constructor for re-constructing the domain from a serialized form.
     * @param domain de-serialized domain
     */
    static clone(domain) {
        const clonedDomain = new DomainInfo(domain.fileUri, Number.NaN, domain.name, PddlSyntaxTree_1.PddlSyntaxTree.EMPTY, new DocumentPositionResolver_1.SimpleDocumentPositionResolver(''));
        clonedDomain.setActions(domain.actions.map(a => this.cloneAction(a)));
        clonedDomain.setConstants(TypeObjectMap.clone(domain.constants));
        clonedDomain.setConstraints(domain.constraints);
        clonedDomain.setDerived(domain.derived);
        domain.events && clonedDomain.setEvents(domain.events);
        clonedDomain.setFunctions(domain.functions);
        clonedDomain.setPredicates(domain.predicates);
        domain.processes && clonedDomain.setProcesses(domain.processes);
        // todo: domain.requirements && clonedDomain.setRequirements(domain.getRequirements());
        clonedDomain.setTypeInheritance(DirectionalGraph_1.DirectionalGraph.fromGraph(domain.typeInheritance));
        return clonedDomain;
    }
    static cloneAction(action) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const actionAny = action;
        if ('duration' in actionAny) {
            return new DurativeAction(action.name, action.parameters, DocumentPositionResolver_1.PddlRange.createUnknown());
        }
        else {
            return new InstantAction(action.name, action.parameters, DocumentPositionResolver_1.PddlRange.createUnknown());
        }
    }
    getLanguage() {
        return language_1.PddlLanguage.PDDL;
    }
    getPredicates() {
        return this.predicates;
    }
    setPredicates(predicates) {
        this.predicates = predicates;
    }
    getFunctions() {
        return this.functions;
    }
    setFunctions(functions) {
        this.functions = functions;
    }
    getFunction(liftedVariableName) {
        return this.functions
            .find(variable => variable.name.toLocaleLowerCase() === liftedVariableName.toLocaleLowerCase());
    }
    getLiftedFunction(groundedVariable) {
        return this.getFunction(groundedVariable.name);
    }
    getDerived() {
        return this.derived;
    }
    setDerived(derived) {
        this.derived = derived;
    }
    setActions(actions) {
        this.actions = actions;
    }
    getActions() {
        return this.actions;
    }
    getStructures() {
        const structures = new Array();
        structures.push(...this.getActions());
        const events = this.getEvents();
        if (events) {
            structures.push(...events);
        }
        const processes = this.getProcesses();
        if (processes) {
            structures.push(...processes);
        }
        return structures;
    }
    getTypeInheritance() {
        return this.typeInheritance;
    }
    setTypeInheritance(typeInheritance, typesNode, positionResolver) {
        this.typeInheritance = typeInheritance;
        if (typesNode && positionResolver) {
            this.getTypes().forEach(typeName => {
                const typeNode = typesNode.getFirstChild(PddlTokenizer_1.PddlTokenType.Other, new RegExp("^" + typeName + "$"));
                if (typeNode) {
                    const range = new DocumentPositionResolver_1.PddlRange({
                        start: positionResolver.resolveToPosition(typeNode.getStart()),
                        end: positionResolver.resolveToPosition(typeNode.getEnd())
                    });
                    this.typeLocations.set(typeName, range);
                }
            });
        }
    }
    setConstants(constants) {
        this.constants = constants;
    }
    getConstants() {
        return this.constants;
    }
    getTypes() {
        return this.typeInheritance.getVertices()
            .filter(t => t.toLowerCase() !== "object");
    }
    getTypesInclObject() {
        return this.typeInheritance.getVertices();
    }
    isDomain() {
        return true;
    }
    getTypesInheritingFrom(type) {
        return this.typeInheritance.getSubtreePointingTo(type);
    }
    getEvents() {
        return this.events;
    }
    setEvents(events) {
        this.events = events;
    }
    getProcesses() {
        return this.processes;
    }
    setProcesses(processes) {
        this.processes = processes;
    }
    getConstraints() {
        return this.constraints;
    }
    setConstraints(constraints) {
        this.constraints = constraints;
    }
    getTypeLocation(type) {
        return this.typeLocations.get(type);
    }
}
exports.DomainInfo = DomainInfo;
class PddlDomainConstruct {
    constructor(name, parameters, location) {
        this.name = name;
        this.parameters = parameters;
        this.location = location;
        this.documentation = []; // initialized lazily
    }
    getLocation() {
        return this.location;
    }
    setDocumentation(documentation) {
        this.documentation = documentation;
    }
    getDocumentation() {
        return this.documentation;
    }
    getNameOrEmpty() {
        var _a;
        return (_a = this.name) !== null && _a !== void 0 ? _a : '';
    }
}
exports.PddlDomainConstruct = PddlDomainConstruct;
class Action extends PddlDomainConstruct {
}
exports.Action = Action;
class InstantAction extends Action {
    constructor(name, parameters, location, preCondition, effect) {
        super(name, parameters, location);
        this.preCondition = preCondition;
        this.effect = effect;
    }
    isDurative() {
        return false;
    }
}
exports.InstantAction = InstantAction;
class DurativeAction extends Action {
    constructor(name, parameters, location, duration, condition, effect) {
        super(name, parameters, location);
        this.duration = duration;
        this.condition = condition;
        this.effect = effect;
    }
    isDurative() {
        return true;
    }
}
exports.DurativeAction = DurativeAction;
class UnrecognizedStructure extends PddlDomainConstruct {
    constructor(range) {
        super("unrecognized", [], range);
    }
}
exports.UnrecognizedStructure = UnrecognizedStructure;

},{"./DocumentPositionResolver":15,"./FileInfo":17,"./language":33,"./parser/PddlSyntaxTree":52,"./parser/PddlTokenizer":54,"./utils/DirectionalGraph":73,"./utils/serializationUtils":77}],17:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnknownFileInfo = exports.ParsingProblem = exports.FileInfo = exports.stripComments = void 0;
const DocumentPositionResolver_1 = require("./DocumentPositionResolver");
const PddlSyntaxTree_1 = require("./parser/PddlSyntaxTree");
const PddlTokenizer_1 = require("./parser/PddlTokenizer");
const language_1 = require("./language");
function stripComments(pddlText) {
    const lines = pddlText.split(/\r?\n/g);
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const index = line.indexOf(';');
        if (index > -1) {
            lines[i] = line.substring(0, index);
        }
    }
    return lines.join("\n");
}
exports.stripComments = stripComments;
/**
 * An abstract PDDL file.
 */
class FileInfo {
    constructor(fileUri, version, name, syntaxTree, positionResolver) {
        this.fileUri = fileUri;
        this.version = version;
        this.name = name;
        this.syntaxTree = syntaxTree;
        this.positionResolver = positionResolver;
        this.status = language_1.FileStatus.Parsed;
        this.parsingProblems = [];
    }
    getVersion() {
        return this.version;
    }
    getText() {
        if (this.text) {
            return this.text;
        }
        else {
            throw new Error('Accessing getText() before file was parsed');
        }
    }
    setText(text) {
        this.text = text;
    }
    isDomain() {
        return false;
    }
    isProblem() {
        return false;
    }
    isUnknownPddl() {
        return false;
    }
    isPlan() {
        return false;
    }
    isHappenings() {
        return false;
    }
    update(version, text, force = false) {
        const isNewerVersion = (version > this.version) || force;
        if (isNewerVersion) {
            this.setStatus(language_1.FileStatus.Dirty);
            this.version = version;
            this.text = text;
        }
        return isNewerVersion;
    }
    setStatus(status) {
        this.status = status;
    }
    getStatus() {
        return this.status;
    }
    /**
     * Adds a parsing problem.
     * @param parsingProblem parsing problems
     */
    addProblem(parsingProblem) {
        this.parsingProblems.push(parsingProblem);
    }
    /**
     * Adds list of parsing problems.
     * @param parsingProblems parsing problems
     */
    addProblems(parsingProblems) {
        parsingProblems.forEach(pp => this.addProblem(pp));
    }
    getParsingProblems() {
        return this.parsingProblems;
    }
    getVariableReferences(variable) {
        const referenceLocations = [];
        this.syntaxTree.getDefineNode().getChildrenRecursively(node => this.isVariableReference(node, variable), node => referenceLocations.push(this.getRange(node)));
        return referenceLocations;
    }
    isVariableReference(node, variable) {
        if (node.getToken().type !== PddlTokenizer_1.PddlTokenType.OpenBracket) {
            return false;
        }
        const nonWhiteSpaceChildren = node.getNonWhitespaceChildren();
        if (nonWhiteSpaceChildren.length < 1) {
            return false;
        }
        const variableNameNode = nonWhiteSpaceChildren[0];
        return variableNameNode.getToken().type === PddlTokenizer_1.PddlTokenType.Other
            && variableNameNode.getToken().tokenText.toLowerCase() === variable.name.toLowerCase();
    }
    getTypeReferences(typeName) {
        if (!this.text) {
            return [];
        }
        const referenceLocations = [];
        const pattern = `-\\s+${typeName}\\b`;
        const lines = stripComments(this.text).split('\n');
        const regexp = new RegExp(pattern, "gi");
        for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
            const line = lines[lineIdx];
            regexp.lastIndex = 0;
            const match = regexp.exec(line);
            if (match) {
                const range = new DocumentPositionResolver_1.PddlRange({
                    start: new DocumentPositionResolver_1.PddlPosition(lineIdx, match.index + 2),
                    end: new DocumentPositionResolver_1.PddlPosition(lineIdx, match.index + match[0].length)
                });
                referenceLocations.push(range);
            }
        }
        return referenceLocations;
    }
    getRange(node) {
        return this.positionResolver.resolveToRange(node.getStart(), node.getEnd());
    }
    setRequirements(requirements) {
        this.requirements = requirements;
    }
    getRequirements() {
        if (this.requirements) {
            return this.requirements;
        }
        else {
            throw new Error('Accessing getRequirements() before file was parsed');
        }
    }
    getDocumentPositionResolver() {
        return this.positionResolver;
    }
}
exports.FileInfo = FileInfo;
/**
 * Parsing problem.
 */
class ParsingProblem {
    /**
     * Constructs parsing problem.
     * @param problem problem description to display
     * @param severity problem severity
     * @param range range where the problem is
     */
    constructor(problem, severity, range) {
        this.problem = problem;
        this.severity = severity;
        this.range = range;
    }
}
exports.ParsingProblem = ParsingProblem;
class UnknownFileInfo extends FileInfo {
    constructor(fileUri, version, positionResolver) {
        super(fileUri, version, "", PddlSyntaxTree_1.PddlSyntaxTree.EMPTY, positionResolver);
    }
    getLanguage() {
        return language_1.PddlLanguage.PDDL;
    }
    isUnknownPddl() {
        return true;
    }
}
exports.UnknownFileInfo = UnknownFileInfo;

},{"./DocumentPositionResolver":15,"./language":33,"./parser/PddlSyntaxTree":52,"./parser/PddlTokenizer":54}],18:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Grounder = void 0;
const language_1 = require("./language");
const typeInheritance_1 = require("./typeInheritance");
class Grounder {
    constructor(domain, problem) {
        this.domain = domain;
        this.problem = problem;
        this.typeObjects = this.domain.getConstants().merge(this.problem.getObjectsTypeMap());
    }
    getObjectsForType(typeName) {
        return (0, typeInheritance_1.getObjectsInheritingFrom)(this.typeObjects, typeName, this.domain.getTypeInheritance());
    }
    getObjects(typeNames) {
        return typeNames.map(typeName => this.getObjectsForType(typeName));
    }
    getObjectPermutations(typeNames) {
        const objects = this.getObjects(typeNames);
        if (typeNames.length === 0) {
            return [];
        }
        else if (typeNames.length === 1) {
            return objects[0].map(name => [name]);
        }
        else if (typeNames.length === 2) {
            const objectPermutations = [];
            for (let index0 = 0; index0 < objects[0].length; index0++) {
                for (let index1 = 0; index1 < objects[1].length; index1++) {
                    objectPermutations.push([objects[0][index0], objects[1][index1]]);
                }
            }
            return objectPermutations;
        }
        else {
            throw new Error("Not implemented for 3-ary+ relationships.");
        }
    }
    ground(variable) {
        if (variable.parameters.length === 0) {
            return [variable];
        }
        else if (variable.parameters.length <= 2) {
            const types = variable.parameters.map(p => p.type);
            const objectPermutations = this.getObjectPermutations(types);
            return objectPermutations.map(objectVector => new language_1.Variable(variable.declaredName, this.createObjectInstances(types, objectVector)));
        }
        else {
            //todo: handle variables with multiple parameters
            return [];
        }
    }
    createObjectInstances(types, objectVector) {
        if (types.length !== objectVector.length) {
            throw new Error('List of types and list objects have different sizes.');
        }
        return types.map((type, index) => new language_1.ObjectInstance(objectVector[index], type));
    }
}
exports.Grounder = Grounder;

},{"./language":33,"./typeInheritance":72}],19:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Happening = exports.HappeningsInfo = exports.HappeningType = void 0;
const FileInfo_1 = require("./FileInfo");
const PddlSyntaxTree_1 = require("./parser/PddlSyntaxTree");
const language_1 = require("./language");
var HappeningType;
(function (HappeningType) {
    /** Action start. */
    HappeningType[HappeningType["START"] = 0] = "START";
    /** Action end */
    HappeningType[HappeningType["END"] = 1] = "END";
    /** Instantaneous (non-durative) action */
    HappeningType[HappeningType["INSTANTANEOUS"] = 2] = "INSTANTANEOUS";
    /** Timed-action e.g. time-initial literal/fluent. */
    HappeningType[HappeningType["TIMED"] = 3] = "TIMED";
})(HappeningType = exports.HappeningType || (exports.HappeningType = {}));
/**
 * Plan happenings file.
 */
class HappeningsInfo extends FileInfo_1.FileInfo {
    constructor(fileUri, version, problemName, domainName, text, positionResolver) {
        super(fileUri, version, problemName, PddlSyntaxTree_1.PddlSyntaxTree.EMPTY, positionResolver);
        this.problemName = problemName;
        this.domainName = domainName;
        this.happenings = [];
        this.setText(text);
    }
    getLanguage() {
        return language_1.PddlLanguage.HAPPENINGS;
    }
    setHappenings(happenings) {
        this.happenings = happenings;
    }
    getHappenings() {
        return this.happenings;
    }
    isHappenings() {
        return true;
    }
}
exports.HappeningsInfo = HappeningsInfo;
/**
 * Single plan happening e.g. a thing that happens at a given time.
 */
class Happening {
    /**
     * Constructs happening instance.
     * @param time happening time
     * @param type happening type
     * @param fullActionName action name including parameter names
     * @param counter same happening counter
     * @param lineIndex line index in the file
     */
    constructor(time, type, fullActionName, counter, lineIndex) {
        this.time = time;
        this.type = type;
        this.fullActionName = fullActionName;
        this.counter = counter;
        this.lineIndex = lineIndex;
        const nameFragments = fullActionName.split(' ');
        this.actionName = nameFragments[0];
        this.objects = nameFragments.slice(1);
    }
    /**
     * Happening time.
     */
    getTime() {
        return this.time;
    }
    /**
     * Happening type: start/end/instantaneous/til/tif
     */
    getType() {
        return this.type;
    }
    /**
     * Action name without parameters.
     */
    getAction() {
        return this.actionName;
    }
    /**
     * Action name with parameters.
     */
    getFullActionName() {
        return this.fullActionName;
    }
    /**
     * Counter for the equivalent actions within the same plan.
     */
    getCounter() {
        return this.counter;
    }
    /**
     * Returns true if this happening belongs to the other happening.
     * It is decided by comparing the full action name and the counter.
     */
    belongsTo(other) {
        if (other === null || other === undefined) {
            return false;
        }
        return this.fullActionName === other.fullActionName
            && this.counter === other.counter;
    }
    toString() {
        return `${this.time}: ${this.toHappeningType(this.type)} (${this.fullActionName}) #${this.counter}`;
    }
    toHappeningType(type) {
        switch (type) {
            case HappeningType.START:
                return 'start ';
            case HappeningType.END:
                return 'end ';
            default:
                return '';
        }
    }
}
exports.Happening = Happening;

},{"./FileInfo":17,"./language":33,"./parser/PddlSyntaxTree":52}],20:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2019. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableReferenceKind = exports.UnrecognizedVariableReferenceInfo = exports.VariableEffectReferenceInfo = exports.VariableReferenceInfo = exports.ReferenceInfo = exports.ModelHierarchy = void 0;
const DomainInfo_1 = require("./DomainInfo");
const PddlTokenizer_1 = require("./parser/PddlTokenizer");
const ActionEffectParser_1 = require("./parser/ActionEffectParser");
class ModelHierarchy {
    constructor(domainInfo) {
        this.domainInfo = domainInfo;
    }
    rangeIncludesOffset(range, offset) {
        return this.domainInfo.getDocumentPositionResolver()
            .rangeIncludesOffset(range, offset);
    }
    getReferenceInfo(variableInfo, startOffset) {
        var _a, _b, _c, _d, _e;
        const referenceNode = this.domainInfo.syntaxTree.getNodeAt(startOffset);
        const domainActionFound = this.domainInfo.getStructures()
            .find(domainAction => this.rangeIncludesOffset(domainAction.getLocation(), startOffset));
        // todo: support constraints
        // let constraintFound = this.domainInfo.getConstraints()
        //     .find(c => c.node.includesIndex(startOffset));
        if (domainActionFound) {
            if (domainActionFound instanceof DomainInfo_1.DurativeAction) {
                const durativeAction = domainActionFound;
                // is it referenced by the duration?
                if ((_a = durativeAction.duration) === null || _a === void 0 ? void 0 : _a.includesIndex(startOffset)) {
                    return this.getReadOnlyReferenceInfo(referenceNode, variableInfo, durativeAction, "duration");
                }
                // read by a condition?
                else if ((_b = durativeAction.condition) === null || _b === void 0 ? void 0 : _b.includesIndex(startOffset)) {
                    const timeQualifierNode = ModelHierarchy.findConditionTimeQualifier(referenceNode);
                    return this.getConditionReferenceInfo(referenceNode, variableInfo, durativeAction, timeQualifierNode);
                }
                // accessed by an effect?
                else if ((_c = durativeAction.effect) === null || _c === void 0 ? void 0 : _c.includesIndex(startOffset)) {
                    const timeQualifierNode = ModelHierarchy.findConditionTimeQualifier(referenceNode);
                    return this.getEffectReferenceInfo(referenceNode, variableInfo, durativeAction, timeQualifierNode);
                }
                else {
                    return new VariableReferenceInfo(durativeAction, undefined, "", VariableReferenceKind.UNRECOGNIZED, referenceNode, referenceNode.expand().getText());
                }
            }
            else if (domainActionFound instanceof DomainInfo_1.InstantAction) {
                const instantAction = domainActionFound;
                // read by a condition?
                if ((_d = instantAction.preCondition) === null || _d === void 0 ? void 0 : _d.includesIndex(startOffset)) {
                    return this.getConditionReferenceInfo(referenceNode, variableInfo, instantAction, undefined);
                }
                // accessed by an effect?
                else if ((_e = instantAction.effect) === null || _e === void 0 ? void 0 : _e.includesIndex(startOffset)) {
                    return this.getEffectReferenceInfo(referenceNode, variableInfo, instantAction);
                }
                else {
                    return new VariableReferenceInfo(instantAction, undefined, "", VariableReferenceKind.UNRECOGNIZED, referenceNode, "");
                }
            }
            else {
                throw new Error("Unexpected action type.");
            }
        }
        // else if (constraintFound) {
        // todo: support for constraint
        // }
        else {
            const range = this.domainInfo.getDocumentPositionResolver().nodeToRange(referenceNode);
            return new UnrecognizedVariableReferenceInfo(referenceNode, range);
        }
    }
    getConditionReferenceInfo(referenceNode, _variableInfo, structure, timeQualifierNode) {
        return this.getReadOnlyReferenceInfo(referenceNode, _variableInfo, structure, "condition", timeQualifierNode);
    }
    getReadOnlyReferenceInfo(referenceNode, _variableInfo, structure, part, timeQualifierNode) {
        var _a;
        let conditionNode = referenceNode;
        while (!['(=', '(>', '(<', '(>=', '(<=', '(not'].includes(conditionNode.getToken().tokenText)) {
            const parentNode = (_a = conditionNode.getParent()) !== null && _a !== void 0 ? _a : conditionNode;
            if (parentNode === timeQualifierNode ||
                parentNode.isType(PddlTokenizer_1.PddlTokenType.Keyword) ||
                parentNode.isDocument() ||
                ['(and', '(at start', '(at end', '(over all'].includes(parentNode.getToken().tokenText.toLowerCase())) {
                break;
            }
            conditionNode = parentNode;
        }
        return new VariableReferenceInfo(structure, timeQualifierNode, part, VariableReferenceKind.READ, referenceNode, conditionNode.getText());
    }
    getEffectReferenceInfo(referenceNode, variableInfo, structure, timeQualifierNode) {
        var _a;
        let effectNode = referenceNode;
        while (!['(increase', '(decrease', '(scale-up', '(scale-down', '(assign', '(not'].includes(effectNode.getToken().tokenText)) {
            const parentNode = (_a = effectNode.getParent()) !== null && _a !== void 0 ? _a : effectNode;
            if (parentNode === timeQualifierNode ||
                parentNode.isType(PddlTokenizer_1.PddlTokenType.Keyword) ||
                parentNode.isDocument() ||
                ['(and', '(at start', '(at end'].includes(parentNode.getToken().tokenText.toLowerCase())) {
                break;
            }
            effectNode = parentNode;
        }
        const effect = ActionEffectParser_1.ActionEffectParser.parseEffect(effectNode);
        const kind = effect instanceof ActionEffectParser_1.VariableEffect && effect.modifies(variableInfo) ?
            VariableReferenceKind.WRITE : VariableReferenceKind.READ;
        return new VariableEffectReferenceInfo(structure, timeQualifierNode, "effect", kind, effect, referenceNode, effect.toPddlString());
    }
    static isInsideCondition(currentNode) {
        return ModelHierarchy.findConditionAncestor(currentNode) !== undefined;
    }
    static findConditionAncestor(currentNode) {
        return currentNode.findAncestor(PddlTokenizer_1.PddlTokenType.Keyword, /^\s*:condition$/i);
    }
    static isInsideDurativeActionUnqualifiedCondition(currentNode) {
        return ModelHierarchy.findDurativeActionAncestor(currentNode) !== undefined
            && ModelHierarchy.findConditionTimeQualifier(currentNode) === undefined;
    }
    static findDurativeActionAncestor(currentNode) {
        return currentNode.findAncestor(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /^\(\s*:durative-action/i);
    }
    static findConditionTimeQualifier(currentNode) {
        return currentNode.findAncestor(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /^\(\s*(at\s+start|at\s+end|over\s+all)/i);
    }
    static isInsideDurativeActionDiscreteEffect(currentNode) {
        return currentNode.findAncestor(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /\(\s*:durative-action/i) !== undefined
            && currentNode.findAncestor(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /\(\s*(at start|at end)/i) !== undefined;
    }
    static isInsideActionOrEvent(currentNode) {
        return currentNode.findAncestor(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /\(\s*:(action|event)/i) !== undefined;
    }
    static isInsideEffect(currentNode) {
        return currentNode.findAncestor(PddlTokenizer_1.PddlTokenType.Keyword, /^\s*:effect$/i) !== undefined;
    }
    static isInsideDurativeActionUnqualifiedEffect(currentNode) {
        return currentNode.findAncestor(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /\(\s*:durative-action/i) !== undefined
            && currentNode.findAncestor(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /\(\s*(at start|at end)/i) === undefined;
    }
    static isInsideProcess(currentNode) {
        return currentNode.findAncestor(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /\(\s*:process/i) !== undefined;
    }
}
exports.ModelHierarchy = ModelHierarchy;
class ReferenceInfo {
    constructor(node) {
        this.node = node;
    }
}
exports.ReferenceInfo = ReferenceInfo;
class VariableReferenceInfo extends ReferenceInfo {
    constructor(structure, timeQualifierNode, part, kind, node, relevantCode) {
        super(node);
        this.structure = structure;
        this.timeQualifierNode = timeQualifierNode;
        this.part = part;
        this.kind = kind;
        this.relevantCode = relevantCode;
    }
    getTimeQualifier() {
        var _a, _b;
        return (_b = (_a = this.timeQualifierNode) === null || _a === void 0 ? void 0 : _a.getToken().tokenText.substr(1)) !== null && _b !== void 0 ? _b : "";
    }
    toString() {
        return `Accessed by structure \`${this.structure.getNameOrEmpty()}\` *${this.getTimeQualifier()}* ${this.part}`;
    }
}
exports.VariableReferenceInfo = VariableReferenceInfo;
class VariableEffectReferenceInfo extends VariableReferenceInfo {
    constructor(structure, timeQualifierNode, part, kind, effect, node, relevantCode) {
        super(structure, timeQualifierNode, part, kind, node, relevantCode);
        this.effect = effect;
    }
}
exports.VariableEffectReferenceInfo = VariableEffectReferenceInfo;
class UnrecognizedVariableReferenceInfo extends VariableReferenceInfo {
    constructor(node, range) {
        super(new DomainInfo_1.UnrecognizedStructure(range), undefined, "", VariableReferenceKind.UNRECOGNIZED, node);
    }
}
exports.UnrecognizedVariableReferenceInfo = UnrecognizedVariableReferenceInfo;
var VariableReferenceKind;
(function (VariableReferenceKind) {
    VariableReferenceKind[VariableReferenceKind["READ"] = 0] = "READ";
    VariableReferenceKind[VariableReferenceKind["READ_OR_WRITE"] = 1] = "READ_OR_WRITE";
    VariableReferenceKind[VariableReferenceKind["WRITE"] = 2] = "WRITE";
    VariableReferenceKind[VariableReferenceKind["UNRECOGNIZED"] = 3] = "UNRECOGNIZED";
})(VariableReferenceKind = exports.VariableReferenceKind || (exports.VariableReferenceKind = {}));

},{"./DomainInfo":16,"./parser/ActionEffectParser":34,"./parser/PddlTokenizer":54}],21:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Division = exports.Product = exports.Subtraction = exports.Sum = exports.NAryExpression = exports.BinaryExpression = exports.NumericLiteral = exports.VariableExpression = exports.NumericExpression = exports.ValueMap = void 0;
const language_1 = require("./language");
class ValueMap extends Map {
    constructor(...keyValues) {
        super(ValueMap.toEntryPairs(keyValues));
    }
    static toEntryPairs(keyValues) {
        if (keyValues.length % 2 === 1) {
            throw new Error("Must supply an even number of arguments to eval context");
        }
        const entries = [];
        for (let index = 0; index < keyValues.length; index += 2) {
            const key = keyValues[index];
            const value = keyValues[index + 1];
            if (typeof (key) !== "string") {
                throw new Error(`Expect string, but found ${key}`);
            }
            if (typeof (value) !== "number" && typeof (value) !== "boolean") {
                throw new Error(`Expect number|boolean, but found ${value}`);
            }
            entries.push([key, value]);
        }
        return entries;
    }
}
exports.ValueMap = ValueMap;
/**
 * Numeric expression.
 */
class NumericExpression {
    getVariableNames() {
        return this.getVariables().map(v => v.getFullName());
    }
}
exports.NumericExpression = NumericExpression;
class VariableExpression extends NumericExpression {
    constructor(name) {
        super();
        this.name = name;
        this.variable = language_1.Variable.fromGrounded(name);
    }
    getVariables() {
        return [this.variable];
    }
    evaluate(context) {
        const value = context.get(this.name);
        if (typeof (value) === "number") {
            return value;
        }
        else {
            return undefined;
        }
    }
}
exports.VariableExpression = VariableExpression;
class NumericLiteral extends NumericExpression {
    constructor(value) {
        super();
        this.value = value;
    }
    getVariables() {
        return [];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    evaluate(context) {
        return this.value;
    }
}
exports.NumericLiteral = NumericLiteral;
class BinaryExpression extends NumericExpression {
    constructor(operator, left, right) {
        super();
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
    getVariables() {
        return [this.left, this.right]
            .map(child => child.getVariables())
            .reduce((prev, curr) => prev.concat(curr), []);
    }
}
exports.BinaryExpression = BinaryExpression;
class NAryExpression extends NumericExpression {
    constructor(operator, children) {
        super();
        this.operator = operator;
        this.children = children;
    }
    getVariables() {
        return this.children
            .map(child => child.getVariables())
            .reduce((prev, curr) => prev.concat(curr), []);
    }
    evaluate(context) {
        return this.children
            .map(child => child.evaluate(context))
            .reduce(this.reduce, this.identity());
    }
}
exports.NAryExpression = NAryExpression;
class Sum extends NAryExpression {
    constructor(children) {
        super("+", children);
    }
    reduce(left, right) {
        if (left !== undefined && right !== undefined) {
            return left + right;
        }
        return undefined;
    }
    identity() {
        return 0;
    }
}
exports.Sum = Sum;
class Subtraction extends BinaryExpression {
    constructor(left, right) {
        super("+", left, right);
    }
    evaluate(context) {
        const leftValue = this.left.evaluate(context);
        const rightValue = this.right.evaluate(context);
        return leftValue !== undefined && rightValue !== undefined ?
            leftValue - rightValue :
            undefined;
    }
}
exports.Subtraction = Subtraction;
class Product extends NAryExpression {
    constructor(children) {
        super("*", children);
    }
    reduce(left, right) {
        if (left !== undefined && right !== undefined) {
            return left * right;
        }
        return undefined;
    }
    identity() {
        return 1;
    }
}
exports.Product = Product;
class Division extends BinaryExpression {
    constructor(left, right) {
        super("/", left, right);
    }
    evaluate(context) {
        const leftValue = this.left.evaluate(context);
        const rightValue = this.right.evaluate(context);
        return leftValue !== undefined && rightValue !== undefined ?
            leftValue / rightValue :
            undefined;
    }
}
exports.Division = Division;

},{"./language":33}],22:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],23:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlWorkspace = exports.FileType = exports.Folder = void 0;
const vscode_uri_1 = require("vscode-uri");
const events_1 = require("events");
const path_1 = require("path");
const HappeningsParser_1 = require("./parser/HappeningsParser");
const FileInfo_1 = require("./FileInfo");
const PddlSyntaxTreeBuilder_1 = require("./parser/PddlSyntaxTreeBuilder");
const DocumentPositionResolver_1 = require("./DocumentPositionResolver");
const PddlPlanParser_1 = require("./parser/PddlPlanParser");
const language_1 = require("./language");
const index_1 = require("./parser/index");
const PlannerRegistrar_1 = require("./planner/PlannerRegistrar");
function lowerCaseEquals(first, second) {
    if (first === null || first === undefined) {
        return second === null || second === undefined;
    }
    else if (second === null || second === undefined) {
        return first === null || first === undefined;
    }
    else {
        return first.toLowerCase() === second.toLowerCase();
    }
}
class Folder {
    constructor(folderPath) {
        this.folderPath = folderPath;
        this.files = new Map();
        this.folderUri = vscode_uri_1.URI.file(this.folderPath);
    }
    getFolderUri() {
        return this.folderUri;
    }
    hasFile(fileUri) {
        return this.files.has(fileUri.toString());
    }
    get(fileUri) {
        return this.files.get(fileUri.toString());
    }
    add(fileInfo) {
        if (fileInfo.fileUri.scheme !== "git") {
            this.files.set(fileInfo.fileUri.toString(), fileInfo);
        }
    }
    remove(fileInfo) {
        return this.files.delete(fileInfo.fileUri.toString());
    }
    removeByUri(fileUri) {
        return this.files.delete(fileUri.toString());
    }
    getProblemFileWithName(problemName) {
        return Array.from(this.files.values())
            .filter(value => value.isProblem())
            .map(value => value)
            .find(problemInfo => lowerCaseEquals(problemInfo.name, problemName));
    }
    getProblemFilesFor(domainInfo) {
        return Array.from(this.files.values())
            .filter(value => value.isProblem())
            .map(f => f)
            .filter(problemInfo => lowerCaseEquals(problemInfo.domainName, domainInfo.name));
    }
    getDomainFilesFor(problemInfo) {
        return Array.from(this.files.values())
            .filter(value => value.isDomain())
            .map(value => value)
            .filter(domainInfo => lowerCaseEquals(domainInfo.name, problemInfo.domainName));
    }
}
exports.Folder = Folder;
/**
 * Enumeration of file types. The types `File` and `Directory` can also be
 * a symbolic links, in that case use `FileType.File | FileType.SymbolicLink` and
 * `FileType.Directory | FileType.SymbolicLink`.
 */
var FileType;
(function (FileType) {
    /**
     * The file type is unknown.
     */
    FileType[FileType["Unknown"] = 0] = "Unknown";
    /**
     * A regular file.
     */
    FileType[FileType["File"] = 1] = "File";
    /**
     * A directory.
     */
    FileType[FileType["Directory"] = 2] = "Directory";
    /**
     * A symbolic link to a file.
     */
    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType = exports.FileType || (exports.FileType = {}));
function toFileNameTypeUri(folderUri, file) {
    return {
        fileName: file[0],
        fileType: file[1],
        fileUri: vscode_uri_1.URI.file((0, path_1.join)(folderUri.fsPath, file[0])),
    };
}
class PddlWorkspace extends events_1.EventEmitter {
    constructor(epsilon, context, fileLoader) {
        super();
        this.epsilon = epsilon;
        this.fileLoader = fileLoader;
        this.folders = new Map();
        this.defaultTimerDelayInSeconds = 1;
        this.lastVersionUpdateEmitted = new Map();
        /** Explicit associations between problem files and domain files. */
        this.problemToDomainMap = new Map();
        /** Explicit associations between plan files and problem files. */
        this.planToProblemMap = new Map();
        this.pddlFileParsers = [new index_1.PddlDomainParser(), new index_1.PddlProblemParser(context)];
        this.plannerRegistrar = new PlannerRegistrar_1.PlannerRegistrar();
    }
    getPlannerRegistrar() {
        return this.plannerRegistrar;
    }
    addExtension(extension) {
        if (extension.getPddlParsers) {
            const parsers = extension.getPddlParsers();
            if (parsers) {
                this.addPddlFileParser(parsers);
            }
        }
        if (extension.getPlannerProvider) {
            const plannerProviders = extension.getPlannerProvider();
            if (plannerProviders) {
                plannerProviders
                    .forEach(provider => this.plannerRegistrar.registerPlannerProvider(provider.kind, provider));
            }
        }
    }
    addPddlFileParser(parsers) {
        this.pddlFileParsers.unshift(...parsers);
        if (parsers.length > 0) {
            this.getAllFilesIf(fi => fi.getLanguage() === language_1.PddlLanguage.PDDL)
                .forEach(fi => this.invalidateDiagnostics(fi, language_1.FileStatus.Dirty));
            this.scheduleParsing();
        }
    }
    static getFolderPath(documentUri) {
        const documentPath = documentUri.fsPath;
        return (0, path_1.dirname)(documentPath);
    }
    static getFileName(documentUri) {
        const documentPath = documentUri.fsPath;
        return (0, path_1.basename)(documentPath);
    }
    static getFileInfoName(fileInfo) {
        return this.getFileName(fileInfo.fileUri);
    }
    async upsertAndParseFile(fileUri, language, fileVersion, fileText, positionResolver) {
        let fileInfo = await this.upsertFile(fileUri, language, fileVersion, fileText, positionResolver);
        if (fileInfo.getStatus() === language_1.FileStatus.Dirty) {
            fileInfo = await this.reParseFile(fileInfo);
        }
        return fileInfo;
    }
    async upsertFile(fileUri, language, fileVersion, fileText, positionResolver, force = false) {
        const folderPath = PddlWorkspace.getFolderPath(fileUri);
        const folder = this.upsertFolder(folderPath);
        let fileInfo = folder.get(fileUri);
        if (fileInfo) {
            if (fileInfo.update(fileVersion, fileText, force)) {
                this.scheduleParsing();
            }
        }
        else {
            fileInfo = await this.insertFile(folder, fileUri, language, fileVersion, fileText, positionResolver);
        }
        return fileInfo;
    }
    async insertFile(folder, fileUri, language, fileVersion, fileText, positionResolver) {
        const fileInfo = await this.parseFile(fileUri, language, fileVersion, fileText, positionResolver);
        folder.add(fileInfo);
        if (fileInfo.isDomain()) {
            this.markProblemsAsDirty(fileInfo);
        }
        else if (fileInfo.isProblem()) {
            this.markPlansAsDirty(fileInfo);
        }
        this.emitIfNew(PddlWorkspace.UPDATED, fileInfo);
        this.emitIfNew(PddlWorkspace.INSERTED, fileInfo);
        this.loadFolder(folder);
        return fileInfo;
    }
    async loadFolder(folder) {
        const folderUri = folder.getFolderUri();
        if (this.fileLoader) {
            const files = await this.fileLoader.readDirectory(folderUri);
            files
                .map(file => toFileNameTypeUri(folderUri, file))
                .filter(file => file.fileType === FileType.File
                && (0, path_1.extname)(file.fileName).toLowerCase() === '.' + language_1.PDDL
                && !folder.hasFile(file.fileUri)
                && folder.files.size < PddlWorkspace.MAX_FILES_PER_FOLDER)
                .forEach(async (file) => {
                var _a, _b;
                const fileContent = new TextDecoder("utf-8").decode(await ((_a = this.fileLoader) === null || _a === void 0 ? void 0 : _a.readFile(file.fileUri)));
                fileContent && this.insertFile(folder, file.fileUri, (_b = (0, language_1.toLanguageFromId)(language_1.PDDL)) !== null && _b !== void 0 ? _b : language_1.PddlLanguage.PDDL, -1, fileContent, new DocumentPositionResolver_1.SimpleDocumentPositionResolver(fileContent));
            });
        }
    }
    invalidateDiagnostics(fileInfo, fileStatus) {
        fileInfo.setStatus(fileStatus !== null && fileStatus !== void 0 ? fileStatus : language_1.FileStatus.Parsed);
        this.emitIfNew(PddlWorkspace.UPDATED, fileInfo);
    }
    markProblemsAsDirty(domainInfo) {
        this.getProblemFiles(domainInfo).forEach(problemInfo => {
            this.invalidateDiagnostics(problemInfo);
            this.markPlansAsDirty(problemInfo);
        });
    }
    markPlansAsDirty(problemInfo) {
        this.getPlanFiles(problemInfo).forEach(planInfo => this.invalidateDiagnostics(planInfo));
        this.getHappeningsFiles(problemInfo).forEach(happeningsInfo => this.invalidateDiagnostics(happeningsInfo));
    }
    scheduleParsing() {
        this.cancelScheduledParsing();
        this.parsingTimeout = setTimeout(() => this.parseAllDirty(), this.defaultTimerDelayInSeconds * 1000);
    }
    cancelScheduledParsing() {
        if (this.parsingTimeout) {
            clearTimeout(this.parsingTimeout);
        } // todo: use .refresh()
    }
    parseAllDirty() {
        // find all dirty files
        const dirtyFiles = this.getAllFilesIf(fileInfo => fileInfo.getStatus() === language_1.FileStatus.Dirty);
        dirtyFiles.forEach(file => this.reParseFile(file));
    }
    async reParseFile(fileInfo) {
        const folderPath = PddlWorkspace.getFolderPath(fileInfo.fileUri);
        const folder = this.upsertFolder(folderPath);
        folder.remove(fileInfo);
        fileInfo = await this.parseFile(fileInfo.fileUri, fileInfo.getLanguage(), fileInfo.getVersion(), fileInfo.getText(), fileInfo.getDocumentPositionResolver());
        folder.add(fileInfo);
        this.emitIfNew(PddlWorkspace.UPDATED, fileInfo);
        return fileInfo;
    }
    /**
     * Emit event, unless it is stale
     * @param fileInfo file concerned
     */
    emitIfNew(symbol, fileInfo) {
        if (symbol === PddlWorkspace.UPDATED) {
            const lastVersion = this.lastVersionUpdateEmitted.get(fileInfo.fileUri.toString());
            if (lastVersion !== undefined && fileInfo.getVersion() <= lastVersion) {
                return;
            }
            else {
                this.lastVersionUpdateEmitted.set(fileInfo.fileUri.toString(), fileInfo.getVersion());
            }
        }
        this.emit(symbol, fileInfo);
    }
    async parseFile(fileUri, language, fileVersion, fileText, positionResolver) {
        if (language === language_1.PddlLanguage.PDDL) {
            const parser = new PddlSyntaxTreeBuilder_1.PddlSyntaxTreeBuilder(fileText);
            const syntaxTree = parser.getTree();
            for (const pddlParser of this.pddlFileParsers) {
                const pddlFile = await pddlParser.tryParse(fileUri, fileVersion, fileText, syntaxTree, positionResolver);
                if (pddlFile) {
                    this.appendOffendingTokenToParsingProblems(pddlFile, parser, positionResolver);
                    return pddlFile;
                }
            }
            const unknownFile = new FileInfo_1.UnknownFileInfo(fileUri, fileVersion, positionResolver);
            unknownFile.setText(fileText);
            return unknownFile;
        }
        else if (language === language_1.PddlLanguage.PLAN) {
            return new PddlPlanParser_1.PddlPlanParser().parseText(fileText, this.epsilon, fileUri, fileVersion, positionResolver);
        }
        else if (language === language_1.PddlLanguage.HAPPENINGS) {
            return new HappeningsParser_1.HappeningsParser().parseHappenings(fileUri, fileVersion, fileText, this.epsilon, positionResolver);
        }
        else {
            throw Error("Unknown language: " + language);
        }
    }
    appendOffendingTokenToParsingProblems(fileInfo, parser, positionResolver) {
        fileInfo.addProblems(parser.getOffendingTokens().map(token => {
            const offendingPosition = positionResolver.resolveToPosition(token.getStart());
            return new FileInfo_1.ParsingProblem(`Unexpected token: ${token.toString()}`, "error", DocumentPositionResolver_1.PddlRange.createSingleCharacterRange({ line: offendingPosition.line, character: offendingPosition.character }));
        }));
    }
    async upsertAndParseFolder(folderUri) {
        const folderPath = folderUri.fsPath;
        const folder = this.folders.get(folderPath);
        if (folder) {
            return folder;
        }
        const newFolder = new Folder(folderPath);
        this.folders.set(folderPath, newFolder);
        this.loadFolder(newFolder);
        return newFolder;
    }
    getFolder(folderUri) {
        return this.folders.get(folderUri.fsPath);
    }
    upsertFolder(folderPath) {
        let folder;
        if (!this.folders.has(folderPath)) {
            folder = new Folder(folderPath);
            this.folders.set(folderPath, folder);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            folder = this.folders.get(folderPath);
        }
        return folder;
    }
    removeFile(documentUri, options) {
        if (this.hasExplicitAssociations(documentUri)) {
            if (!options.removeAllReferences) {
                return false;
            }
        }
        // todo: remove the explicit associations
        const folderPath = PddlWorkspace.getFolderPath(documentUri);
        if (this.folders.has(folderPath)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const folder = this.folders.get(folderPath);
            if (folder.hasFile(documentUri)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const documentInfo = folder.get(documentUri);
                this.emitIfNew(PddlWorkspace.REMOVING, documentInfo);
                return folder.remove(documentInfo);
            }
        }
        return false;
    }
    hasExplicitAssociations(documentUri) {
        return this.problemToDomainMap.has(documentUri.toString()) || [...this.problemToDomainMap.values()].includes(documentUri.toString())
            || this.planToProblemMap.has(documentUri.toString()) || [...this.planToProblemMap.values()].includes(documentUri.toString());
    }
    getFileInfo(fileUri) {
        const folderPath = PddlWorkspace.getFolderPath(fileUri);
        if (this.folders.has(folderPath)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const folder = this.folders.get(folderPath);
            const fileInfo = folder.get(fileUri);
            return fileInfo; // or null if the file did not exist in the folder
        }
        // folder does not exist
        return undefined;
    }
    getProblemFiles(domainInfo) {
        var _a;
        const folder = this.folders.get(PddlWorkspace.getFolderPath(domainInfo.fileUri));
        // find problem files in the same folder that match the domain name
        const problemFiles = (_a = folder === null || folder === void 0 ? void 0 : folder.getProblemFilesFor(domainInfo)) !== null && _a !== void 0 ? _a : [];
        return problemFiles;
    }
    getPlanFiles(problemInfo) {
        const folder = this.folders.get(PddlWorkspace.getFolderPath(problemInfo.fileUri));
        if (folder === undefined) {
            return [];
        }
        // find plan files in the same folder that match the domain and problem names
        return Array.from(folder.files.values())
            .filter(f => f.isPlan())
            .map(f => f)
            .filter(p => lowerCaseEquals(p.problemName, problemInfo.name)
            && lowerCaseEquals(p.domainName, problemInfo.domainName));
    }
    getHappeningsFiles(problemInfo) {
        const folder = this.folders.get(PddlWorkspace.getFolderPath(problemInfo.fileUri));
        if (folder === undefined) {
            return [];
        }
        // find happenings files in the same folder that match the domain and problem names
        return Array.from(folder.files.values())
            .filter(f => f.isHappenings())
            .map(f => f)
            .filter(p => lowerCaseEquals(p.problemName, problemInfo.name)
            && lowerCaseEquals(p.domainName, problemInfo.domainName));
    }
    getAllFilesIf(predicate) {
        const selectedFiles = new Array();
        this.folders.forEach(folder => {
            folder.files.forEach((fileInfo) => {
                if (predicate.apply(this, [fileInfo])) {
                    selectedFiles.push(fileInfo);
                }
            });
        });
        return selectedFiles;
    }
    getAllFiles() {
        const selectedFiles = new Array();
        this.folders.forEach(folder => {
            folder.files.forEach((fileInfo) => {
                selectedFiles.push(fileInfo);
            });
        });
        return selectedFiles;
    }
    /**
     * Finds a corresponding domain file
     * @param fileInfo a PDDL file info
     * @returns corresponding domain file if fileInfo is a problem file,
     * or `fileInfo` itself if the `fileInfo` is a domain file, or `null` otherwise.
     */
    asDomain(fileInfo) {
        if (fileInfo.isDomain()) {
            return fileInfo;
        }
        else if (fileInfo.isProblem()) {
            return this.getDomainFileFor(fileInfo);
        }
        else if (fileInfo.isPlan()) {
            const problemFile1 = this.getProblemFileForPlan(fileInfo);
            return problemFile1 && this.getDomainFileFor(problemFile1);
        }
        else if (fileInfo.isHappenings()) {
            const problemFile2 = this.getProblemFileForHappenings(fileInfo);
            return problemFile2 && this.getDomainFileFor(problemFile2);
        }
        else {
            return undefined;
        }
    }
    associateProblemToDomain(problemInfo, domainInfo) {
        this.problemToDomainMap.set(problemInfo.fileUri.toString(), domainInfo.fileUri.toString());
    }
    /**
     * Finds the matching domain files.
     * @param problemFile problem file info
     * @returns matching domain files (zero, one or many)
     */
    getDomainFilesFor(problemFile) {
        const key = problemFile.fileUri.toString();
        // does an explicit association exist?
        if (this.problemToDomainMap.has(key)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const domainFileUri = vscode_uri_1.URI.parse(this.problemToDomainMap.get(key));
            const associatedDomain = this.getFileInfo(domainFileUri);
            return associatedDomain ? [associatedDomain] : [];
        }
        else {
            const folder = this.folders.get(PddlWorkspace.getFolderPath(problemFile.fileUri));
            if (!folder) {
                return [];
            }
            // find domain files in the same folder that match the problem's domain name
            const domainFiles = folder.getDomainFilesFor(problemFile);
            return domainFiles;
        }
    }
    /**
     * Finds the matching domain file in the same folder.
     * @param problemFile problem file info
     * @returns matching domain file, if exactly one exists in the same folder. `null` otherwise
     */
    getDomainFileFor(problemFile) {
        // find domain files in the same folder that match the problem's domain name
        const domainFiles = this.getDomainFilesFor(problemFile);
        return domainFiles.length === 1 ? domainFiles[0] : undefined;
    }
    associatePlanToProblem(planUri, problemFileInfo) {
        this.planToProblemMap.set(planUri.toString(), problemFileInfo.fileUri.toString());
    }
    getProblemFileForPlan(planInfo) {
        const key = planInfo.fileUri.toString();
        // does an explicit association exist?
        if (this.planToProblemMap.has(key)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const problemFileUri = vscode_uri_1.URI.parse(this.planToProblemMap.get(key));
            return this.getFileInfo(problemFileUri);
        }
        else {
            const folder = this.getFolderOf(planInfo);
            if (!folder) {
                return undefined;
            }
            return folder.getProblemFileWithName(planInfo.problemName);
        }
    }
    getProblemFileForHappenings(happeningsInfo) {
        var _a;
        return (_a = this.getFolderOf(happeningsInfo)) === null || _a === void 0 ? void 0 : _a.getProblemFileWithName(happeningsInfo.problemName);
    }
    getFolderOf(fileInfo) {
        return this.folders.get(PddlWorkspace.getFolderPath(fileInfo.fileUri));
    }
}
exports.PddlWorkspace = PddlWorkspace;
PddlWorkspace.INSERTED = Symbol("INSERTED");
PddlWorkspace.UPDATED = Symbol("UPDATED");
PddlWorkspace.REMOVING = Symbol("REMOVING");
PddlWorkspace.MAX_FILES_PER_FOLDER = 30;

},{"./DocumentPositionResolver":15,"./FileInfo":17,"./language":33,"./parser/HappeningsParser":37,"./parser/PddlPlanParser":47,"./parser/PddlSyntaxTreeBuilder":53,"./parser/index":59,"./planner/PlannerRegistrar":65,"events":230,"path":235,"vscode-uri":80}],24:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],25:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plan = void 0;
const ProblemInfo_1 = require("./ProblemInfo");
const PlanStep_1 = require("./PlanStep");
const DomainInfo_1 = require("./DomainInfo");
class Plan {
    constructor(steps, domain, problem, now, helpfulActions) {
        this.steps = steps;
        this.domain = domain;
        this.problem = problem;
        this.now = now;
        this.helpfulActions = helpfulActions;
        this._makespan = steps.length ? Math.max(...steps.map(step => step.getEndTime())) : 0;
    }
    /**
     * Copy constructor for re-constructing the plan from a serialized form.
     * @param plan serialized plan
     */
    static clone(plan) {
        var _a, _b;
        const clonedDomain = plan.domain && DomainInfo_1.DomainInfo.clone(plan.domain);
        const clonedProblem = plan.problem && ProblemInfo_1.ProblemInfo.clone(plan.problem, (_b = (_a = plan.domain) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'unknown-domain');
        const clonedPlan = new Plan(plan.steps.map(s => PlanStep_1.PlanStep.clone(s)), clonedDomain, clonedProblem, plan.now, plan.helpfulActions);
        plan._metric !== undefined && (clonedPlan.metric = plan._metric);
        clonedPlan.statesEvaluated = plan.statesEvaluated;
        return clonedPlan;
    }
    /** @deprecated use `metric` */
    get cost() {
        return this.metric;
    }
    /** @deprecated use `metric` */
    set cost(metric) {
        this.metric = metric;
    }
    get metric() {
        var _a;
        // if cost was not output by the planning engine, use the plan makespan
        return (_a = this._metric) !== null && _a !== void 0 ? _a : this._makespan;
    }
    set metric(metric) {
        this._metric = metric;
    }
    get makespan() {
        return this._makespan;
    }
    isMetricDefined() {
        return this._metric !== undefined;
    }
    /** @deprecated use isMetricDefined */
    isCostDefined() {
        return this.isMetricDefined();
    }
    /**
     * Returns true if any helpful actions were specified.
     */
    hasHelpfulActions() {
        var _a, _b;
        return ((_b = (_a = this.helpfulActions) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0;
    }
    getText() {
        return this.steps.map(step => step.toPddl()).join("\n");
    }
}
exports.Plan = Plan;

},{"./DomainInfo":16,"./PlanStep":27,"./ProblemInfo":29}],26:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlanInfo = void 0;
const FileInfo_1 = require("./FileInfo");
const PddlSyntaxTree_1 = require("./parser/PddlSyntaxTree");
const language_1 = require("./language");
const Plan_1 = require("./Plan");
/**
 * Plan file.
 */
class PlanInfo extends FileInfo_1.FileInfo {
    constructor(fileUri, version, problemName, domainName, text, positionResolver) {
        // note we use the `problemName` as the plan name as the plan does not have any declared name
        super(fileUri, version, problemName, PddlSyntaxTree_1.PddlSyntaxTree.EMPTY, positionResolver);
        this.problemName = problemName;
        this.domainName = domainName;
        this.steps = [];
        this.setText(text);
    }
    getLanguage() {
        return language_1.PddlLanguage.PLAN;
    }
    setSteps(steps) {
        this.steps = steps;
    }
    getSteps() {
        return this.steps;
    }
    get metric() {
        return this._metric;
    }
    set metric(metric) {
        this._metric = metric;
    }
    get statesEvaluated() {
        return this._statesEvaluated;
    }
    set statesEvaluated(statesEvaluated) {
        this._statesEvaluated = statesEvaluated;
    }
    isPlan() {
        return true;
    }
    static getHappenings(planSteps) {
        // todo: when flatMap is available, rewrite this...
        const happenings = [];
        planSteps
            .forEach((planStep, idx, allSteps) => happenings.push(...planStep.getHappenings(allSteps.slice(0, idx - 1))));
        const compare = function (happening1, happening2) {
            if (happening1.getTime() !== happening2.getTime()) {
                return happening1.getTime() - happening2.getTime();
            }
            else {
                return happening1.getFullActionName().localeCompare(happening2.getFullActionName());
            }
        };
        return happenings.sort(compare);
    }
    getHappenings() {
        return PlanInfo.getHappenings(this.getSteps());
    }
    getPlan(domain, problem) {
        return new Plan_1.Plan(this.getSteps(), domain, problem);
    }
}
exports.PlanInfo = PlanInfo;

},{"./FileInfo":17,"./Plan":25,"./language":33,"./parser/PddlSyntaxTree":52}],27:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlanStepCommitment = exports.PlanStep = void 0;
const HappeningsInfo_1 = require("./HappeningsInfo");
class PlanStep {
    constructor(time, fullActionName, isDurative, duration, lineIndex, commitment, iterations) {
        this.time = time;
        this.fullActionName = fullActionName;
        this.isDurative = isDurative;
        this.duration = duration;
        this.lineIndex = lineIndex;
        this.commitment = commitment;
        this.iterations = iterations;
        const nameFragments = fullActionName.split(' ');
        this.actionName = nameFragments[0];
        this.objects = nameFragments.slice(1);
    }
    static clone(planStep) {
        return new PlanStep(planStep.time, planStep.fullActionName, planStep.isDurative, planStep.duration, planStep.lineIndex, planStep.commitment, planStep.iterations);
    }
    getActionName() {
        return this.actionName;
    }
    getFullActionName() {
        return this.fullActionName;
    }
    getObjects() {
        return this.objects;
    }
    getStartTime() {
        return this.time;
    }
    getEndTime() {
        var _a;
        return this.isDurative ? this.time + ((_a = this.duration) !== null && _a !== void 0 ? _a : Number.NaN) : this.time;
    }
    /**
     * @returns end time that makes this plan step effectively durative
     */
    getEffectiveEndTime() {
        var _a;
        return this.time + ((_a = this.duration) !== null && _a !== void 0 ? _a : Number.NaN);
    }
    getDuration() {
        return this.duration;
    }
    getIterations() {
        var _a;
        return (_a = this.iterations) !== null && _a !== void 0 ? _a : 1;
    }
    equals(other, epsilon) {
        if (this.isDurative) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (!other.isDurative || !PlanStep.equalsWithin(this.duration, other.duration, epsilon)) {
                return false;
            }
        }
        return PlanStep.equalsWithin(this.time, other.time, epsilon)
            && this.fullActionName.toLowerCase() === other.fullActionName.toLowerCase();
    }
    static equalsWithin(a, b, epsilon) {
        return Math.abs(a - b) <= 1.1 * epsilon;
    }
    toPddl() {
        var _a;
        let output = "";
        if (this.time !== null && this.time !== undefined) {
            output += `${this.time.toFixed(5)}: `;
        }
        output += `(${this.fullActionName})`;
        if (this.isDurative) {
            output += ` [${(_a = this.duration) === null || _a === void 0 ? void 0 : _a.toFixed(5)}]`;
        }
        return output;
    }
    getHappenings(priorSteps) {
        const count = priorSteps.filter(step => step.fullActionName === this.fullActionName).length;
        const line = priorSteps.length;
        if (this.isDurative) {
            const start = new HappeningsInfo_1.Happening(this.getStartTime(), HappeningsInfo_1.HappeningType.START, this.fullActionName, count, line);
            const end = new HappeningsInfo_1.Happening(this.getEndTime(), HappeningsInfo_1.HappeningType.END, this.fullActionName, count, line);
            return [start, end];
        }
        else {
            const instant = new HappeningsInfo_1.Happening(this.getStartTime(), HappeningsInfo_1.HappeningType.INSTANTANEOUS, this.fullActionName, count, line);
            return [instant];
        }
    }
}
exports.PlanStep = PlanStep;
var PlanStepCommitment;
(function (PlanStepCommitment) {
    PlanStepCommitment["Committed"] = "COMMITTED";
    PlanStepCommitment["EndsInRelaxedPlan"] = "ENDS_IN_RELAXED_PLAN";
    PlanStepCommitment["StartsInRelaxedPlan"] = "STARTS_IN_RELAXED_PLAN";
})(PlanStepCommitment = exports.PlanStepCommitment || (exports.PlanStepCommitment = {}));

},{"./HappeningsInfo":19}],28:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NunjucksPreProcessor = exports.Jinja2PreProcessor = exports.PythonPreProcessor = exports.CommandPreProcessor = exports.PreProcessor = exports.PreProcessingError = void 0;
const process = __importStar(require("child_process"));
const path = __importStar(require("path"));
const nunjucks = __importStar(require("nunjucks"));
const fs = __importStar(require("fs"));
class PreProcessingError {
    constructor(message, line, column) {
        this.message = message;
        this.line = line;
        this.column = column;
    }
    get name() {
        return 'pre-processing_error';
    }
}
exports.PreProcessingError = PreProcessingError;
class PreProcessor {
    constructor(metaDataLine, metaDataLineOffset) {
        this.metaDataLine = metaDataLine;
        this.metaDataLineOffset = metaDataLineOffset;
    }
    removeMetaDataLine(text) {
        const pattern = /^;;\s*!pre-parsing:/;
        return text.split('\n').map(line => pattern.test(line) ? "; Generated from a PDDL template and a data file" : line).join('\n');
    }
}
exports.PreProcessor = PreProcessor;
/**
 * Shell command based pre-processor.
 */
class CommandPreProcessor extends PreProcessor {
    constructor(command, args, metaDataLine, metaDataLineOffset) {
        super(metaDataLine, metaDataLineOffset);
        this.command = command;
        this.args = args;
    }
    toString() {
        return `${this.command} ` + this.args.join(' ');
    }
    static fromJson(json) {
        return new CommandPreProcessor(json["command"], json["args"], '');
    }
    getInputFiles() {
        return [];
    }
    getLabel() {
        return this.command;
    }
    handleError(error) {
        throw new PreProcessingError(error.message, 0, 0);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    handleErrorAsync(error, reject) {
        reject(new PreProcessingError(error.message, 0, 0));
    }
    async transform(input, workingDirectory, outputWindow) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const that = this;
        return new Promise(function (resolve, reject) {
            var _a, _b;
            const childProcess = process.execFile(that.command, that.args, {
                cwd: workingDirectory
            }, (error, stdout, stderr) => {
                if (stderr) {
                    outputWindow.appendLine(stderr);
                }
                if (error) {
                    outputWindow.appendLine('Failed to transform the problem file.');
                    outputWindow.appendLine(error.message);
                    that.handleErrorAsync(error, reject);
                    resolve(input);
                }
                else {
                    resolve(that.removeMetaDataLine(stdout));
                    return;
                }
            });
            (_a = childProcess.stdin) === null || _a === void 0 ? void 0 : _a.write(input);
            (_b = childProcess.stdin) === null || _b === void 0 ? void 0 : _b.end();
        });
    }
}
exports.CommandPreProcessor = CommandPreProcessor;
/**
 * Python-based pre-processor
 */
class PythonPreProcessor extends CommandPreProcessor {
    constructor(pythonPath, script, args, metaDataLine, metaDataLineOffset) {
        super(pythonPath, [script].concat(args), metaDataLine, metaDataLineOffset);
    }
    getInputFiles() {
        return this.args;
    }
    getLabel() {
        return this.args.join(' ');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static fromJson(_json) {
        throw new Error("For Jinja2 pre-processor, use the constructor instead");
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    handleErrorAsync(error, reject) {
        const errorLines = error.message.split('\n');
        const templateSyntaxError = errorLines.find(row => row.startsWith(PythonPreProcessor.JINJA2_TEMPLATE_SYNTAX_ERROR_PREFIX));
        if (templateSyntaxError) {
            reject(new PreProcessingError(templateSyntaxError.substring(PythonPreProcessor.JINJA2_TEMPLATE_SYNTAX_ERROR_PREFIX.length), 0, 0));
            return;
        }
        const pythonJsonError = errorLines.find(row => row.startsWith(PythonPreProcessor.PYTHON_JSON_DECODER));
        if (pythonJsonError) {
            reject(new PreProcessingError('JSON Error: ' + pythonJsonError.substring(PythonPreProcessor.PYTHON_JSON_DECODER.length), 0, 0));
            return;
        }
        super.handleErrorAsync(error, reject);
    }
}
exports.PythonPreProcessor = PythonPreProcessor;
PythonPreProcessor.JINJA2_TEMPLATE_SYNTAX_ERROR_PREFIX = 'jinja2.exceptions.TemplateSyntaxError: ';
PythonPreProcessor.PYTHON_JSON_DECODER = 'json.decoder.JSONDecodeError: ';
/**
 * Jinja2 pre-processor
 */
class Jinja2PreProcessor extends PythonPreProcessor {
    constructor(pythonPath, extensionRoot, dataFileName, metaDataLine, metaDataLineOffset) {
        super(pythonPath, path.join(extensionRoot, "scripts", "transform_jinja2.py"), [dataFileName], metaDataLine, metaDataLineOffset);
        this.dataFileName = dataFileName;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static fromJson(_json) {
        throw new Error("For Jinja2 pre-processor, use the constructor instead");
    }
    getInputFiles() {
        return [this.dataFileName];
    }
    getLabel() {
        return this.dataFileName;
    }
}
exports.Jinja2PreProcessor = Jinja2PreProcessor;
/**
 * Nunjucks based pre-processor
 */
class NunjucksPreProcessor extends PreProcessor {
    constructor(dataFileName, metaDataLine, metaDataLineOffset, preserveWhitespace) {
        super(metaDataLine, metaDataLineOffset);
        this.dataFileName = dataFileName;
        this.nunjucksEnv = nunjucks.configure({ trimBlocks: false, lstripBlocks: !preserveWhitespace, throwOnUndefined: true });
        this.nunjucksEnv.addFilter('map', function (array, attribute) {
            return array.map((item) => item[attribute]);
        });
        this.nunjucksEnv.addFilter('setAttribute', function (dictionary, key, value) {
            dictionary[key] = value;
            return dictionary;
        });
    }
    getInputFiles() {
        return [this.dataFileName];
    }
    getLabel() {
        return this.dataFileName;
    }
    toString() {
        return `Nunjucks ${this.dataFileName}`;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async transform(input, workingDirectory, _outputWindow) {
        const dataPath = path.join(workingDirectory, this.dataFileName);
        const dataText = await fs.promises.readFile(dataPath);
        let data;
        try {
            data = JSON.parse(dataText.toLocaleString());
        }
        catch (error) {
            return `Failed to read from '${dataPath}'.`;
        }
        try {
            const translated = this.nunjucksEnv.renderString(input, { data: data });
            return this.removeMetaDataLine(translated);
        }
        catch (error) {
            const error1 = error;
            const pattern = /\((.+)\)\s+\[Line\s+(\d+),\s+Column\s+(\d+)\]/;
            const match = pattern.exec(error1.message);
            if (match) {
                throw new PreProcessingError(match[1], parseInt(match[2]) - 1, parseInt(match[3]) - 1);
            }
            else {
                throw new PreProcessingError(error1.message, 0, 0);
            }
        }
    }
}
exports.NunjucksPreProcessor = NunjucksPreProcessor;

},{"child_process":227,"fs":227,"nunjucks":13,"path":235}],29:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimedVariableValue = exports.ProblemInfo = exports.Metric = exports.MetricDirection = exports.SupplyDemand = exports.UnsupportedVariableValue = exports.VariableValue = void 0;
const FileInfo_1 = require("./FileInfo");
const PddlSyntaxTree_1 = require("./parser/PddlSyntaxTree");
const DocumentPositionResolver_1 = require("./DocumentPositionResolver");
const DomainInfo_1 = require("./DomainInfo");
const language_1 = require("./language");
/**
 * Variable value initialization in the problem file.
 */
class VariableValue {
    constructor(variableName, value) {
        this.variableName = variableName;
        this.value = value;
    }
    getVariableName() {
        return this.variableName;
    }
    getValue() {
        return this.value;
    }
    negate() {
        return new VariableValue(this.variableName, !this.value);
    }
    get isSupported() {
        return true;
    }
}
exports.VariableValue = VariableValue;
class UnsupportedVariableValue extends VariableValue {
    constructor(text) {
        super(text, false);
    }
    negate() {
        return this;
    }
    get isSupported() {
        return false;
    }
}
exports.UnsupportedVariableValue = UnsupportedVariableValue;
/**
 * Supply-demand contract.
 */
class SupplyDemand {
    constructor(name) {
        this.name = name;
    }
    getName() {
        return this.name;
    }
}
exports.SupplyDemand = SupplyDemand;
var MetricDirection;
(function (MetricDirection) {
    MetricDirection[MetricDirection["MINIMIZE"] = 0] = "MINIMIZE";
    MetricDirection[MetricDirection["MAXIMIZE"] = 1] = "MAXIMIZE";
})(MetricDirection = exports.MetricDirection || (exports.MetricDirection = {}));
class Metric {
    constructor(direction, expression, location, documentation) {
        this.direction = direction;
        this.expression = expression;
        this.location = location;
        this.documentation = documentation;
    }
    getDirection() {
        return this.direction;
    }
    getExpression() {
        return this.expression;
    }
    getLocation() {
        return this.location;
    }
    getDocumentation() {
        return this.documentation;
    }
}
exports.Metric = Metric;
/**
 * Problem file.
 */
class ProblemInfo extends FileInfo_1.FileInfo {
    constructor(fileUri, version, problemName, domainName, syntaxTree, positionResolver) {
        super(fileUri, version, problemName, syntaxTree, positionResolver);
        this.domainName = domainName;
        this.syntaxTree = syntaxTree;
        this.objects = new DomainInfo_1.TypeObjectMap();
        this.inits = [];
        this.supplyDemands = [];
        this.constraints = [];
        this.metrics = [];
    }
    /**
     * Copy constructor for re-constructing the problem from a serialized form.
     * @param problem de-serialized problem
     * @param domainName domain name
     */
    static clone(problem, domainName) {
        const clonedProblem = new ProblemInfo(problem.fileUri, Number.NaN, problem.name, domainName !== null && domainName !== void 0 ? domainName : problem.domainName, PddlSyntaxTree_1.PddlSyntaxTree.EMPTY, new DocumentPositionResolver_1.SimpleDocumentPositionResolver(''));
        clonedProblem.setConstraints(problem.constraints);
        clonedProblem.setInits(problem.inits.map(i => TimedVariableValue.copy(i)));
        clonedProblem.setMetrics(problem.metrics);
        clonedProblem.setObjects(DomainInfo_1.TypeObjectMap.clone(problem.objects));
        clonedProblem.setSupplyDemands(problem.supplyDemands);
        return clonedProblem;
    }
    /**
     * Copy constructor for deriving problem file with new initial state (preserving TILs after the `newStateTime`).
     * @param origProblem original (de-serialized) problem
     * @param newState new initial state
     * @param newStateTime time at which the new state is effective
     */
    static cloneWithInitStateAt(origProblem, newState, newStateTime = 0) {
        const origProblemText = origProblem.getText();
        const initNode = origProblem.syntaxTree.getDefineNodeOrThrow().getFirstOpenBracket(':init');
        if (origProblem.getSupplyDemands().length) {
            throw new Error("Problems with supply-demand are not supported.");
        }
        // some TILs from the original problem are still in the future
        const futureTils = origProblem.getInits()
            // filter original TILs occurring after `newStateTime`
            .filter(til => til.getTime() > newStateTime);
        const newStateWithTils = newState.concat(futureTils)
            .map(til => TimedVariableValue.copy(til));
        newStateWithTils.forEach(til => til.setTime(til.getTime() - newStateTime));
        const newInit = newStateWithTils.map(tiv => tiv.toPddlString()).join('\n\t');
        const newProblemText = origProblemText.substring(0, initNode.getStart())
            + '\n(:init\n' + newInit + '\n)'
            + origProblemText.substring(initNode.getEnd());
        return newProblemText;
    }
    setPreParsingPreProcessor(preProcessor) {
        this.preParsingPreProcessor = preProcessor;
    }
    getPreParsingPreProcessor() {
        return this.preParsingPreProcessor;
    }
    getLanguage() {
        return language_1.PddlLanguage.PDDL;
    }
    setObjects(objects) {
        this.objects = objects;
    }
    getObjects(type) {
        var _a, _b;
        return (_b = ((_a = this.objects.getTypeCaseInsensitive(type)) === null || _a === void 0 ? void 0 : _a.getObjects())) !== null && _b !== void 0 ? _b : [];
    }
    getObjectsTypeMap() {
        return this.objects;
    }
    /**
     * Sets predicate/function initial values.
     * @param inits initial values
     */
    setInits(inits) {
        this.inits = inits;
    }
    /**
     * Returns variable initial values and time-initial literals/fluents.
     */
    getInits() {
        return this.inits;
    }
    setSupplyDemands(supplyDemands) {
        this.supplyDemands = supplyDemands;
    }
    getSupplyDemands() {
        return this.supplyDemands;
    }
    setConstraints(constraints) {
        this.constraints = constraints;
    }
    getConstraints() {
        return this.constraints;
    }
    setMetrics(metrics) {
        this.metrics = metrics;
    }
    getMetrics() {
        return this.metrics;
    }
    isProblem() {
        return true;
    }
}
exports.ProblemInfo = ProblemInfo;
/**
 * Variable value effective from certain time, e.g. initialization of the variable in the problem file.
 */
class TimedVariableValue {
    constructor(time, variableName, value, _isSupported = true) {
        this.time = time;
        this.variableName = variableName;
        this.value = value;
        this._isSupported = _isSupported;
    }
    static from(time, value) {
        return new TimedVariableValue(time, value.getVariableName(), value.getValue(), value.isSupported);
    }
    /**
     * Makes a deep copy of the supplied value and returns a new instance
     * @param value value to copy from
     */
    static copy(value) {
        return new TimedVariableValue(value.time, value.variableName, value.value, value.isSupported);
    }
    get isSupported() {
        return this._isSupported;
    }
    getTime() {
        return this.time;
    }
    setTime(time) {
        this.time = time;
    }
    getVariableName() {
        return this.variableName;
    }
    getLiftedVariableName() {
        return this.variableName.split(' ')[0];
    }
    getValue() {
        return this.value;
    }
    /**
     * Updates this value.
     * @param newValue new value
     */
    update(time, newValue) {
        this.time = time;
        this.value = newValue.getValue();
    }
    /**
     * Determines whether the variable name and value are the same, ignoring the timestamp.
     * @param other other timed variable value
     */
    sameValue(other) {
        return this.getVariableName() === other.getVariableName()
            && this.getValue() === other.getValue();
    }
    getVariableValue() {
        return new VariableValue(this.variableName, this.value);
    }
    toString() {
        return `${this.variableName}=${this.value} @ ${this.time}`;
    }
    toPddlString() {
        const valuePddl = typeof this.value == "boolean" ?
            this.value === true ? `(${this.variableName})` : `(not (${this.variableName}))` :
            `(= (${this.variableName}) ${this.value})`;
        return this.time <= 0 ?
            valuePddl
            : `(at ${this.time} ${valuePddl})`;
    }
}
exports.TimedVariableValue = TimedVariableValue;

},{"./DocumentPositionResolver":15,"./DomainInfo":16,"./FileInfo":17,"./language":33,"./parser/PddlSyntaxTree":52}],30:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProblemParserPreProcessor = void 0;
const PreProcessors_1 = require("./PreProcessors");
class ConsoleOutputAdaptor {
    appendLine(text) {
        console.info(text);
    }
    show() {
        // do nothing
    }
}
class ProblemParserPreProcessor {
    constructor(context) {
        this.context = context;
        this.problemCompletePattern = /^;;\s*!pre-parsing:\s*{\s*type:\s*"(command|nunjucks|jinja2|python)"\s*,\s*(command:\s*"([\w:\-/\\\. ]+)"\s*(,\s*args:\s*\[([^\]]*)\])?|data:\s*"([\w:\-/\\\. ]+)")\s*}/gm;
    }
    async process(preProcessor, templatedProblem, workingDirectory) {
        if (preProcessor) {
            const transformed = await preProcessor.transform(templatedProblem, workingDirectory, new ConsoleOutputAdaptor());
            console.log("Pre-processed successfully using " + preProcessor.toString());
            return transformed || templatedProblem;
        }
        else {
            return templatedProblem;
        }
    }
    createPreProcessor(templatedProblem) {
        var _a, _b, _c;
        let preProcessor;
        this.problemCompletePattern.lastIndex = 0;
        const match = this.problemCompletePattern.exec(templatedProblem);
        if (match && match[1]) {
            switch (match[1]) {
                case "command":
                    const args = this.parseArgs(match[5]);
                    preProcessor = new PreProcessors_1.CommandPreProcessor(match[3], args, match[0], match.index);
                    break;
                case "python":
                    try {
                        const args1 = this.parseArgs(match[5]);
                        preProcessor = new PreProcessors_1.PythonPreProcessor(this.context.pythonPath(), match[3], args1, match[0], match.index);
                    }
                    catch (err) {
                        console.log(err);
                        const error = err;
                        throw new PreProcessors_1.PreProcessingError((_a = error.message) !== null && _a !== void 0 ? _a : err, 0, 0);
                    }
                    break;
                case "nunjucks":
                    try {
                        preProcessor = new PreProcessors_1.NunjucksPreProcessor(match[6], match[0], match.index, true);
                    }
                    catch (err) {
                        console.log(err);
                        const error = err;
                        throw new PreProcessors_1.PreProcessingError((_b = error.message) !== null && _b !== void 0 ? _b : err, 0, 0);
                    }
                    break;
                case "jinja2":
                    if (!this.context) {
                        break;
                    }
                    try {
                        preProcessor = new PreProcessors_1.Jinja2PreProcessor(this.context.pythonPath(), this.context.extensionPath, match[6], match[0], match.index);
                    }
                    catch (err) {
                        console.log(err);
                        const error = err;
                        throw new PreProcessors_1.PreProcessingError((_c = error.message) !== null && _c !== void 0 ? _c : err, 0, 0);
                    }
                    break;
                default:
                    console.log("Not supported: " + match[1]);
            }
        }
        return preProcessor;
    }
    parseArgs(argsText) {
        return argsText ? argsText.split(',').map(arg => arg.trim().slice(1, -1)) : [];
    }
}
exports.ProblemParserPreProcessor = ProblemParserPreProcessor;

},{"./PreProcessors":28}],31:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2019. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StrictlyAfterConstraint = exports.AfterConstraint = exports.NamedConditionConstraint = exports.ConditionalConstraint = exports.Condition = exports.Constraint = void 0;
class Constraint {
    constructor(node) {
        this.node = node;
    }
}
exports.Constraint = Constraint;
class Condition {
    constructor(node) {
        this.node = node;
    }
    getText() {
        return this.node.getNonCommentText();
    }
}
exports.Condition = Condition;
class ConditionalConstraint extends Constraint {
    constructor(condition, node) {
        super(node);
        this.condition = condition;
    }
}
exports.ConditionalConstraint = ConditionalConstraint;
class NamedConditionConstraint extends ConditionalConstraint {
    constructor(definition, node) {
        super(definition.condition, node);
        this.name = definition.name;
    }
    toString() {
        return this.node.getText();
    }
}
exports.NamedConditionConstraint = NamedConditionConstraint;
class AfterConstraint extends Constraint {
    constructor(predecessor, successor, node) {
        super(node);
        this.predecessor = predecessor;
        this.successor = successor;
    }
}
exports.AfterConstraint = AfterConstraint;
class StrictlyAfterConstraint extends AfterConstraint {
    constructor(predecessor, successor, node) {
        super(predecessor, successor, node);
    }
}
exports.StrictlyAfterConstraint = StrictlyAfterConstraint;

},{}],32:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.search = exports.planner = exports.parser = exports.Grounder = void 0;
__exportStar(require("./language"), exports);
__exportStar(require("./PddlWorkspace"), exports);
__exportStar(require("./HappeningsInfo"), exports);
__exportStar(require("./DocumentPositionResolver"), exports);
__exportStar(require("./FileInfo"), exports);
__exportStar(require("./DomainInfo"), exports);
__exportStar(require("./ProblemInfo"), exports);
__exportStar(require("./PlanInfo"), exports);
__exportStar(require("./Plan"), exports);
__exportStar(require("./PlanStep"), exports);
__exportStar(require("./constraints"), exports);
__exportStar(require("./PreProcessors"), exports);
__exportStar(require("./ModelHierarchy"), exports);
__exportStar(require("./PddlExtensionContext"), exports);
__exportStar(require("./PddlWorkspaceExtension"), exports);
__exportStar(require("./NumericExpression"), exports);
__exportStar(require("./typeInheritance"), exports);
var Grounder_1 = require("./Grounder");
Object.defineProperty(exports, "Grounder", { enumerable: true, get: function () { return Grounder_1.Grounder; } });
// parser
const parser = __importStar(require("./parser/index"));
exports.parser = parser;
// planner
const planner = __importStar(require("./planner/index"));
exports.planner = planner;
// search
const search = __importStar(require("./search/index"));
exports.search = search;
// utils
const utils = __importStar(require("./utils/index"));
exports.utils = utils;

},{"./DocumentPositionResolver":15,"./DomainInfo":16,"./FileInfo":17,"./Grounder":18,"./HappeningsInfo":19,"./ModelHierarchy":20,"./NumericExpression":21,"./PddlExtensionContext":22,"./PddlWorkspace":23,"./PddlWorkspaceExtension":24,"./Plan":25,"./PlanInfo":26,"./PlanStep":27,"./PreProcessors":28,"./ProblemInfo":29,"./constraints":31,"./language":33,"./parser/index":59,"./planner/index":67,"./search/index":71,"./typeInheritance":72,"./utils/index":76}],33:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi 2020. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectInstance = exports.Parameter = exports.Term = exports.Variable = exports.FileStatus = exports.toLanguageFromId = exports.PddlLanguage = exports.HAPPENINGS = exports.PLAN = exports.PDDL = void 0;
// Language ID of Domain and Problem files
exports.PDDL = 'pddl';
// Language ID of Plan files
exports.PLAN = 'plan';
// Language ID of Happenings files
exports.HAPPENINGS = 'happenings';
var PddlLanguage;
(function (PddlLanguage) {
    // domain or problem
    PddlLanguage[PddlLanguage["PDDL"] = 0] = "PDDL";
    // plan (output of the planner)
    PddlLanguage[PddlLanguage["PLAN"] = 1] = "PLAN";
    // plan happenings sequence (instantaneous happenings)
    PddlLanguage[PddlLanguage["HAPPENINGS"] = 2] = "HAPPENINGS";
})(PddlLanguage = exports.PddlLanguage || (exports.PddlLanguage = {}));
const languageMap = new Map([
    [exports.PDDL, PddlLanguage.PDDL],
    [exports.PLAN, PddlLanguage.PLAN],
    [exports.HAPPENINGS, PddlLanguage.HAPPENINGS]
]);
function toLanguageFromId(languageId) {
    return languageMap.get(languageId);
}
exports.toLanguageFromId = toLanguageFromId;
/**
 * Status of the file parsing.
 */
var FileStatus;
(function (FileStatus) {
    /** File is parsed when the FileInfo object is created. */
    FileStatus[FileStatus["Parsed"] = 0] = "Parsed";
    /** File was parsed before, but was updated, but not re-parsed yet. */
    FileStatus[FileStatus["Dirty"] = 1] = "Dirty";
    /** Running external language-specific deep parser/validator.  */
    FileStatus[FileStatus["Validating"] = 2] = "Validating";
    /** Finished running external language-specific deep parser/validator.  */
    FileStatus[FileStatus["Validated"] = 3] = "Validated";
})(FileStatus = exports.FileStatus || (exports.FileStatus = {}));
/**
 * State variable.
 */
class Variable {
    constructor(declaredName, parameters = []) {
        this.declaredName = declaredName;
        this.parameters = parameters;
        this.documentation = []; // initialized lazily
        this.unit = ''; // initialized lazily
        this.declaredNameWithoutTypes = declaredName.replace(/\s+-\s+[\w-_]+/gi, '');
        this.name = declaredName.replace(/( .*)$/gi, '');
    }
    static fromGrounded(fullName) {
        const fragments = fullName.split(/\s+/);
        const name = fragments.shift();
        if (!name) {
            throw new Error(`Illegal grounded variable name: ${fullName}`);
        }
        const terms = fragments
            .map(o => new ObjectInstance(o, "object"));
        return new Variable(name, terms);
    }
    bind(objects) {
        const objectNames = objects.map(o => o.name).join(" ");
        if (this.parameters.length !== objects.length) {
            throw new Error(`Invalid objects '${objectNames}' for function '${this.getFullName()}' with ${this.parameters.length} parameters.`);
        }
        let fullName = this.name;
        if (objects) {
            fullName += " " + objectNames;
        }
        return new Variable(fullName, objects);
    }
    getFullName() {
        return this.name + this.parameters.map(par => " " + par.toPddlString()).join('');
    }
    matchesShortNameCaseInsensitive(symbolName) {
        return this.name.toLowerCase() === symbolName.toLowerCase();
    }
    isGrounded() {
        return this.parameters.every(parameter => parameter.isGrounded());
    }
    setDocumentation(documentation) {
        this.documentation = documentation;
        const match = documentation.join('\n').match(/\[([^\]]*)\]/);
        if (match) {
            this.unit = match[1];
        }
    }
    getDocumentation() {
        return this.documentation;
    }
    getUnit() {
        return this.unit;
    }
    setLocation(range) {
        this.location = range;
    }
    getLocation() {
        if (this.location === undefined) {
            throw new Error('Accessing getLocation() before parsing.');
        }
        return this.location;
    }
}
exports.Variable = Variable;
class Term {
    constructor(type) {
        this.type = type;
    }
}
exports.Term = Term;
class Parameter extends Term {
    constructor(name, type) {
        super(type);
        this.name = name;
    }
    toPddlString() {
        return `?${this.name} - ${this.type}`;
    }
    isGrounded() { return false; }
}
exports.Parameter = Parameter;
class ObjectInstance extends Term {
    constructor(name, type) {
        super(type);
        this.name = name;
    }
    toPddlString() {
        return this.name;
    }
    isGrounded() { return true; }
}
exports.ObjectInstance = ObjectInstance;

},{}],34:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2019. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionEffectParser = exports.MakeTrueEffect = exports.AssignEffect = exports.ScaleDownEffect = exports.ScaleUpEffect = exports.DecreaseEffect = exports.IncreaseEffect = exports.MakeFalseEffect = exports.ExpressionEffect = exports.UnrecognizedEffect = exports.VariableEffect = exports.Effect = void 0;
const language_1 = require("../language");
function parseTerm(termText) {
    if (termText.startsWith('?')) {
        return new language_1.Parameter(termText.slice(1), "object");
    }
    else {
        return new language_1.ObjectInstance(termText, "object");
    }
}
function parseVariable(node) {
    const fragments = node.getNestedText().split(/\s+/);
    return new language_1.Variable(fragments[0], fragments.slice(1).map(term => parseTerm(term)));
}
class Effect {
    constructor(node) {
        this.node = node;
    }
    toPddlString() {
        return this.node.getText();
    }
}
exports.Effect = Effect;
class VariableEffect extends Effect {
    constructor(node, variableModified) {
        super(node);
        this.variableModified = variableModified;
    }
    getVariableModified() {
        return this.variableModified;
    }
    modifies(variable) {
        return this.variableModified.name.toLowerCase() === variable.name.toLowerCase();
    }
}
exports.VariableEffect = VariableEffect;
class UnrecognizedEffect extends Effect {
    constructor(node) {
        super(node);
    }
}
exports.UnrecognizedEffect = UnrecognizedEffect;
class ExpressionEffect extends VariableEffect {
    constructor(node, variableModified, expressionNode) {
        super(node, variableModified);
        this.expressionNode = expressionNode;
    }
    static parseBase(node, expectedToken, creator) {
        if (node.getToken().tokenText !== expectedToken) {
            throw new Error(`Invalid '${expectedToken}' effect: ` + node.getText());
        }
        const children = node.getNonWhitespaceNonCommentChildren();
        if (children.length === 2) {
            return creator.apply(this, [node, parseVariable(children[0]), children[1]]);
        }
        else {
            throw new Error(`Invalid '${expectedToken}' effect: ` + node.getText());
        }
    }
}
exports.ExpressionEffect = ExpressionEffect;
class MakeFalseEffect extends VariableEffect {
    constructor(node, variableModified) {
        super(node, variableModified);
    }
    static parse(node) {
        if (node.getToken().tokenText !== this.TOKEN) {
            throw new Error("Invalid 'not' effect: " + node.getText());
        }
        const children = node.getNonWhitespaceNonCommentChildren();
        if (children.length === 1) {
            return new MakeFalseEffect(node, parseVariable(children[0]));
        }
        else {
            throw new Error("Invalid 'not' effect: " + node.getText());
        }
    }
}
exports.MakeFalseEffect = MakeFalseEffect;
MakeFalseEffect.TOKEN = '(not';
class IncreaseEffect extends ExpressionEffect {
    constructor(node, variableModified, expressionNode) {
        super(node, variableModified, expressionNode);
    }
    static parse(node) {
        return this.parseBase(node, this.TOKEN, (node, variable, expressionNode) => new IncreaseEffect(node, variable, expressionNode));
    }
}
exports.IncreaseEffect = IncreaseEffect;
IncreaseEffect.TOKEN = '(increase';
class DecreaseEffect extends ExpressionEffect {
    constructor(node, variableModified, expressionNode) {
        super(node, variableModified, expressionNode);
    }
    static parse(node) {
        return this.parseBase(node, this.TOKEN, (node, variable, expressionNode) => new DecreaseEffect(node, variable, expressionNode));
    }
}
exports.DecreaseEffect = DecreaseEffect;
DecreaseEffect.TOKEN = '(decrease';
class ScaleUpEffect extends ExpressionEffect {
    constructor(node, variableModified, expressionNode) {
        super(node, variableModified, expressionNode);
    }
    static parse(node) {
        return this.parseBase(node, this.TOKEN, (node, variable, expressionNode) => new ScaleUpEffect(node, variable, expressionNode));
    }
}
exports.ScaleUpEffect = ScaleUpEffect;
ScaleUpEffect.TOKEN = '(scale-up';
class ScaleDownEffect extends ExpressionEffect {
    constructor(node, variableModified, expressionNode) {
        super(node, variableModified, expressionNode);
    }
    static parse(node) {
        return this.parseBase(node, this.TOKEN, (node, variable, expressionNode) => new ScaleDownEffect(node, variable, expressionNode));
    }
}
exports.ScaleDownEffect = ScaleDownEffect;
ScaleDownEffect.TOKEN = '(scale-down';
class AssignEffect extends ExpressionEffect {
    constructor(node, variableModified, expressionNode) {
        super(node, variableModified, expressionNode);
    }
    static parse(node) {
        return this.parseBase(node, this.TOKEN, (node, variable, expressionNode) => new AssignEffect(node, variable, expressionNode));
    }
}
exports.AssignEffect = AssignEffect;
AssignEffect.TOKEN = '(assign';
class MakeTrueEffect extends VariableEffect {
    constructor(node, variableModified) {
        super(node, variableModified);
    }
    static parse(node) {
        if (this.TOKENS.includes(node.getToken().tokenText)) {
            return this.parse(node.getSingleNonWhitespaceChild());
        }
        return new MakeTrueEffect(node, parseVariable(node));
    }
}
exports.MakeTrueEffect = MakeTrueEffect;
MakeTrueEffect.TOKENS = ['(and', '(at start', '(at end'];
class ActionEffectParser {
    static parseEffect(node) {
        switch (node.getToken().tokenText) {
            case MakeFalseEffect.TOKEN:
                return MakeFalseEffect.parse(node);
            case AssignEffect.TOKEN:
                return AssignEffect.parse(node);
            case IncreaseEffect.TOKEN:
                return IncreaseEffect.parse(node);
            case DecreaseEffect.TOKEN:
                return DecreaseEffect.parse(node);
            case ScaleUpEffect.TOKEN:
                return ScaleUpEffect.parse(node);
            case ScaleDownEffect.TOKEN:
                return ScaleDownEffect.parse(node);
            default:
                if (node.isLeaveBracket() || MakeTrueEffect.TOKENS.includes(node.getToken().tokenText)) {
                    return MakeTrueEffect.parse(node);
                }
                else {
                    return new UnrecognizedEffect(node);
                }
        }
    }
}
exports.ActionEffectParser = ActionEffectParser;

},{"../language":33}],35:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DerivedVariablesParser = void 0;
const language_1 = require("../language");
const PddlTokenizer_1 = require("./PddlTokenizer");
const DocumentPositionResolver_1 = require("../DocumentPositionResolver");
const VariablesParser_1 = require("./VariablesParser");
/** Parses derived predicates and functions. E.g.:
 * `(:derived (<p> ?x ?y - type) <condition> )`
 */
class DerivedVariablesParser {
    constructor(derivedNode, positionResolver) {
        const children = derivedNode.getNonWhitespaceChildren()
            .filter(c => c.getToken().type !== PddlTokenizer_1.PddlTokenType.Comment);
        if (children.length !== 2) {
            return;
        }
        const fullNameNode = children[0];
        if (fullNameNode.getToken().type !== PddlTokenizer_1.PddlTokenType.OpenBracket) {
            return;
        }
        const fullName = fullNameNode.getNestedText();
        const parameters = (0, VariablesParser_1.parseParameters)(fullName);
        this.conditionNode = children[1];
        this.variable = new language_1.Variable(fullName, parameters);
        const location = new DocumentPositionResolver_1.PddlRange({
            start: positionResolver.resolveToPosition(derivedNode.getStart()),
            end: positionResolver.resolveToPosition(derivedNode.getEnd())
        });
        this.variable.setLocation(location);
        this.variable.setDocumentation(DerivedVariablesParser.getDocumentationAbove(derivedNode));
    }
    static getDocumentationAbove(derivedNode) {
        var _a, _b;
        const siblingNodes = (_b = (_a = derivedNode.getParent()) === null || _a === void 0 ? void 0 : _a.getChildren()) !== null && _b !== void 0 ? _b : [];
        const indexOfThisNode = siblingNodes.indexOf(derivedNode);
        // iterate backwards through the siblings and find first comment line
        // the previous sibling should be a white space
        const whiteSpaceIndex = indexOfThisNode - 1;
        if (whiteSpaceIndex < 0 || siblingNodes[whiteSpaceIndex].getToken().type !== PddlTokenizer_1.PddlTokenType.Whitespace) {
            return [];
        }
        const commentIndex = whiteSpaceIndex - 1;
        if (commentIndex < 0 || siblingNodes[commentIndex].getToken().type !== PddlTokenizer_1.PddlTokenType.Comment) {
            return [];
        }
        else {
            const documentation = siblingNodes[commentIndex].getText().substr(1).trim(); // strip the semicolon
            return [documentation];
        }
    }
    getVariable() {
        return this.variable;
    }
    getConditionNode() {
        return this.conditionNode;
    }
}
exports.DerivedVariablesParser = DerivedVariablesParser;

},{"../DocumentPositionResolver":15,"../language":33,"./PddlTokenizer":54,"./VariablesParser":57}],36:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DurativeActionParser = void 0;
const PddlTokenizer_1 = require("./PddlTokenizer");
const DocumentPositionResolver_1 = require("../DocumentPositionResolver");
const VariablesParser_1 = require("./VariablesParser");
const DomainInfo_1 = require("../DomainInfo");
const DerivedVariableParser_1 = require("./DerivedVariableParser");
/**
 * Parses `(:durative-action ...)` blocks.
 */
class DurativeActionParser {
    constructor(actionNode, positionResolver) {
        /*(:durative-action name
            :parameters (<parameters>)
            :duration (<duration constraint>)
            :condition (and
                (at start (<condition>))
                (over all (<condition>))
                (at end (<condition>))
            )
            :effect (and
                (at start (<effect>))
                (at end (<effect>))
                (increase (<function>) (* #t <expression>))
                (decrease (<function>) (* #t <expression>))
            )
        )*/
        const nameNode = actionNode.getFirstChild(PddlTokenizer_1.PddlTokenType.Other, /[\w-]+/);
        const actionName = nameNode ? nameNode.getText() : undefined;
        const parametersNode = actionNode.getKeywordOpenBracket('parameters');
        const parameters = parametersNode ? (0, VariablesParser_1.parseParameters)(parametersNode.getNestedNonCommentText()) : [];
        const durationNode = actionNode.getKeywordOpenBracket('duration');
        const conditionNode = actionNode.getKeywordOpenBracket('condition');
        const effectNode = actionNode.getKeywordOpenBracket('effect');
        const location = new DocumentPositionResolver_1.PddlRange({
            start: positionResolver.resolveToPosition(actionNode.getStart()),
            end: positionResolver.resolveToPosition(actionNode.getEnd())
        });
        this.action = new DomainInfo_1.DurativeAction(actionName, parameters, location, durationNode, conditionNode, effectNode);
        this.action.setDocumentation(DerivedVariableParser_1.DerivedVariablesParser.getDocumentationAbove(actionNode));
    }
    getAction() {
        return this.action;
    }
}
exports.DurativeActionParser = DurativeActionParser;

},{"../DocumentPositionResolver":15,"../DomainInfo":16,"./DerivedVariableParser":35,"./PddlTokenizer":54,"./VariablesParser":57}],37:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HappeningsParser = void 0;
const HappeningsInfo_1 = require("../HappeningsInfo");
const PlanHappeningsBuilder_1 = require("./PlanHappeningsBuilder");
const PddlPlanParser_1 = require("./PddlPlanParser");
class HappeningsParser {
    parseHappenings(fileUri, fileVersion, fileText, epsilon, positionResolver) {
        const meta = PddlPlanParser_1.PddlPlanParser.parsePlanMeta(fileText);
        const happeningsInfo = new HappeningsInfo_1.HappeningsInfo(fileUri, fileVersion, meta.problemName, meta.domainName, fileText, positionResolver);
        const planBuilder = new PlanHappeningsBuilder_1.PlanHappeningsBuilder(epsilon);
        planBuilder.tryParseFile(fileText);
        happeningsInfo.setHappenings(planBuilder.getHappenings());
        happeningsInfo.addProblems(planBuilder.getParsingProblems());
        planBuilder.validateOpenQueueIsEmpty();
        return happeningsInfo;
    }
}
exports.HappeningsParser = HappeningsParser;

},{"../HappeningsInfo":19,"./PddlPlanParser":47,"./PlanHappeningsBuilder":55}],38:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstantActionParser = void 0;
const PddlTokenizer_1 = require("./PddlTokenizer");
const DocumentPositionResolver_1 = require("../DocumentPositionResolver");
const VariablesParser_1 = require("./VariablesParser");
const DomainInfo_1 = require("../DomainInfo");
const DerivedVariableParser_1 = require("./DerivedVariableParser");
/**
 * Parses `(:action ...)` blocks.
 */
class InstantActionParser {
    constructor(actionNode, positionResolver) {
        /*(:action|process|event name
            :parameters (<parameters>)
            :precondition (and <conditions>)
            :effect (and <effects>)
        )*/
        const nameNode = actionNode.getFirstChild(PddlTokenizer_1.PddlTokenType.Other, /[\w-]+/);
        const actionName = nameNode ? nameNode.getText() : undefined;
        const parametersNode = actionNode.getKeywordOpenBracket('parameters');
        const parameters = parametersNode ? (0, VariablesParser_1.parseParameters)(parametersNode.getNestedNonCommentText()) : [];
        const conditionNode = actionNode.getKeywordOpenBracket('precondition');
        const effectNode = actionNode.getKeywordOpenBracket('effect');
        const location = new DocumentPositionResolver_1.PddlRange({
            start: positionResolver.resolveToPosition(actionNode.getStart()),
            end: positionResolver.resolveToPosition(actionNode.getEnd())
        });
        this.action = new DomainInfo_1.InstantAction(actionName, parameters, location, conditionNode, effectNode);
        this.action.setDocumentation(DerivedVariableParser_1.DerivedVariablesParser.getDocumentationAbove(actionNode));
    }
    getAction() {
        return this.action;
    }
}
exports.InstantActionParser = InstantActionParser;

},{"../DocumentPositionResolver":15,"../DomainInfo":16,"./DerivedVariableParser":35,"./PddlTokenizer":54,"./VariablesParser":57}],39:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricParser = void 0;
const PddlTokenizer_1 = require("./PddlTokenizer");
const DocumentPositionResolver_1 = require("../DocumentPositionResolver");
const DerivedVariableParser_1 = require("./DerivedVariableParser");
const ProblemInfo_1 = require("../ProblemInfo");
const NumericExpressionParser_1 = require("./NumericExpressionParser");
/**
 * Parses `(:metric ...)` blocks.
 */
class MetricParser {
    constructor(metricNode, positionResolver) {
        /*(:metric
            minimize|maximize
            <expression>
        )*/
        let direction;
        let expression;
        const children = metricNode.getNonWhitespaceNonCommentChildren();
        children.forEach(node => {
            const match = node.getText().match(/(minimize|maximize)/i);
            if (match === null || match === void 0 ? void 0 : match.length) {
                switch (match[1]) {
                    case "minimize":
                        direction = ProblemInfo_1.MetricDirection.MINIMIZE;
                        break;
                    case "maximize":
                        direction = ProblemInfo_1.MetricDirection.MAXIMIZE;
                        break;
                }
            }
            else if ((0, PddlTokenizer_1.isOpenBracket)(node.getToken())) {
                expression = new NumericExpressionParser_1.NumericExpressionParser(node).getExpression();
            }
        });
        if (direction !== undefined && expression !== undefined) {
            const location = new DocumentPositionResolver_1.PddlRange({
                start: positionResolver.resolveToPosition(metricNode.getStart()),
                end: positionResolver.resolveToPosition(metricNode.getEnd())
            });
            const documentation = DerivedVariableParser_1.DerivedVariablesParser.getDocumentationAbove(metricNode);
            this.metric = new ProblemInfo_1.Metric(direction, expression, location, documentation);
        }
    }
    getMetric() {
        return this.metric;
    }
}
exports.MetricParser = MetricParser;

},{"../DocumentPositionResolver":15,"../ProblemInfo":29,"./DerivedVariableParser":35,"./NumericExpressionParser":41,"./PddlTokenizer":54}],40:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2021. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NormalizingPddlPlanParser = void 0;
const PlanStep_1 = require("../PlanStep");
const PddlPlanBuilder_1 = require("./PddlPlanBuilder");
const PddlPlanParser_1 = require("./PddlPlanParser");
/** Parsers the plan lines, offsets the times (by epsilon, if applicable) and returns the lines normalized. */
class NormalizingPddlPlanParser {
    constructor(epsilon) {
        this.epsilon = epsilon;
        this.makespan = 0;
        this.timeOffset = 0;
        this.firstLineParsed = false;
    }
    /**
     * Parses and normalizes the plan text (typically for plan comparison).
     * If the plan starts at time zero, it is shifted to time `epsilon`.
     *
     * @param origText original plan text
     * @param endl platform-specific end-line characters
     */
    normalize(origText, endl) {
        const compare = function (step1, step2) {
            if (step1.getStartTime() !== step2.getStartTime()) {
                return step1.getStartTime() - step2.getStartTime();
            }
            else {
                return step1.fullActionName.localeCompare(step2.fullActionName);
            }
        };
        const planMeta = PddlPlanParser_1.PddlPlanParser.parsePlanMeta(origText);
        const planParser = new PddlPlanParser_1.PddlPlanParser();
        const planBuilder = new PddlPlanBuilder_1.PddlPlanBuilder(this.epsilon);
        const normalizedText = PddlPlanParser_1.PddlPlanParser.getPlanMeta(planMeta.domainName, planMeta.problemName, endl)
            + `${endl}; Normalized plan:${endl}`
            + origText.split('\n')
                .map((origLine, idx) => this.normalizeLine(origLine, idx, planParser, planBuilder))
                .filter(step => step !== undefined)
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                .map(step => step)
                .sort(compare)
                .map(step => step.toPddl())
                .join(endl);
        return normalizedText;
    }
    normalizeLine(line, lineIdx, planParser, planBuilder) {
        const planStep = planParser.parse(line, lineIdx, planBuilder);
        if (!planStep) {
            return undefined;
        }
        else {
            // this line is a plan step
            const time = planStep.getStartTime();
            if (!this.firstLineParsed) {
                if (time === 0) {
                    this.timeOffset = -this.epsilon;
                }
                this.firstLineParsed = true;
            }
            return new PlanStep_1.PlanStep(time - this.timeOffset, planStep.getFullActionName(), planStep.isDurative, planStep.getDuration(), planStep.lineIndex);
        }
    }
}
exports.NormalizingPddlPlanParser = NormalizingPddlPlanParser;

},{"../PlanStep":27,"./PddlPlanBuilder":46,"./PddlPlanParser":47}],41:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumericExpressionParser = void 0;
// import { PddlTokenType } from "./PddlTokenizer";
// import { PddlRange, DocumentPositionResolver } from "../DocumentPositionResolver";
const NumericExpression_1 = require("../NumericExpression");
const __1 = require("..");
/**
 * Parses `(+ (a) (b))` numeric expressions.
 */
class NumericExpressionParser {
    constructor(rootNode) {
        this.expression = this.parseNode(rootNode);
    }
    getExpression() {
        return this.expression;
    }
    parseNode(node) {
        switch (node.getToken().tokenText) {
            case '(+':
                const summants = this.parseChildren(node);
                return new NumericExpression_1.Sum(summants);
            case '(*':
                const multiplicants = this.parseChildren(node);
                return new NumericExpression_1.Product(multiplicants);
            case '(/': {
                const operands = this.parseChildren(node);
                if (operands.length === 2) {
                    return new NumericExpression_1.Division(operands[0], operands[1]);
                }
                else {
                    return undefined;
                }
            }
            case '(-': {
                const operands = this.parseChildren(node);
                if (operands.length === 2) {
                    return new NumericExpression_1.Subtraction(operands[0], operands[1]);
                }
                else {
                    return undefined;
                }
            }
        }
        if (node.getToken().tokenText.startsWith('(')) {
            return new __1.VariableExpression(node.getNestedText());
        }
        else if (parseFloat(node.getToken().tokenText)) {
            // the parsed value may be NaN
            return new NumericExpression_1.NumericLiteral(parseFloat(node.getToken().tokenText));
        }
        return undefined;
    }
    parseChildren(node) {
        return node.getNonWhitespaceNonCommentChildren()
            .map(childNode => this.parseNode(childNode))
            // todo: should not be filtering out elements that failed to parse, but rather reporting the failure
            .filter(c => !!c)
            .map(c => c);
    }
}
exports.NumericExpressionParser = NumericExpressionParser;

},{"..":32,"../NumericExpression":21}],42:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2019. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlConstraintsParser = void 0;
const constraints_1 = require("../constraints");
const PddlTokenizer_1 = require("./PddlTokenizer");
/* eslint-disable @typescript-eslint/no-non-null-assertion */
class PddlConstraintsParser {
    parseConstraints(constraintsNode) {
        const children = constraintsNode.getNonWhitespaceChildren().filter(child => (0, PddlTokenizer_1.isOpenBracket)(child.getToken()));
        if (children.length === 0) {
            return [];
        }
        if (children[0].isType(PddlTokenizer_1.PddlTokenType.OpenBracketOperator) && children[0].getToken().tokenText === '(and') {
            return this.parseConstraints(children[0]);
        }
        return children
            .map(child => this.parseChild(child))
            .filter(c => c !== undefined)
            .map(c => c);
    }
    parseChild(node) {
        var _a, _b;
        const children = node.getNonWhitespaceNonCommentChildren();
        if (children.length === 0 && node.getToken().tokenText === '(') {
            return new constraints_1.Constraint(node);
        }
        if (children.length > 0 && children[0].getToken().type === PddlTokenizer_1.PddlTokenType.Other) {
            const token = children[0].getToken().tokenText.toLowerCase();
            const strictlyAfterToken = 'strictly-after';
            switch (token) {
                case 'name':
                case 'named-condition':
                    return (_a = this.parseNamedCondition(node, children.slice(1))) !== null && _a !== void 0 ? _a : new constraints_1.Constraint(node);
                case strictlyAfterToken:
                case 'after':
                    return (_b = this.parseAfter(node, children.slice(1), token === strictlyAfterToken)) !== null && _b !== void 0 ? _b : new constraints_1.Constraint(node);
                default:
                    return new constraints_1.Constraint(node);
            }
        }
        else {
            return new constraints_1.Constraint(node);
        }
    }
    parseNamedCondition(constraintNode, children) {
        if (children.length < 2) {
            return undefined;
        }
        if (!children[0].isType(PddlTokenizer_1.PddlTokenType.Other)) {
            return undefined;
        }
        const name = children[0].getText();
        if ((0, PddlTokenizer_1.isOpenBracket)(children[1].getToken())) {
            const condition = new constraints_1.Condition(children[1]);
            return new constraints_1.NamedConditionConstraint({ name: name, condition: condition }, constraintNode);
        }
        else {
            return undefined;
        }
    }
    parseAfter(constraintNode, children, strictly) {
        if (children.length < 2) {
            return undefined;
        }
        const predecessor = this.parseAfterGoal(children[0]);
        const successor = this.parseAfterGoal(children[1]);
        if (!(predecessor || successor)) {
            return undefined;
        }
        if (strictly) {
            return new constraints_1.StrictlyAfterConstraint(predecessor, successor, constraintNode);
        }
        else {
            return new constraints_1.AfterConstraint(predecessor, successor, constraintNode);
        }
    }
    parseAfterGoal(nameOrConditionNode) {
        if (nameOrConditionNode.isType(PddlTokenizer_1.PddlTokenType.Other)) {
            const name = nameOrConditionNode.getText();
            return new constraints_1.NamedConditionConstraint({ name: name }, nameOrConditionNode);
        }
        else if ((0, PddlTokenizer_1.isOpenBracket)(nameOrConditionNode.getToken())) {
            const condition = new constraints_1.Condition(nameOrConditionNode);
            return new constraints_1.NamedConditionConstraint({ condition: condition }, nameOrConditionNode);
        }
        else {
            return undefined;
        }
    }
}
exports.PddlConstraintsParser = PddlConstraintsParser;

},{"../constraints":31,"./PddlTokenizer":54}],43:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlDomainParser = void 0;
const PddlTokenizer_1 = require("./PddlTokenizer");
const VariablesParser_1 = require("./VariablesParser");
const DocumentPositionResolver_1 = require("../DocumentPositionResolver");
const DerivedVariableParser_1 = require("./DerivedVariableParser");
const DomainInfo_1 = require("../DomainInfo");
const InstantActionParser_1 = require("./InstantActionParser");
const DurativeActionParser_1 = require("./DurativeActionParser");
const PddlInheritanceParser_1 = require("./PddlInheritanceParser");
const PddlConstraintsParser_1 = require("./PddlConstraintsParser");
const PddlSyntaxTreeBuilder_1 = require("./PddlSyntaxTreeBuilder");
const PddlFileParser_1 = require("./PddlFileParser");
const vscode_uri_1 = require("vscode-uri");
/**
 * Planning Domain parser.
 */
class PddlDomainParser extends PddlFileParser_1.PddlFileParser {
    async tryParse(fileUri, fileVersion, fileText, syntaxTree, positionResolver) {
        //(define (domain domain_name)
        const defineNode = syntaxTree.getDefineNode();
        if (!defineNode) {
            return undefined;
        }
        const domainNode = defineNode.getFirstOpenBracket('domain');
        if (!domainNode) {
            return undefined;
        }
        return this.parse(fileUri, fileVersion, fileText, domainNode, syntaxTree, positionResolver);
    }
    parse(fileUri, fileVersion, fileText, domainNode, syntaxTree, positionResolver) {
        const domainNameNode = domainNode.getFirstChild(PddlTokenizer_1.PddlTokenType.Other, /./);
        if (!domainNameNode)
            return undefined;
        const domainName = domainNameNode.getToken().tokenText;
        const domainInfo = new DomainInfo_1.DomainInfo(fileUri, fileVersion, domainName, syntaxTree, positionResolver);
        domainInfo.setText(fileText);
        this.parseDomainStructure(domainInfo, positionResolver);
        return domainInfo;
    }
    static parseText(domainText, fileNameOrIdentifier = vscode_uri_1.URI.parse('string://noname'), version = -1) {
        const parser = new PddlSyntaxTreeBuilder_1.PddlSyntaxTreeBuilder(domainText);
        const syntaxTree = parser.getTree();
        //(define (domain domain_name)
        const defineNode = syntaxTree.getDefineNode();
        if (!defineNode) {
            return undefined;
        }
        const domainNode = defineNode.getFirstOpenBracket('domain');
        if (!domainNode) {
            return undefined;
        }
        const positionResolver = new DocumentPositionResolver_1.SimpleDocumentPositionResolver(domainText);
        return new PddlDomainParser().parse(fileNameOrIdentifier, version, domainText, domainNode, syntaxTree, positionResolver);
    }
    parseDomainStructure(domainInfo, positionResolver) {
        const defineNode = domainInfo.syntaxTree.getDefineNodeOrThrow();
        PddlDomainParser.parseRequirements(defineNode, domainInfo);
        const typesNode = defineNode.getFirstOpenBracket(':types');
        if (typesNode) {
            domainInfo.setTypeInheritance(PddlInheritanceParser_1.PddlInheritanceParser.parseInheritance(typesNode.getNestedNonCommentText()), typesNode, positionResolver);
        }
        const constantsNode = defineNode.getFirstOpenBracket(':constants');
        if (constantsNode) {
            const constantsText = constantsNode.getNestedNonCommentText();
            domainInfo.setConstants(PddlInheritanceParser_1.PddlInheritanceParser.toTypeObjects(PddlInheritanceParser_1.PddlInheritanceParser.parseInheritance(constantsText)));
        }
        const predicatesNode = defineNode.getFirstOpenBracket(':predicates');
        if (predicatesNode) {
            const predicates = new VariablesParser_1.VariablesParser(predicatesNode, positionResolver).getVariables();
            domainInfo.setPredicates(predicates);
        }
        const functionsNode = defineNode.getFirstOpenBracket(':functions');
        if (functionsNode) {
            const functions = new VariablesParser_1.VariablesParser(functionsNode, positionResolver).getVariables();
            domainInfo.setFunctions(functions);
        }
        domainInfo.setDerived(PddlDomainParser.parseDerived(defineNode, positionResolver));
        const instantActions = this.parseActionProcessOrEvent(defineNode, positionResolver, "action");
        const durativeActions = this.parseDurativeActions(defineNode, positionResolver);
        domainInfo.setActions(instantActions.concat(durativeActions));
        const processes = this.parseActionProcessOrEvent(defineNode, positionResolver, "process");
        const events = this.parseActionProcessOrEvent(defineNode, positionResolver, "event");
        domainInfo.setProcesses(processes);
        domainInfo.setEvents(events);
        const constraintsNode = defineNode.getFirstOpenBracket(':constraints');
        if (constraintsNode) {
            const constraints = new PddlConstraintsParser_1.PddlConstraintsParser().parseConstraints(constraintsNode);
            domainInfo.setConstraints(constraints);
        }
    }
    static parseRequirements(defineNode, fileInfo) {
        const requirementsNode = defineNode.getFirstOpenBracket(':requirements');
        if (requirementsNode) {
            const requirements = requirementsNode.getNonWhitespaceChildren()
                .filter(node => node.getToken().type === PddlTokenizer_1.PddlTokenType.Keyword)
                .map(node => node.getToken().tokenText);
            fileInfo.setRequirements(requirements);
        }
    }
    static parseDerived(defineNode, positionResolver) {
        return defineNode.getChildrenOfType(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /\(\s*:derived$/)
            .map(derivedNode => new DerivedVariableParser_1.DerivedVariablesParser(derivedNode, positionResolver).getVariable())
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            .filter(derived => !!derived).map(derived => derived);
    }
    parseActionProcessOrEvent(defineNode, positionResolver, keyword) {
        return defineNode.getChildrenOfType(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, new RegExp("\\(\\s*:" + keyword + "$"))
            .map(actionNode => new InstantActionParser_1.InstantActionParser(actionNode, positionResolver).getAction());
    }
    parseDurativeActions(defineNode, positionResolver) {
        return defineNode.getChildrenOfType(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /\(\s*:durative-action$/)
            .map(actionNode => new DurativeActionParser_1.DurativeActionParser(actionNode, positionResolver).getAction());
    }
}
exports.PddlDomainParser = PddlDomainParser;

},{"../DocumentPositionResolver":15,"../DomainInfo":16,"./DerivedVariableParser":35,"./DurativeActionParser":36,"./InstantActionParser":38,"./PddlConstraintsParser":42,"./PddlFileParser":44,"./PddlInheritanceParser":45,"./PddlSyntaxTreeBuilder":53,"./PddlTokenizer":54,"./VariablesParser":57,"vscode-uri":80}],44:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlFileParser = void 0;
/**
 * Abstract PDDL file parser. Implement this interface.
 */
class PddlFileParser {
}
exports.PddlFileParser = PddlFileParser;

},{}],45:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlInheritanceParser = void 0;
const DirectionalGraph_1 = require("../utils/DirectionalGraph");
const DomainInfo_1 = require("../DomainInfo");
/**
 * Planning type/object inheritance parser.
 */
class PddlInheritanceParser {
    static parseInheritance(declarationText) {
        // the inheritance graph is captured as a two dimensional array, where the first index is the types themselves, the second is the parent type they inherit from (PDDL supports multiple inheritance)
        const inheritance = new DirectionalGraph_1.DirectionalGraph();
        if (!declarationText) {
            return inheritance;
        }
        // if there are root types that do not inherit from 'object', add the 'object' inheritance.
        // it will make the following regex work
        if (!declarationText.match(/-\s+\w[\w-]*\s*$/)) {
            declarationText += ' - object';
        }
        const pattern = /(\w[\w-]*\s+)+-\s+\w[\w-]*/g;
        let match;
        while (match = pattern.exec(declarationText)) {
            // is this a group with inheritance?
            const fragments = match[0].split(/\s-/);
            const parent = fragments.length > 1 ? fragments[1].trim() : undefined;
            const children = fragments[0].trim().split(/\s+/g);
            children.forEach(childType => inheritance.addEdge(childType, parent));
        }
        // connect orphan types to the 'object' type
        const orphans = inheritance.getVertices()
            .filter(v => { var _a, _b; return (_b = !((_a = inheritance.getVerticesWithEdgesFrom(v)) === null || _a === void 0 ? void 0 : _a.length)) !== null && _b !== void 0 ? _b : 0; })
            .filter(orphan => orphan !== this.OBJECT);
        orphans.forEach(orphan => inheritance.addEdge(orphan, this.OBJECT));
        return inheritance;
    }
    static toTypeObjects(graph) {
        const typeObjectMap = new DomainInfo_1.TypeObjectMap();
        graph.getVertices().forEach(obj => {
            var _a;
            (_a = graph.getVerticesWithEdgesFrom(obj)) === null || _a === void 0 ? void 0 : _a.forEach(type => typeObjectMap.add(type, obj));
        });
        return typeObjectMap;
    }
}
exports.PddlInheritanceParser = PddlInheritanceParser;
PddlInheritanceParser.OBJECT = 'object';

},{"../DomainInfo":16,"../utils/DirectionalGraph":73}],46:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlPlanBuilder = void 0;
const Plan_1 = require("../Plan");
/**
 * Utility for incremental plan building as it is being parsed.
 */
class PddlPlanBuilder {
    constructor(epsilon) {
        this.epsilon = epsilon;
        this.steps = [];
        this.outputText = ""; // for information only
        this.parsingPlan = false;
        this.makespan = 0;
    }
    add(step) {
        const effectiveEndTime = step.getEffectiveEndTime();
        if (this.makespan < effectiveEndTime) {
            this.makespan = effectiveEndTime;
        }
        this.steps.push(step);
    }
    getSteps() {
        return this.steps;
    }
    build(domain, problem) {
        const plan = new Plan_1.Plan(this.steps, domain, problem);
        plan.statesEvaluated = this.statesEvaluated;
        if (this.metric !== undefined) {
            plan.metric = this.metric;
        }
        return plan;
    }
    getMakespan() {
        return this.makespan;
    }
    setMakespan(makespan) {
        this.makespan = makespan;
    }
    getMetric() {
        return this.metric;
    }
    setMetric(metric) {
        this.metric = metric;
    }
    getStatesEvaluated() {
        return this.statesEvaluated;
    }
    setStatesEvaluated(statesEvaluated) {
        this.statesEvaluated = statesEvaluated;
    }
}
exports.PddlPlanBuilder = PddlPlanBuilder;

},{"../Plan":25}],47:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlPlanParser = exports.UNSPECIFIED_DOMAIN = exports.UNSPECIFIED_PROBLEM = void 0;
const PlanInfo_1 = require("../PlanInfo");
const PddlPlanBuilder_1 = require("./PddlPlanBuilder");
const DocumentPositionResolver_1 = require("../DocumentPositionResolver");
const vscode_uri_1 = require("vscode-uri");
const PlanStep_1 = require("../PlanStep");
exports.UNSPECIFIED_PROBLEM = 'unspecified';
exports.UNSPECIFIED_DOMAIN = 'unspecified';
class PddlPlanParser {
    constructor() {
        this.planStepPattern = /^\s*((\d+|\d+\.\d+)\s*:)?\s*\((.*)\)\s*(\[(?:D:)?\s*(\d+|\d+\.\d+)\s*(?:;\s*C:[\d.]+)?\])?\s*$/gim;
        this.planStatesEvaluatedPattern = /^\s*;?\s*States evaluated[\w ]*:[ ]*(\d*)\s*$/i;
        this.planMetricPattern = /[\w ]*(cost|metric)[^-\w]*:?\s*([+-]?\d*(\.\d+)?|[+-]?\d(\.\d+)?[Ee][+-]?\d+)\s*$/i;
    }
    static parsePlanMeta(fileText) {
        let problemName = exports.UNSPECIFIED_PROBLEM;
        const problemMatch = fileText.match(/^;;\s*!problem:\s*([\w-]+)\s*$/m);
        if (problemMatch) {
            problemName = problemMatch[1];
        }
        let domainName = exports.UNSPECIFIED_DOMAIN;
        const domainMatch = fileText.match(/^;;\s*!domain:\s*([\w-]+)\s*$/m);
        if (domainMatch) {
            domainName = domainMatch[1];
        }
        return { domainName: domainName, problemName: problemName };
    }
    static getPlanMeta(domainName, problemName, endl) {
        return `;;!domain: ${domainName}${endl};;!problem: ${problemName}${endl}`;
    }
    parseText(planText, epsilon = 0.001, fileUri = vscode_uri_1.URI.parse('string://noname'), fileVersion = -1, positionResolver) {
        const meta = PddlPlanParser.parsePlanMeta(planText);
        const definedPositionResolver = positionResolver !== null && positionResolver !== void 0 ? positionResolver : new DocumentPositionResolver_1.SimpleDocumentPositionResolver(planText);
        const planInfo = new PlanInfo_1.PlanInfo(fileUri, fileVersion, meta.problemName, meta.domainName, planText, definedPositionResolver);
        const planBuilder = new PddlPlanBuilder_1.PddlPlanBuilder(epsilon);
        planText.split('\n').forEach((planLine, index) => this.tryParseLine(planLine, index, planBuilder));
        planInfo.setSteps(planBuilder.getSteps());
        planInfo.metric = planBuilder.getMetric();
        planInfo.statesEvaluated = planBuilder.getStatesEvaluated();
        return planInfo;
    }
    tryParseLine(planLine, index, planBuilder) {
        const planStep = this.parse(planLine, index, planBuilder);
        if (planStep) {
            planBuilder.add(planStep);
        }
        else {
            this.parsePlanQuality(planLine, planBuilder);
        }
    }
    /**
     * Parses one line from the plan
     * @param planLine line of text from the plan file
     * @param lineIndex index of the line being parsed
     */
    parse(planLine, lineIndex, planBuilder) {
        this.planStepPattern.lastIndex = 0;
        const group = this.planStepPattern.exec(planLine);
        if (group) {
            // this line is a valid plan step
            const time = group[2] ? parseFloat(group[2]) : planBuilder.getMakespan();
            const action = group[3].trim();
            const isDurative = group[5] ? true : false;
            const duration = isDurative ? parseFloat(group[5]) : planBuilder.epsilon;
            return new PlanStep_1.PlanStep(time, action, isDurative, duration, lineIndex);
        }
        else {
            return undefined;
        }
    }
    parsePlanQuality(planLine, planBuilder) {
        var _a;
        let group;
        this.planStatesEvaluatedPattern.lastIndex = 0;
        this.planMetricPattern.lastIndex = 0;
        if (group = this.planStatesEvaluatedPattern.exec(planLine)) {
            planBuilder.setStatesEvaluated(parseInt(group[1]));
        }
        else if (!planLine.match(/action/i) &&
            (group = this.planMetricPattern.exec(planLine))) {
            if (((_a = group[2]) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                planBuilder.setMetric(parseFloat(group[2]));
            }
        }
    }
}
exports.PddlPlanParser = PddlPlanParser;

},{"../DocumentPositionResolver":15,"../PlanInfo":26,"../PlanStep":27,"./PddlPlanBuilder":46,"vscode-uri":80}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlPlannerOutputParser = void 0;
const ProblemInfo_1 = require("../ProblemInfo");
const DomainInfo_1 = require("../DomainInfo");
const PddlSyntaxTree_1 = require("./PddlSyntaxTree");
const DocumentPositionResolver_1 = require("../DocumentPositionResolver");
const XmlPlanBuilder_1 = require("./XmlPlanBuilder");
const PddlPlanBuilder_1 = require("./PddlPlanBuilder");
const PddlPlanParser_1 = require("./PddlPlanParser");
/**
 * Parses plan in the PDDL form incrementally - line/buffer at a time.
 * It can parse a continuous output of a planner, which may contain multiple plans.
 */
class PddlPlannerOutputParser {
    constructor(domain, problem, options, onPlanReady) {
        this.domain = domain;
        this.problem = problem;
        this.options = options;
        this.onPlanReady = onPlanReady;
        this.plans = [];
        this.endOfBufferToBeParsedNextTime = '';
        this.planTimeScale = 1;
        this.planBuilder = new PddlPlanBuilder_1.PddlPlanBuilder(options.epsilon);
        this.pddlPlanParser = new PddlPlanParser_1.PddlPlanParser();
    }
    setPlanMetaData(makespan, metric, statesEvaluated, _elapsedTimeInSeconds, planTimeScale) {
        this.planBuilder.setMakespan(makespan);
        this.planBuilder.setMetric(metric);
        this.planBuilder.setStatesEvaluated(statesEvaluated);
        this.planTimeScale = planTimeScale;
    }
    /**
     * Appends and parses the planner output.
     * @param text planner output
     */
    appendBuffer(text) {
        const textString = this.endOfBufferToBeParsedNextTime + text;
        this.endOfBufferToBeParsedNextTime = '';
        let lastEndLine = 0;
        let nextEndLine;
        while ((nextEndLine = textString.indexOf('\n', lastEndLine)) > -1) {
            const nextLine = textString.substring(lastEndLine, nextEndLine + 1);
            if (nextLine.trim()) {
                this.appendLine(nextLine.trim());
            }
            lastEndLine = nextEndLine + 1;
        }
        if (textString.length > lastEndLine) {
            this.endOfBufferToBeParsedNextTime = textString.substring(lastEndLine);
        }
    }
    async appendXplan(planXml) {
        if (this.xmlPlanBuilder) {
            throw new Error("Mix of incremental XML parsing and full plan appending is not supported.");
        }
        const xmlPlanBuilder = new XmlPlanBuilder_1.XmlPlanBuilder(this.planTimeScale);
        xmlPlanBuilder.appendLine(planXml);
        const steps = await xmlPlanBuilder.getPlanSteps();
        steps.forEach(step => this.appendStep(step));
        this.onPlanFinished();
        return this.getPlans();
    }
    /**
     * Parses one line of parser output.
     * @param outputLine one line of planner output
     */
    appendLine(outputLine) {
        if (this.xmlPlanBuilder || XmlPlanBuilder_1.XmlPlanBuilder.isXmlStart(outputLine)) {
            (this.xmlPlanBuilder || (this.xmlPlanBuilder = new XmlPlanBuilder_1.XmlPlanBuilder(this.planTimeScale))).appendLine(outputLine);
            if (this.xmlPlanBuilder.isComplete()) {
                // extract plan
                this.xmlPlanBuilder.getPlanSteps()
                    .then(steps => {
                    steps.forEach(step => this.appendStep(step));
                    this.xmlPlanBuilder = undefined;
                    this.onPlanFinished();
                })
                    .catch(reason => {
                    console.log(reason);
                });
            }
            return;
        }
        const planStep = this.pddlPlanParser.parse(outputLine, undefined, this.planBuilder);
        if (planStep) {
            // this line is a plan step
            this.appendStep(planStep);
        }
        else {
            // this line is NOT a plan step
            if (this.planBuilder.parsingPlan) {
                this.planBuilder.parsingPlan = false;
                this.onPlanFinished();
            }
            this.pddlPlanParser.parsePlanQuality(outputLine, this.planBuilder);
        }
        this.planBuilder.outputText += outputLine;
    }
    /**
     * Appends plan step. Use this when the plan does not need parsing.
     * @param planStep plan step to add to the plan
     */
    appendStep(planStep) {
        this.planBuilder.add(planStep);
        if (!this.planBuilder.parsingPlan) {
            this.planBuilder.parsingPlan = true;
        }
    }
    /**
     * Call this when the planning engine stopped. This flushes the last line in the buffered output through the parsing
     * and adds the last plan to the collection of plans.
     */
    onPlanFinished() {
        var _a;
        if (this.endOfBufferToBeParsedNextTime.trim().length) {
            this.appendLine(this.endOfBufferToBeParsedNextTime.trim());
            this.endOfBufferToBeParsedNextTime = '';
        }
        if (this.planBuilder.getSteps().length > 0 ||
            this.plans.length < ((_a = this.options.minimumPlansExpected) !== null && _a !== void 0 ? _a : 1)) {
            this.plans.push(this.planBuilder.build(this.domain, this.problem));
            this.planBuilder = new PddlPlanBuilder_1.PddlPlanBuilder(this.options.epsilon);
        }
        else {
            // patch the previous plan metric and makespan if printed after the plan
            if (this.plans.length > 0) {
                const lastPlan = this.plans[this.plans.length - 1];
                if (this.planBuilder.getMetric() !== undefined
                    && !lastPlan.isMetricDefined()) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    lastPlan.metric = this.planBuilder.getMetric();
                }
            }
        }
        if (this.onPlanReady) {
            this.onPlanReady.apply(this, [this.plans]);
        }
    }
    /** Gets current plan's provisional makespan. */
    getCurrentPlanMakespan() {
        return this.planBuilder.getMakespan();
    }
    /**
     * Gets all plans.
     */
    getPlans() {
        return this.plans;
    }
    static parseOnePlan(planText, planUri, epsilon) {
        const dummyDomain = new DomainInfo_1.DomainInfo(planUri, 1, 'domain', PddlSyntaxTree_1.PddlSyntaxTree.EMPTY, new DocumentPositionResolver_1.SimpleDocumentPositionResolver(''));
        const dummyProblem = new ProblemInfo_1.ProblemInfo(planUri, 1, 'problem', 'domain', PddlSyntaxTree_1.PddlSyntaxTree.EMPTY, new DocumentPositionResolver_1.SimpleDocumentPositionResolver(''));
        const parser = new PddlPlannerOutputParser(dummyDomain, dummyProblem, { minimumPlansExpected: 1, epsilon: epsilon });
        parser.appendBuffer(planText);
        parser.onPlanFinished();
        const plans = parser.getPlans();
        if (plans.length === 1) {
            return plans[0];
        }
        else {
            throw new Error(`Unexpected number of expected plans (${plans.length}) in file ${planUri.toString()}.`);
        }
    }
}
exports.PddlPlannerOutputParser = PddlPlannerOutputParser;

},{"../DocumentPositionResolver":15,"../DomainInfo":16,"../ProblemInfo":29,"./PddlPlanBuilder":46,"./PddlPlanParser":47,"./PddlSyntaxTree":52,"./XmlPlanBuilder":58}],49:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlProblemParser = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const ProblemParserPreProcessor_1 = require("../ProblemParserPreProcessor");
const path_1 = require("path");
const DocumentPositionResolver_1 = require("../DocumentPositionResolver");
const PddlSyntaxTree_1 = require("./PddlSyntaxTree");
const FileInfo_1 = require("../FileInfo");
const PreProcessors_1 = require("../PreProcessors");
const ProblemInfo_1 = require("../ProblemInfo");
const PddlDomainParser_1 = require("./PddlDomainParser");
const PddlTokenizer_1 = require("./PddlTokenizer");
const PddlInheritanceParser_1 = require("./PddlInheritanceParser");
const PddlConstraintsParser_1 = require("./PddlConstraintsParser");
const PddlSyntaxTreeBuilder_1 = require("./PddlSyntaxTreeBuilder");
const PddlFileParser_1 = require("./PddlFileParser");
const vscode_uri_1 = require("vscode-uri");
const MetricParser_1 = require("./MetricParser");
/**
 * Planning Problem parser.
 */
class PddlProblemParser extends PddlFileParser_1.PddlFileParser {
    constructor(context) {
        super();
        this.problemPattern = /^\s*\(define\s*\(problem\s+(\S+)\s*\)\s*\(:domain\s+([^\r\n\t\f\v \)]+)\s*\)/gi;
        if (context) {
            this.problemPreParser = new ProblemParserPreProcessor_1.ProblemParserPreProcessor(context);
        }
    }
    static async parseText(problemText, fileNameOrIdentifier = vscode_uri_1.URI.parse('file:///noname'), version = -1) {
        const parser = new PddlSyntaxTreeBuilder_1.PddlSyntaxTreeBuilder(problemText);
        const syntaxTree = parser.getTree();
        const positionResolver = new DocumentPositionResolver_1.SimpleDocumentPositionResolver(problemText);
        return await new PddlProblemParser()
            .tryParse(fileNameOrIdentifier, version, problemText, syntaxTree, positionResolver);
    }
    async tryParse(fileUri, fileVersion, fileText, syntaxTree, positionResolver) {
        var _a;
        let preProcessor;
        if (this.problemPreParser) {
            try {
                preProcessor = this.problemPreParser.createPreProcessor(fileText);
                const filePath = fileUri.fsPath;
                const workingDirectory = (0, path_1.dirname)(filePath);
                fileText = await this.problemPreParser.process(preProcessor, fileText, workingDirectory);
            }
            catch (ex) {
                const problemInfo = new ProblemInfo_1.ProblemInfo(fileUri, fileVersion, "unknown", "unknown", PddlSyntaxTree_1.PddlSyntaxTree.EMPTY, positionResolver);
                problemInfo.setText(fileText);
                if (ex instanceof PreProcessors_1.PreProcessingError) {
                    const parsingError = ex;
                    problemInfo.addProblems([new FileInfo_1.ParsingProblem(parsingError.message, "error", DocumentPositionResolver_1.PddlRange.createSingleCharacterRange({ line: parsingError.line, character: parsingError.column }))]);
                }
                else if (ex instanceof Error) {
                    const line = positionResolver.resolveToPosition((preProcessor === null || preProcessor === void 0 ? void 0 : preProcessor.metaDataLineOffset) || 0).line;
                    problemInfo.addProblems([new FileInfo_1.ParsingProblem((_a = ex.message) !== null && _a !== void 0 ? _a : ex, "error", DocumentPositionResolver_1.PddlRange.createFullLineRange(line))]);
                }
                if (preProcessor) {
                    problemInfo.setPreParsingPreProcessor(preProcessor);
                }
                return problemInfo;
            }
        }
        const pddlText = (0, FileInfo_1.stripComments)(fileText);
        this.problemPattern.lastIndex = 0;
        const matchGroups = this.problemPattern.exec(pddlText);
        if (matchGroups) {
            const problemName = matchGroups[1];
            const domainName = matchGroups[2];
            const problemInfo = new ProblemInfo_1.ProblemInfo(fileUri, fileVersion, problemName, domainName, syntaxTree, positionResolver);
            problemInfo.setText(fileText);
            this.getProblemStructure(problemInfo);
            if (preProcessor) {
                problemInfo.setPreParsingPreProcessor(preProcessor);
            }
            return problemInfo;
        }
        else {
            return undefined;
        }
    }
    getProblemStructure(problemInfo) {
        const defineNode = problemInfo.syntaxTree.getDefineNodeOrThrow();
        PddlDomainParser_1.PddlDomainParser.parseRequirements(defineNode, problemInfo);
        const objectsNode = defineNode.getFirstOpenBracket(':objects');
        if (objectsNode) {
            const objectsText = objectsNode.getNestedNonCommentText();
            problemInfo.setObjects(PddlInheritanceParser_1.PddlInheritanceParser.toTypeObjects(PddlInheritanceParser_1.PddlInheritanceParser.parseInheritance(objectsText)));
        }
        const initNode = defineNode.getFirstOpenBracket(':init');
        if (initNode) {
            const [values, supplyDemands] = this.parseInitSection(initNode);
            problemInfo.setInits(values);
            problemInfo.setSupplyDemands(supplyDemands);
        }
        const constraintsNode = defineNode.getFirstOpenBracket(':constraints');
        if (constraintsNode) {
            const constraints = new PddlConstraintsParser_1.PddlConstraintsParser().parseConstraints(constraintsNode);
            problemInfo.setConstraints(constraints);
        }
        const metrics = this.parseMetrics(defineNode, problemInfo.getDocumentPositionResolver());
        problemInfo.setMetrics(metrics);
    }
    /**
     * Parses problem :init section.
     * @param initNode init syntax node
     */
    parseInitSection(initNode) {
        const timedVariableValues = initNode.getChildren()
            .filter(node => (0, PddlTokenizer_1.isOpenBracket)(node.getToken()))
            .filter(node => node.getToken().tokenText.match(/\(\s*supply-demand/i) === null)
            .map(bracket => this.parseInit(bracket))
            .filter(init => !!init).map(init => init);
        const supplyDemands = initNode.getChildrenOfType(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /\(\s*supply-demand/i)
            .map(bracket => this.parseSupplyDemand(bracket))
            .filter(sd => !!sd).map(sd => sd);
        return [timedVariableValues, supplyDemands];
    }
    parseInit(bracket) {
        if (bracket.getToken().tokenText === '(at') {
            const tokens = bracket.getNonWhitespaceChildren()
                .filter(n => n.isNotType(PddlTokenizer_1.PddlTokenType.Comment));
            if (tokens.length > 1) {
                const time = parseFloat(tokens[0].getText());
                if (!Number.isNaN(time)) {
                    const variableValue = this.parseVariableValue(tokens[1]);
                    if (variableValue) {
                        return ProblemInfo_1.TimedVariableValue.from(time, variableValue);
                    }
                }
            }
        }
        const variableValue = this.parseVariableValue(bracket);
        if (variableValue) {
            return ProblemInfo_1.TimedVariableValue.from(0, variableValue);
        }
        return undefined;
    }
    parseVariableValue(node) {
        var _a, _b;
        if (node === undefined) {
            return undefined;
        }
        else if (node.getToken().tokenText === '(=') {
            const tokens = node.getNonWhitespaceChildren()
                .filter(n => n.isNotType(PddlTokenizer_1.PddlTokenType.Comment));
            if (tokens.length > 1) {
                if (tokens[0].isType(PddlTokenizer_1.PddlTokenType.OpenBracket) && tokens[1].isType(PddlTokenizer_1.PddlTokenType.Other)) {
                    const variableName = tokens[0].getNestedText();
                    const value = parseFloat(tokens[1].getText());
                    return new ProblemInfo_1.VariableValue(variableName, value);
                }
            }
            return undefined;
        }
        else if (node.getToken().tokenText === '(not') {
            const nested = (_a = node.getFirstChild(PddlTokenizer_1.PddlTokenType.OpenBracket, /.*/)) !== null && _a !== void 0 ? _a : node.getFirstChild(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /.*/);
            if (!nested) {
                return undefined;
            }
            else {
                return (_b = this.parseVariableValue(nested)) === null || _b === void 0 ? void 0 : _b.negate();
            }
        }
        else if (['(forall', '(assign', '(increase', '(decrease'].includes(node.getToken().tokenText)) {
            return new ProblemInfo_1.UnsupportedVariableValue(node.getText());
        }
        else {
            if (node.getChildren().some(child => (0, PddlTokenizer_1.isOpenBracket)(child.getToken()))) {
                return undefined;
            }
            const variableName = node.getToken().tokenText.substr(1) + node.getNestedText();
            return new ProblemInfo_1.VariableValue(variableName, true);
        }
    }
    parseSupplyDemand(node) {
        const tokens = node.getNonWhitespaceChildren();
        if (tokens.length > 0 && tokens[0].isType(PddlTokenizer_1.PddlTokenType.Other)) {
            return new ProblemInfo_1.SupplyDemand(tokens[0].getText());
        }
        else {
            return undefined;
        }
    }
    parseMetrics(defineNode, positionResolver) {
        return defineNode.getChildrenOfType(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, new RegExp("\\(\\s*:metric$"))
            .map(metricNode => new MetricParser_1.MetricParser(metricNode, positionResolver).getMetric())
            .filter(metric => !!metric)
            .map(metric => metric);
    }
}
exports.PddlProblemParser = PddlProblemParser;

},{"../DocumentPositionResolver":15,"../FileInfo":17,"../PreProcessors":28,"../ProblemInfo":29,"../ProblemParserPreProcessor":30,"./MetricParser":39,"./PddlConstraintsParser":42,"./PddlDomainParser":43,"./PddlFileParser":44,"./PddlInheritanceParser":45,"./PddlSyntaxTree":52,"./PddlSyntaxTreeBuilder":53,"./PddlTokenizer":54,"path":235,"vscode-uri":80}],50:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlStructure = void 0;
const PddlTokenizer_1 = require("./PddlTokenizer");
class PddlStructure {
    static findPrecedingSection(newSectionName, defineNode, supportedSections) {
        const precedingSections = PddlStructure.getPrecedingSections(newSectionName, supportedSections);
        // const followingSections = PddlStructure.getFollowingSections(newSectionName, supportedSections);
        let previousSectionNode = defineNode;
        for (let index = 0; index < precedingSections.length; index++) {
            const node = defineNode.getFirstOpenBracket(precedingSections[index]);
            if (node) {
                previousSectionNode = node;
            }
        }
        return previousSectionNode;
    }
    /**
     * Determines which PDDL sections/keywords/structures are allowed at the currentNode
     * @param siblingReferenceNode node for which siblings are retrieved
     * @param currentNode node that is used to split the sibling nodes to before/after
     * @param siblingType to filter the siblings by type
     * @param allSupportedSections all supported ordered PDDL sections
     * @param allSupportedStructures additional PDDL structures (e.g. action/durative-action/process/effect/derived)
     */
    static getSupportedSectionsHere(siblingReferenceNode, currentNode, siblingType, allSupportedSections, allSupportedStructures) {
        const precedingSiblings = siblingReferenceNode.getPrecedingSiblings(siblingType, currentNode);
        const followingSiblings = siblingReferenceNode.getFollowingSiblings(siblingType, currentNode);
        let supportedSectionsHere = allSupportedSections;
        precedingSiblings.forEach(predecessor => {
            supportedSectionsHere = PddlStructure.getFollowingSections(PddlStructure.stripBracket(predecessor), supportedSectionsHere);
        });
        followingSiblings.reverse().forEach(successor => {
            supportedSectionsHere = PddlStructure.getPrecedingSections(PddlStructure.stripBracket(successor), supportedSectionsHere);
        });
        if (followingSiblings.every(successor => allSupportedStructures.find(sectionName => sectionName === PddlStructure.stripBracket(successor)))) {
            supportedSectionsHere = supportedSectionsHere.concat(allSupportedStructures);
        }
        if (precedingSiblings.some(successor => allSupportedStructures.find(sectionName => sectionName === PddlStructure.stripBracket(successor)))) {
            // only suggest structures
            supportedSectionsHere = allSupportedStructures;
        }
        return supportedSectionsHere;
    }
    static stripBracket(node) {
        return node.getToken().tokenText.replace('(', '').trim();
    }
    static getPrecedingSections(newSectionName, supportedSections) {
        const indexOfNewSection = supportedSections.indexOf(newSectionName);
        if (indexOfNewSection === -1) {
            return supportedSections;
        }
        return supportedSections.slice(0, indexOfNewSection);
    }
    static getFollowingSections(newSectionName, supportedSections) {
        const indexOfNewSection = supportedSections.indexOf(newSectionName);
        if (indexOfNewSection === -1) {
            return supportedSections;
        }
        return supportedSections.slice(indexOfNewSection + 1);
    }
    static getPrecedingKeywordOrSelf(node) {
        const parent = node.getParent();
        if (parent && parent.isType(PddlTokenizer_1.PddlTokenType.Keyword)) {
            return parent;
        }
        else {
            return node;
        }
    }
}
exports.PddlStructure = PddlStructure;
/* DOMAIN KEYWORDS */
PddlStructure.DOMAIN = 'domain';
PddlStructure.REQUIREMENTS = ':requirements';
PddlStructure.TYPES = ':types';
PddlStructure.CONSTANTS = ':constants';
PddlStructure.PREDICATES = ':predicates';
PddlStructure.FUNCTIONS = ':functions';
PddlStructure.CONSTRAINTS = ':constraints';
PddlStructure.PDDL_DOMAIN_SECTIONS = [PddlStructure.DOMAIN, PddlStructure.REQUIREMENTS, PddlStructure.TYPES, PddlStructure.CONSTANTS, PddlStructure.PREDICATES, PddlStructure.FUNCTIONS, PddlStructure.CONSTRAINTS];
/* DOMAIN STRUCTURES */
PddlStructure.DERIVED = ':derived';
PddlStructure.ACTION = ':action';
PddlStructure.DURATIVE_ACTION = ':durative-action';
PddlStructure.PROCESS = ':process';
PddlStructure.EVENT = ':event';
PddlStructure.PDDL_DOMAIN_STRUCTURES = [PddlStructure.DERIVED, PddlStructure.ACTION, PddlStructure.DURATIVE_ACTION, PddlStructure.PROCESS, PddlStructure.EVENT];
/* PROBLEM KEYWORDS */
PddlStructure.PROBLEM = 'problem';
PddlStructure.PROBLEM_DOMAIN = ':domain';
PddlStructure.OBJECTS = ':objects';
PddlStructure.INIT = ':init';
PddlStructure.GOAL = ':goal';
PddlStructure.METRIC = ':metric';
PddlStructure.PDDL_PROBLEM_SECTIONS = [PddlStructure.PROBLEM, PddlStructure.PROBLEM_DOMAIN, PddlStructure.REQUIREMENTS, PddlStructure.OBJECTS, PddlStructure.INIT, PddlStructure.GOAL, PddlStructure.CONSTRAINTS, PddlStructure.METRIC];
/* ACTION KEYWORDS */
PddlStructure.PARAMETERS = ':parameters';
PddlStructure.PRECONDITION = ':precondition';
PddlStructure.EFFECT = ':effect';
PddlStructure.PDDL_ACTION_SECTIONS = [PddlStructure.PARAMETERS, PddlStructure.PRECONDITION, PddlStructure.EFFECT];
/* DURATIVE-ACTION KEYWORDS */
PddlStructure.DURATION = ':duration';
PddlStructure.CONDITION = ':condition';
PddlStructure.PDDL_DURATIVE_ACTION_SECTIONS = [PddlStructure.PARAMETERS, PddlStructure.DURATION, PddlStructure.CONDITION, PddlStructure.EFFECT];

},{"./PddlTokenizer":54}],51:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlBracketNode = exports.PddlSyntaxNode = void 0;
const PddlTokenizer_1 = require("./PddlTokenizer");
/** Single node in the syntax tree that wraps one PDDL tokenizer token. */
class PddlSyntaxNode extends PddlTokenizer_1.TextRange {
    /**
     * Creates the syntax tree node.
     * @param token pddl token wrapped by this node
     * @param parent parent node, unless this is the root node
     */
    constructor(token, parent) {
        super();
        this.token = token;
        this.parent = parent;
        this.children = new Array();
        if (parent === undefined) {
            if (token.type !== PddlTokenizer_1.PddlTokenType.Document) {
                throw new Error(`Node of type ${token.type} must have parent defined.`);
            }
        }
        this.maxChildEnd = token.getEnd();
    }
    static createRoot() {
        return new PddlSyntaxNode(new PddlTokenizer_1.PddlToken(PddlTokenizer_1.PddlTokenType.Document, '', 0), undefined);
    }
    isRoot() {
        return this.parent === undefined;
    }
    getParent() {
        return this.parent;
    }
    isLeaveBracket() {
        return this.getNestedChildren().every(child => child.isNotType(PddlTokenizer_1.PddlTokenType.OpenBracket));
    }
    getToken() {
        return this.token;
    }
    addChild(childNode) {
        this.children.push(childNode);
        this.recalculateEnd(childNode);
    }
    recalculateEnd(childNode) {
        this.maxChildEnd = Math.max(this.maxChildEnd, childNode.getEnd());
        if (this.parent) {
            this.parent.recalculateEnd(this);
        }
    }
    getChildren() {
        return this.children;
    }
    getNestedChildren() {
        return this.getChildren();
    }
    getSingleChild() {
        if (this.getNestedChildren().length !== 1) {
            throw new Error(`Failed assertion that node '${this.getText()}' has a single child.`);
        }
        return this.getNestedChildren()[0];
    }
    getNonWhitespaceChildren() {
        return this.getNestedChildren().filter(c => c.getToken().type !== PddlTokenizer_1.PddlTokenType.Whitespace);
    }
    getNonWhitespaceNonCommentChildren() {
        return this.getNonWhitespaceChildren().filter(c => c.getToken().type !== PddlTokenizer_1.PddlTokenType.Comment);
    }
    getSingleNonWhitespaceChild() {
        const nonWhitespaceChildren = this.getNonWhitespaceChildren();
        if (nonWhitespaceChildren.length !== 1) {
            throw new Error(`Failed assertion that node '${this.toString()}' has a single non-whitespace child.`);
        }
        return nonWhitespaceChildren[0];
    }
    getChildrenOfType(type, pattern) {
        return this.children.filter(c => c.getToken().type === type)
            .filter(node => node.getToken().tokenText.match(pattern));
    }
    getFirstChild(type, pattern) {
        return this.children.filter(c => c.getToken().type === type)
            .find(node => node.getToken().tokenText.match(pattern));
    }
    getFirstChildOrThrow(type, pattern) {
        const matchingChild = this.getFirstChild(type, pattern);
        if (!matchingChild) {
            throw new Error(`No child element of type ${type} satisfying pattern ${pattern.source}.`);
        }
        return matchingChild;
    }
    getFirstOpenBracket(keyword) {
        return this.getFirstChild(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, new RegExp('\\(\\s*' + keyword + '$', 'i'));
    }
    getFirstOpenBracketOrThrow(keyword) {
        const matchingNode = this.getFirstOpenBracket(keyword);
        if (!matchingNode) {
            throw new Error(`No child '${keyword}' open bracket.`);
        }
        return matchingNode;
    }
    getChildrenRecursively(test, callback) {
        this.getNestedChildren().forEach(child => {
            try {
                if (test(child)) {
                    callback(child);
                }
            }
            catch (_e) {
                // swallow
            }
            finally {
                child.getChildrenRecursively(test, callback);
            }
        });
    }
    /**
     * Finds the bracket nested inside the `:keyword`.
     * @param keyword keyword name e.g. 'precondition' to match ':precondition (*)'
     */
    getKeywordOpenBracket(keyword) {
        const keywordNode = this.getFirstChild(PddlTokenizer_1.PddlTokenType.Keyword, new RegExp(":" + keyword + "$", "i"));
        if (!keywordNode) {
            return undefined;
        }
        const bracket = keywordNode.getNonWhitespaceChildren().find(child => (0, PddlTokenizer_1.isOpenBracket)(child.getToken()));
        if (bracket) {
            return bracket;
        }
        else {
            return undefined;
        }
    }
    /**
     * Get all keyword open brackets e.g. `(:action ...)`
     * @param keyword keyword name e.g. `action` to match `(:action ...)`
     */
    getKeywordOpenBrackets(keyword) {
        return this.getChildrenOfType(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, new RegExp("\\(\\s*:" + keyword + "$"))
            .map(node => node);
    }
    hasChildren() {
        return this.getNestedChildren().length > 0;
    }
    getNestedText() {
        let nestedText = '';
        this.getNestedChildren()
            .forEach(node => { nestedText = nestedText + node.getText(); });
        return nestedText;
    }
    getNestedNonCommentText() {
        let nestedText = '';
        this.getNestedChildren()
            .filter(node => node.isNotType(PddlTokenizer_1.PddlTokenType.Comment))
            .forEach(node => { nestedText = nestedText + node.getNonCommentText(); });
        return nestedText;
    }
    getText() {
        return this.getToken().tokenText + this.getNestedText();
    }
    getNonCommentText() {
        if (this.isNotType(PddlTokenizer_1.PddlTokenType.Comment)) {
            return this.getToken().tokenText + this.getNestedNonCommentText();
        }
        else {
            return '';
        }
    }
    getStart() {
        return this.token.getStart();
    }
    getEnd() {
        return this.maxChildEnd;
    }
    /** @returns number of characters in this node (including its children) */
    get length() {
        return this.getEnd() - this.getStart();
    }
    findAncestor(type, pattern) {
        let parent = this.parent;
        while (parent && parent.isNotType(PddlTokenizer_1.PddlTokenType.Document)) {
            if (parent.isType(type) && pattern.test(parent.getToken().tokenText)) {
                return parent;
            }
            parent = parent.parent;
        }
        return undefined;
    }
    getAncestors(includeTypes, pattern = /.*/) {
        const ancestors = [];
        let parent = this.parent;
        while (parent && parent.isNotType(PddlTokenizer_1.PddlTokenType.Document)) {
            if (parent.isAnyOf(includeTypes) && pattern.test(parent.getToken().tokenText)) {
                ancestors.push(parent);
            }
            parent = parent.parent;
        }
        return ancestors;
    }
    findParametrisableScope(parameterName) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let node = this;
        while (!node.isDocument()) {
            node = PddlSyntaxNode.findParametrisableAncestor(node);
            if (!node) {
                return this.getParent();
            }
            else if (node.declaresParameter(parameterName)) {
                return node;
            }
        }
        return undefined;
    }
    findAllParametrisableScopes() {
        const scopes = [];
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let node = this;
        while (node && !node.isDocument()) {
            node = PddlSyntaxNode.findParametrisableAncestor(node);
            if (node) {
                scopes.push(node);
            }
        }
        return scopes;
    }
    static findParametrisableAncestor(node) {
        return node.findAncestor(PddlTokenizer_1.PddlTokenType.OpenBracketOperator, /^\(\s*(:action|:durative-action|:process|:event|:derived|forall|sumall|exists)$/);
    }
    getParameterDefinition() {
        if (this.getToken().tokenText.match(/:action|:durative-action|:process|:event/)) {
            // this node is expected to have a :parameters keyword
            return this.getKeywordOpenBracket('parameters');
        }
        else {
            // this node is expected to have parameters defined inside parentheses
            const nonWhitespaceChildren = this.getNonWhitespaceChildren();
            if (nonWhitespaceChildren.length === 0) {
                return undefined;
            }
            const firstChild = nonWhitespaceChildren[0];
            if (!(0, PddlTokenizer_1.isOpenBracket)(firstChild.getToken())) {
                return undefined;
            }
            return firstChild;
        }
    }
    /**
     * Checks whether this scope node defines given parameter.
     * @param parameterName parameter name without the `?` sign
     */
    declaresParameter(parameterName) {
        const parametersNode = this.getParameterDefinition();
        const parameterDefinition = parametersNode && parametersNode.getNestedText();
        const pattern = new RegExp("\\?" + parameterName + "\\b");
        return (parameterDefinition !== undefined) && pattern.test(parameterDefinition);
    }
    /**
     * Expands to the encompassing bracket pair, unless this node is the top level Document node.
     */
    expand() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let node = this;
        while (node && !(0, PddlTokenizer_1.isOpenBracket)(node.getToken()) && !node.isDocument()) {
            const parentNode = node.getParent();
            if (parentNode !== undefined) {
                node = parentNode;
            }
            else {
                break;
            }
        }
        return node;
    }
    /**
     * Gets all preceding siblings (in order of appearance, not backwards)
     * @param type node type filter
     * @param centralNode optional node from which the siblings are split to preceding/following (by default this node is `this` node)
     */
    getPrecedingSiblings(type, centralNode) {
        const siblings = this.getSiblings(type);
        const centralNodeStart = (centralNode !== null && centralNode !== void 0 ? centralNode : this).getStart();
        const precedingSiblings = siblings.filter(sibling => sibling.getStart() < centralNodeStart);
        return precedingSiblings;
    }
    /**
     * Gets all following siblings
     * @param type node type filter
     * @param centralNode optional node from which the siblings are split to preceding/following (by default this node is `this` node)
     */
    getFollowingSiblings(type, centralNode) {
        const siblings = this.getSiblings(type);
        const centralNodeStart = (centralNode !== null && centralNode !== void 0 ? centralNode : this).getStart();
        const followingSiblings = siblings.filter(sibling => sibling.getStart() > centralNodeStart);
        return followingSiblings;
    }
    /**
     * Gets the just preceding sibling, or `undefined`, if none.
     * @param type node type filter
     * @param centralNode optional node from which the siblings are split to preceding/following (by default this node is `this` node)
     */
    getPrecedingSibling(type, centralNode) {
        const precedingSiblings = this.getPrecedingSiblings(type, centralNode);
        if (precedingSiblings.length > 0) {
            return precedingSiblings[precedingSiblings.length - 1];
        }
        else {
            return undefined;
        }
    }
    /**
     * Gets the just following sibling, or `undefined`, if none.
     * @param type node type filter
     * @param centralNode optional node from which the siblings are split to preceding/following (by default this node is `this` node)
     */
    getFollowingSibling(type, centralNode) {
        const followingSiblings = this.getFollowingSiblings(type, centralNode);
        if (followingSiblings.length > 0) {
            return followingSiblings[0];
        }
        else {
            return undefined;
        }
    }
    /**
     * Gets the siblings of this node.
     * @param type optional node type filter
     * @param centralNode optional node from which the siblings are split to preceding/following (by default this node is `this` node)
     */
    getSiblings(type, pattern = /.*/) {
        var _a, _b, _c, _d;
        if (this.isRoot()) {
            return [];
        }
        if (type) {
            return (_b = (_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.getChildrenOfType(type, pattern)) !== null && _b !== void 0 ? _b : [];
        }
        else {
            return (_d = (_c = this.getParent()) === null || _c === void 0 ? void 0 : _c.getChildren().filter(node => node.getToken().tokenText.match(pattern))) !== null && _d !== void 0 ? _d : [];
        }
    }
    isDocument() {
        return this.isType(PddlTokenizer_1.PddlTokenType.Document);
    }
    isType(type) {
        return this.getToken().type === type;
    }
    isNotType(type) {
        return this.getToken().type !== type;
    }
    isAnyOf(types) {
        return types.includes(this.getToken().type);
    }
    isNoneOf(types) {
        return !this.isAnyOf(types);
    }
    isNumericExpression() {
        return ['(=', '(>', '(<', '(>=', '(<=', '(+', '(-', '(/', '(*'].includes(this.getToken().tokenText.replace(' ', ''));
    }
    isLogicalExpression() {
        return ['(and', '(or', '(not'].includes(this.getToken().tokenText.replace(' ', ''));
    }
    isTemporalExpression() {
        return ['(at start', '(at end', '(over all'].includes(this.getToken().tokenText.replace(/  /g, ' '));
    }
    toString() {
        return `${this.token.type}: text: '${this.token.tokenText.split(/\r?\n/).join('\\n')}', range: ${this.getStart()}~${this.getEnd()}}`;
    }
}
exports.PddlSyntaxNode = PddlSyntaxNode;
/** Specialized tree node for open/close bracket pair. */
class PddlBracketNode extends PddlSyntaxNode {
    constructor() {
        super(...arguments);
        this._isClosed = false;
    }
    /**
     * Sets the bracket close token.
     * @param token pddl bracket close token
     */
    setCloseBracket(token) {
        this._isClosed = true;
        this.closeToken = token;
        this.addChild(new PddlSyntaxNode(token, this));
        this.recalculateEnd(token);
    }
    getCloseBracket() {
        return this.closeToken;
    }
    get isClosed() {
        return this._isClosed;
    }
    getNestedChildren() {
        return this.getChildren()
            .filter(child => child.getToken() !== this.closeToken);
    }
    getText() {
        var _a, _b;
        return super.getText() + ((_b = (_a = this.closeToken) === null || _a === void 0 ? void 0 : _a.tokenText) !== null && _b !== void 0 ? _b : '');
    }
    getNonCommentText() {
        var _a, _b;
        return super.getNonCommentText() + ((_b = (_a = this.closeToken) === null || _a === void 0 ? void 0 : _a.tokenText) !== null && _b !== void 0 ? _b : '');
    }
}
exports.PddlBracketNode = PddlBracketNode;

},{"./PddlTokenizer":54}],52:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlSyntaxTree = void 0;
const PddlSyntaxNode_1 = require("./PddlSyntaxNode");
/** Represents a syntax tree of a PDDL document. */
class PddlSyntaxTree {
    constructor() {
        this.root = PddlSyntaxNode_1.PddlSyntaxNode.createRoot();
    }
    getRootNode() {
        return this.root;
    }
    /**
     * Finds the node at given index in the document text.
     * @param symbolIndex index in the document text, where the node is located
     */
    getNodeAt(symbolIndex) {
        return this.getChildNodeAt(this.root, symbolIndex);
    }
    getChildNodeAt(parent, symbolIndex) {
        if (!parent.includesIndex(symbolIndex)) {
            throw new Error(`Index ${symbolIndex} is not included in the scope of ${parent.toString()}.`);
        }
        if (!parent.hasChildren()) {
            return parent;
        }
        else if (parent.getToken().includesIndex(symbolIndex)) {
            return parent;
        }
        else {
            // todo: use binary search among children
            const firstMatchingChild = parent.getChildren().find(node => node.includesIndex(symbolIndex));
            if (!firstMatchingChild) {
                throw new Error("Assertion failed: there should be a child at index: " + symbolIndex);
            }
            return this.getChildNodeAt(firstMatchingChild, symbolIndex);
        }
    }
    getDefineNode() {
        return this.getRootNode().getFirstOpenBracket('define');
    }
    getDefineNodeOrThrow() {
        return this.getRootNode().getFirstOpenBracketOrThrow('define');
    }
}
exports.PddlSyntaxTree = PddlSyntaxTree;
PddlSyntaxTree.EMPTY = new PddlSyntaxTree();

},{"./PddlSyntaxNode":51}],53:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PddlSyntaxTreeBuilder = void 0;
const PddlTokenizer_1 = require("./PddlTokenizer");
const PddlSyntaxTree_1 = require("./PddlSyntaxTree");
const PddlSyntaxNode_1 = require("./PddlSyntaxNode");
/** Builds a syntax tree from PDDL syntax tokens. */
class PddlSyntaxTreeBuilder {
    constructor(pddlText, symbolIndex) {
        this.symbolIndex = symbolIndex;
        this.offendingTokens = [];
        this.tree = new PddlSyntaxTree_1.PddlSyntaxTree();
        this.currentLeaf = this.tree.getRootNode();
        // tslint:disable-next-line:no-unused-expression
        new PddlTokenizer_1.PddlTokenizer(pddlText, token => this.onToken(token), symbolIndex);
    }
    getBreadcrumbs(symbolIndex) {
        const breadcrumbs = [];
        let nodeAtIndex = symbolIndex === undefined ? this.currentLeaf : this.tree.getNodeAt(symbolIndex);
        do {
            breadcrumbs.push(nodeAtIndex.getToken());
            nodeAtIndex = nodeAtIndex.getParent();
        } while (nodeAtIndex);
        return breadcrumbs.reverse();
    }
    getTree() {
        return this.tree;
    }
    getOffendingTokens() {
        return this.offendingTokens;
    }
    getTreeAsString() {
        return this.getNodeAsString(this.tree.getRootNode());
    }
    getNodeAsString(node) {
        const childrenAsString = node.getChildren().map(c => this.getNodeAsString(c));
        return [node.toString()].concat(childrenAsString.map(s => this.indent(s))).join('\n');
    }
    indent(s) {
        return s.split('\n').map(line => "  " + line).join('\n');
    }
    onToken(token) {
        if (this.symbolIndex && (token.getStart() > this.symbolIndex)) {
            return;
        }
        switch (token.type) {
            case PddlTokenizer_1.PddlTokenType.Keyword:
                this.closeKeyword();
                this.addChild(token);
                break;
            case PddlTokenizer_1.PddlTokenType.CloseBracket:
                this.closeBracket(token);
                break;
            default:
                if (this.inLeaf()) {
                    this.closeCurrentSibling();
                }
                this.addChild(token);
                break;
        }
    }
    closeCurrentSibling() {
        const parent = this.currentLeaf.getParent();
        if (parent) {
            this.currentLeaf = parent && parent;
        }
        else {
            throw new Error("Assertion error: closing a leaf node that has no parent.");
        }
    }
    addChild(token) {
        const newChild = (0, PddlTokenizer_1.isOpenBracket)(token) ?
            new PddlSyntaxNode_1.PddlBracketNode(token, this.currentLeaf) :
            new PddlSyntaxNode_1.PddlSyntaxNode(token, this.currentLeaf);
        this.currentLeaf.addChild(newChild);
        this.currentLeaf = newChild;
    }
    isInLeafOfType(expectedTypes) {
        const actualType = this.currentLeaf.getToken().type;
        return expectedTypes.includes(actualType);
    }
    inLeaf() {
        return this.isInLeafOfType([PddlTokenizer_1.PddlTokenType.Comment,
            PddlTokenizer_1.PddlTokenType.Other,
            PddlTokenizer_1.PddlTokenType.Parameter,
            PddlTokenizer_1.PddlTokenType.Dash,
            PddlTokenizer_1.PddlTokenType.Whitespace]);
    }
    closeBracket(closeBracketToken) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const openBracketNode = this.closeSibling(token => (0, PddlTokenizer_1.isOpenBracket)(token), _ => false);
        if (openBracketNode) {
            openBracketNode.setCloseBracket(closeBracketToken);
        }
        else {
            this.offendingTokens.push(closeBracketToken);
        }
    }
    closeKeyword() {
        this.closeSibling(token => token.type === PddlTokenizer_1.PddlTokenType.Keyword, token => (0, PddlTokenizer_1.isOpenBracket)(token));
    }
    closeSibling(isSibling, isParent) {
        // exit out of the other nested token(s)
        while (!isSibling(this.currentLeaf.getToken()) && !isParent(this.currentLeaf.getToken())) {
            if (this.currentLeaf.getParent() === undefined) {
                return undefined;
            }
            else {
                this.closeCurrentSibling();
            }
        }
        // exit out the parent token
        if (isSibling(this.currentLeaf.getToken()) && !isParent(this.currentLeaf.getToken())) {
            const sibling = this.currentLeaf;
            this.closeCurrentSibling();
            return sibling;
        }
        else {
            return undefined;
        }
    }
}
exports.PddlSyntaxTreeBuilder = PddlSyntaxTreeBuilder;

},{"./PddlSyntaxNode":51,"./PddlSyntaxTree":52,"./PddlTokenizer":54}],54:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isOpenBracket = exports.PddlTokenizer = exports.PddlToken = exports.TextRange = exports.PddlTokenType = void 0;
var PddlTokenType;
(function (PddlTokenType) {
    /** Open bracket with the operator name, e.g. `(+` or `(:action` or `(increase` */
    PddlTokenType["OpenBracketOperator"] = "OPEN_BRACKET_OPERATOR";
    /** Open bracket `(` */
    PddlTokenType["OpenBracket"] = "OPEN_BRACKET";
    /** Close bracket `)` */
    PddlTokenType["CloseBracket"] = "CLOSE_BRACKET";
    /** Keyword e.g. `:parameters` or `:effect` */
    PddlTokenType["Keyword"] = "KEYWORD";
    /** Dash character. */
    PddlTokenType["Dash"] = "DASH";
    /** Parameter name e.g. `?p1`. */
    PddlTokenType["Parameter"] = "PARAMETER";
    /** Vertical or horizontal whitespace. */
    PddlTokenType["Whitespace"] = "WHITESPACE";
    /** Other unclassified token. */
    PddlTokenType["Other"] = "OTHER";
    /** Comment i.e. anything after `;`, including the semicolon */
    PddlTokenType["Comment"] = "COMMENT";
    /** Document is the root node type. */
    PddlTokenType["Document"] = "DOCUMENT";
})(PddlTokenType = exports.PddlTokenType || (exports.PddlTokenType = {}));
class TextRange {
    includesIndex(symbolIndex) {
        if (symbolIndex < this.getStart()) {
            return false;
        }
        if (this.getEnd() === undefined) {
            return true;
        }
        else {
            return symbolIndex <= this.getEnd();
        }
    }
}
exports.TextRange = TextRange;
/** PDDL syntax token. */
class PddlToken extends TextRange {
    /**
     * Constructs.
     * @param type token type
     * @param tokenText token content
     * @param start first character of the token
     */
    constructor(type, tokenText, start) {
        super();
        this.type = type;
        this.tokenText = tokenText;
        this.start = start;
        this.end = start + tokenText.length;
    }
    /**
     * Creates token from a regex match result.
     * @param type token type
     * @param match regex match
     */
    static from(type, match) {
        return new PddlToken(type, match[0], match.index);
    }
    getStart() {
        return this.start;
    }
    getEnd() {
        return this.end;
    }
    toString() {
        return `PddlToken{type: ${this.type}, text: '${this.tokenText}', range: ${this.start}~${this.end}}`;
    }
}
exports.PddlToken = PddlToken;
/** Tokenizes PDDL documents. */
class PddlTokenizer {
    /**
     * Starts tokenizing.
     * @param pddlText input PDDL text
     * @param callback callback to call when a new token is encountered
     * @param lastIndexOfInterest last index of interest or `undefined` to parse the entire document
     */
    constructor(pddlText, callback, lastIndexOfInterest) {
        const pddlPattern = /\(\s*(:\w[\w-]*|[-\/+*]|[><]=?|define|domain|problem|and|or|not|at start|at end|over all|at|=|assign|increase|decrease|always|sometime|forall|exists|when|within|at-most-once|sometime-before|always-within|supply-demand)(?!-)|\(|:[\w-]+|\(|\)|;|\?\w[\w-]*|[-+]?[0-9]*\.?[0-9]+|-|#t|\w[\w-]*|[\s]+/g;
        const endOfLinePattern = /(\n|\r\n)/g;
        let endOfLastToken = 0;
        lastIndexOfInterest = lastIndexOfInterest === undefined ? Number.MAX_SAFE_INTEGER : lastIndexOfInterest;
        let match;
        while (match = pddlPattern.exec(pddlText)) {
            if (match.index > endOfLastToken) {
                callback(new PddlToken(PddlTokenType.Other, pddlText.substring(endOfLastToken, match.index), endOfLastToken));
            }
            let commentLength = 0;
            if (match[0] === '-') {
                callback(PddlToken.from(PddlTokenType.Dash, match));
            }
            else if (match[0] === '(') {
                callback(PddlToken.from(PddlTokenType.OpenBracket, match));
            }
            else if (match[0].startsWith('(')) {
                callback(PddlToken.from(PddlTokenType.OpenBracketOperator, match));
            }
            else if (match[0].match(/^\)$/)) {
                callback(PddlToken.from(PddlTokenType.CloseBracket, match));
            }
            else if (match[0].match(/\?\w[\w-]*$/)) {
                callback(PddlToken.from(PddlTokenType.Parameter, match));
            }
            else if (match[0].match(/^:[\w-]+$/)) {
                callback(PddlToken.from(PddlTokenType.Keyword, match));
            }
            else if (match[0].startsWith(';')) {
                // this is where a comment starts
                endOfLinePattern.lastIndex = match.index + 1;
                const endOfLineMatch = endOfLinePattern.exec(pddlText);
                if (endOfLineMatch) {
                    // end of line found
                    commentLength = endOfLineMatch.index - match.index;
                }
                else {
                    // the file(!) ends on this comment line
                    commentLength = pddlText.length - match.index;
                }
                // extract the comment text
                const comment = pddlText.substr(match.index, commentLength);
                callback(new PddlToken(PddlTokenType.Comment, comment, match.index));
                pddlPattern.lastIndex = match.index + commentLength;
            }
            else if (match[0].match(/^[\s]+$/)) {
                // this is whitespace
                callback(PddlToken.from(PddlTokenType.Whitespace, match));
            }
            else {
                callback(PddlToken.from(PddlTokenType.Other, match));
            }
            endOfLastToken = match.index + match[0].length +
                (commentLength ? commentLength - 1 : 0);
            if (pddlPattern.lastIndex > lastIndexOfInterest) {
                break;
            }
        }
    }
}
exports.PddlTokenizer = PddlTokenizer;
function isOpenBracket(token) {
    return token.type === PddlTokenType.OpenBracketOperator || token.type === PddlTokenType.OpenBracket;
}
exports.isOpenBracket = isOpenBracket;

},{}],55:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlanHappeningsBuilder = void 0;
const FileInfo_1 = require("../FileInfo");
const HappeningsInfo_1 = require("../HappeningsInfo");
const DocumentPositionResolver_1 = require("../DocumentPositionResolver");
/**
 * Builds the list of happenings while validating the sequence.
 */
class PlanHappeningsBuilder {
    constructor(epsilon) {
        this.epsilon = epsilon;
        // all happenings parsed thus far
        this.happenings = [];
        // parsing problems to report
        this.parsingProblems = [];
        // plan makespan thus far
        this.makespan = 0;
        // open actions (action starts that were not matched with an end yet)
        this.openActions = [];
        this.happeningPattern = /^\s*((\d+|\d+\.\d+|\.\d+)\s*:)?\s*(start|end)?\s*\(([\w -]+)\)\s*(#\d+)?\s*(;.*)?\s*$/;
        this.whiteSpacePattern = /^\s*(;.*)?\s*$/;
    }
    tryParseFile(fileText) {
        fileText.split('\n')
            .forEach((planLine, index) => {
            if (!this.isWhiteSpace(planLine)) {
                this.tryParse(planLine, index);
            }
        });
    }
    isWhiteSpace(planLine) {
        this.whiteSpacePattern.lastIndex = 0;
        return this.whiteSpacePattern.exec(planLine) !== null;
    }
    tryParse(planLine, lineIndex) {
        const happening = this.parse(planLine, lineIndex);
        if (happening) {
            this.add(happening);
        }
        else {
            this.parsingProblems.push(new FileInfo_1.ParsingProblem(`Invalid happening syntax: ${planLine}`, "error", DocumentPositionResolver_1.PddlRange.createFullLineRange(lineIndex !== null && lineIndex !== void 0 ? lineIndex : 0)));
        }
    }
    /**
     * Parses single line of plan text.
     * @param planLine line of plan text
     * @param lineIndex line number
     */
    parse(planLine, lineIndex) {
        this.happeningPattern.lastIndex = 0;
        const group = this.happeningPattern.exec(planLine);
        if (group) {
            // this line is a valid plan happening
            const time = group[2] ? parseFloat(group[2]) : this.getMakespan() + this.epsilon;
            const type = this.parseType(group[3]);
            const action = group[4];
            const counter = group[5] ? parseInt(group[5].substring(1)) : 0;
            return new HappeningsInfo_1.Happening(time, type, action, counter, lineIndex);
        }
        else {
            return undefined;
        }
    }
    add(happening) {
        var _a, _b, _c;
        switch (happening.getType()) {
            case HappeningsInfo_1.HappeningType.START:
                const alreadyExistingStart = this.openActions.concat(this.happenings).find(happening1 => happening1.getType() === HappeningsInfo_1.HappeningType.START
                    && happening1.belongsTo(happening));
                if (alreadyExistingStart) {
                    this.parsingProblems.push(new FileInfo_1.ParsingProblem(`A happening matching ${happening.toString()} is already in the plan. Increase the #N counter.`, "error", DocumentPositionResolver_1.PddlRange.createFullLineRange((_a = happening.lineIndex) !== null && _a !== void 0 ? _a : 0)));
                }
                this.openActions.push(happening);
                break;
            case HappeningsInfo_1.HappeningType.END:
                // there must be an open start
                const matchingStart = this.openActions.find(start => start.belongsTo(happening));
                if (matchingStart) {
                    this.openActions.splice(this.openActions.indexOf(matchingStart), 1);
                }
                else {
                    this.parsingProblems.push(new FileInfo_1.ParsingProblem(`There is no start corresponding to ${happening.toString()}`, "error", DocumentPositionResolver_1.PddlRange.createFullLineRange((_b = happening.lineIndex) !== null && _b !== void 0 ? _b : 0)));
                }
                break;
        }
        // adjust the plan makespan
        if (this.makespan < happening.getTime()) {
            this.makespan = happening.getTime();
        }
        else if (this.makespan > happening.getTime()) {
            this.parsingProblems.push(new FileInfo_1.ParsingProblem(`Time must not go backwards.`, "warning", DocumentPositionResolver_1.PddlRange.createFullLineRange((_c = happening.lineIndex) !== null && _c !== void 0 ? _c : 0)));
        }
        this.happenings.push(happening);
    }
    validateOpenQueueIsEmpty() {
        const problems = this.openActions
            .map(start => {
            var _a;
            return new FileInfo_1.ParsingProblem(`Missing end of ${start.toString()}`, "error", DocumentPositionResolver_1.PddlRange.createFullLineRange((_a = start.lineIndex) !== null && _a !== void 0 ? _a : 0));
        });
        this.parsingProblems.push(...problems);
    }
    getHappenings() {
        return this.happenings;
    }
    getMakespan() {
        return this.makespan;
    }
    getParsingProblems() {
        return this.parsingProblems;
    }
    parseType(typeAsString) {
        switch (typeAsString) {
            case "start":
                return HappeningsInfo_1.HappeningType.START;
            case "end":
                return HappeningsInfo_1.HappeningType.END;
            case undefined:
                return HappeningsInfo_1.HappeningType.INSTANTANEOUS;
            default:
                throw new Error(`Unexpected happening type: ${typeAsString}`);
        }
    }
}
exports.PlanHappeningsBuilder = PlanHappeningsBuilder;

},{"../DocumentPositionResolver":15,"../FileInfo":17,"../HappeningsInfo":19}],56:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlanValuesParser = void 0;
class StateValues {
    constructor(time) {
        this.time = time;
        this.values = new Map();
    }
    setValue(functionName, value) {
        this.values.set(functionName, value);
    }
    getValue(functionName) {
        var _a;
        return (_a = this.values.get(functionName)) !== null && _a !== void 0 ? _a : Number.NaN;
    }
}
class PlanValuesParser {
    constructor(steps, functions, actionFunctionValues) {
        this.steps = steps;
        this.functions = functions;
        this.stateValues = [];
        if (steps.length !== actionFunctionValues.length) {
            throw new Error("Plan steps and action values do not correspond.");
        }
        steps.forEach((planStep, idx) => {
            var _a;
            const planStepFunctionValues = actionFunctionValues[idx].split(',');
            if (!this.describesInstantaneousAction(planStepFunctionValues)
                && !this.describesDurativeAction(planStepFunctionValues)) {
                throw new Error("Wrong number of values on in the output: " + actionFunctionValues[idx]);
            }
            if (planStep.fullActionName !== planStepFunctionValues[0]) {
                throw new Error("Action name does not match the one in the plan: " + actionFunctionValues[idx]);
            }
            this.addState(planStep.getStartTime(), planStepFunctionValues.slice(1, 1 + functions.length));
            if (this.describesDurativeAction(planStepFunctionValues)) {
                this.addState(planStep.getStartTime() + ((_a = planStep.getDuration()) !== null && _a !== void 0 ? _a : 1e-3), planStepFunctionValues.slice(1 + functions.length));
            }
        });
        this.stateValues = this.stateValues.sort((s1, s2) => s1.time - s2.time);
    }
    describesInstantaneousAction(planStepFunctionValues) {
        return this.compareCsvTermsToFunctionCount(planStepFunctionValues, 1);
    }
    describesDurativeAction(planStepFunctionValues) {
        return this.compareCsvTermsToFunctionCount(planStepFunctionValues, 2);
    }
    compareCsvTermsToFunctionCount(planStepFunctionValues, multiple) {
        return planStepFunctionValues.length === 1 + multiple * this.functions.length;
    }
    addState(time, values) {
        const state = new StateValues(time);
        if (values.length !== this.functions.length) {
            throw new Error(`Expecting number of values (${values}) to match number of functions ${this.functions.length}.`);
        }
        for (let index = 0; index < values.length; index++) {
            const valueAsString = values[index];
            const value = parseFloat(valueAsString);
            state.setValue(this.functions[index].getFullName(), value);
        }
        this.stateValues.push(state);
    }
    getSingleFunctionValues(functionName) {
        return this.stateValues.map(state => [state.time, state.getValue(functionName)]);
    }
    getValues(functionName) {
        const functions = this.functions.filter(f => f.name === functionName);
        return this.stateValues.map(state => this.getStateValues(functions, state));
    }
    getStateValues(groundedFunctions, state) {
        const values = [state.time];
        groundedFunctions.forEach(function1 => values.push(state.getValue(function1.getFullName())));
        return values;
    }
}
exports.PlanValuesParser = PlanValuesParser;

},{}],57:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VariablesParser = exports.parseParameters = void 0;
const language_1 = require("../language");
const PddlTokenizer_1 = require("./PddlTokenizer");
const DocumentPositionResolver_1 = require("../DocumentPositionResolver");
const util_1 = require("../utils/util");
function parseParameters(fullSymbolName) {
    const parameterPattern = /((\?[\w][\w-]*\s+)+)-\s+([\w][\w-]*)/g;
    const parameters = [];
    let group;
    while (group = parameterPattern.exec(fullSymbolName)) {
        const variables = group[1];
        const type = group[3];
        variables.split(/(\s+)/)
            .filter(term => term.trim().length)
            .map(variable => variable.substr(1).trim()) // skip the question-mark
            .forEach(variable => parameters.push(new language_1.Parameter(variable, type)));
    }
    return parameters;
}
exports.parseParameters = parseParameters;
/** Parses the `:predicates` and `:functions` section. */
class VariablesParser {
    constructor(predicatesNode, positionResolver) {
        this.positionResolver = positionResolver;
        this.variables = new Array();
        this.chunks = new Array();
        this.currentVariableNodes = new Array();
        this.variableNodeEncountered = false;
        this.consecutiveVerticalWhitespaceCount = 0;
        // first split the list of children to chunks describing one variable
        this.chunkByVerticalWhitespace(predicatesNode);
        this.variables = util_1.Util.flatMap(this.chunks.map(chunk => this.processChunk(chunk)));
    }
    chunkByVerticalWhitespace(predicatesNode) {
        for (const node of predicatesNode.getNestedChildren()) {
            if (node.getToken().type === PddlTokenizer_1.PddlTokenType.Whitespace) {
                const verticalWhitespaceCount = node.getText().split(/\r?\n/).length - 1;
                // did we encountered end of the line AFTER the variable declaration?
                if (verticalWhitespaceCount > 0 && this.variableNodeEncountered) {
                    // this is the end of one variable declaration
                    this.addCurrentVariableChunkAndReset();
                }
                this.consecutiveVerticalWhitespaceCount += verticalWhitespaceCount;
                if (this.consecutiveVerticalWhitespaceCount >= 2) {
                    // empty line encountered, reset
                    this.reset();
                }
            }
            else {
                // reset the EOL counter as this is not a vertical whitespace
                this.consecutiveVerticalWhitespaceCount = 0;
                if ((0, PddlTokenizer_1.isOpenBracket)(node.getToken())) {
                    this.variableNodeEncountered = true;
                }
                this.currentVariableNodes.push(node);
            }
        }
        // push the last chunk
        if (this.currentVariableNodes.length) {
            this.addCurrentVariableChunkAndReset();
        }
    }
    processChunk(chunk) {
        const documentation = new Array();
        const variableNodes = [];
        for (const node of chunk) {
            if (node.isType(PddlTokenizer_1.PddlTokenType.Comment)) {
                const indexOfSemicolon = node.getText().indexOf(';');
                if (indexOfSemicolon > -1) {
                    const textAfterSemicolon = node.getText().substr(indexOfSemicolon + 1).trim();
                    documentation.push(textAfterSemicolon);
                }
            }
            else if ((0, PddlTokenizer_1.isOpenBracket)(node.getToken())) {
                variableNodes.push(node);
            }
        }
        return variableNodes.map(node => this.createVariable(node, documentation));
    }
    createVariable(node, documentation) {
        const fullSymbolName = node.getText().replace(/[\(\)]/g, '');
        const parameters = parseParameters(fullSymbolName);
        const variable = new language_1.Variable(fullSymbolName, parameters);
        variable.setDocumentation(documentation);
        const startPosition = this.positionResolver.resolveToPosition(node.getStart());
        const endPosition = this.positionResolver.resolveToPosition(node.getEnd());
        variable.setLocation(new DocumentPositionResolver_1.PddlRange({ start: startPosition, end: endPosition }));
        return variable;
    }
    addCurrentVariableChunkAndReset() {
        this.chunks.push(this.currentVariableNodes);
        this.reset();
    }
    /** Resets the current variable chunk */
    reset() {
        this.currentVariableNodes = [];
        this.variableNodeEncountered = false;
        this.consecutiveVerticalWhitespaceCount = 0;
    }
    static isVerticalWhitespace(node) {
        return node.getToken().type === PddlTokenizer_1.PddlTokenType.Whitespace
            && /[\r\n]/.test(node.getToken().tokenText);
    }
    getVariables() {
        return this.variables;
    }
}
exports.VariablesParser = VariablesParser;

},{"../DocumentPositionResolver":15,"../language":33,"../utils/util":78,"./PddlTokenizer":54}],58:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlPlanBuilder = void 0;
const PlanStep_1 = require("../PlanStep");
class XmlPlanBuilder {
    constructor(planTimeScale) {
        this.planTimeScale = planTimeScale;
        this.xmlText = '';
    }
    static isXmlStart(outputLine) {
        return outputLine.match(/<\?xml /) !== null;
    }
    appendLine(outputLine) {
        this.xmlText += outputLine;
    }
    isComplete() {
        return this.xmlText.match(/<\/Plan>\s*$/) !== null;
    }
    async getPlanSteps() {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const xml2js = require('xml2js');
        const parser = new xml2js.Parser();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let plan;
        try {
            plan = await parser.parseStringPromise(this.xmlText);
        }
        catch (err) {
            console.log(err);
            throw err;
        }
        const steps = [];
        for (const happening of plan.Plan.Actions[0].OrderedHappening) {
            //const happeningId = happening.HappeningID[0];
            if (happening.Happening[0].ActionStart) {
                const actionStart = happening.Happening[0].ActionStart[0];
                const startTime = this.parseTimeStamp(actionStart.ExpectedStartTime[0]);
                const actionName = actionStart.Name[0];
                const actionParameters = actionStart.Parameters
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    ? ' ' + actionStart.Parameters[0].Parameter.map((p) => p.Symbol[0]).join(' ')
                    : '';
                const isDurative = actionStart.ExpectedDuration !== undefined;
                const duration = isDurative ? this.parseTimeStamp(actionStart.ExpectedDuration[0]) : undefined;
                steps.push(new PlanStep_1.PlanStep(startTime, actionName + actionParameters, isDurative, duration, -1));
            }
        }
        return steps;
    }
    parseTimeStamp(timestamp) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const pxd = require('parse-xsd-duration');
        return pxd.default(timestamp) / this.planTimeScale;
    }
}
exports.XmlPlanBuilder = XmlPlanBuilder;

},{"../PlanStep":27,"parse-xsd-duration":14,"xml2js":86}],59:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./PddlFileParser"), exports);
__exportStar(require("./ActionEffectParser"), exports);
__exportStar(require("./PddlDomainParser"), exports);
__exportStar(require("./PddlProblemParser"), exports);
__exportStar(require("./DurativeActionParser"), exports);
__exportStar(require("./InstantActionParser"), exports);
__exportStar(require("./DerivedVariableParser"), exports);
__exportStar(require("./PddlConstraintsParser"), exports);
__exportStar(require("./PddlInheritanceParser"), exports);
__exportStar(require("./VariablesParser"), exports);
__exportStar(require("./MetricParser"), exports);
__exportStar(require("./NumericExpressionParser"), exports);
__exportStar(require("./PddlSyntaxTreeBuilder"), exports);
__exportStar(require("./PddlSyntaxTree"), exports);
__exportStar(require("./PddlSyntaxNode"), exports);
__exportStar(require("./PddlStructure"), exports);
__exportStar(require("./PddlTokenizer"), exports);
__exportStar(require("./PddlPlanParser"), exports);
__exportStar(require("./PddlPlanBuilder"), exports);
__exportStar(require("./PddlPlannerOutputParser"), exports);
__exportStar(require("./PlanValuesParser"), exports);
__exportStar(require("./NormalizingPddlPlanParser"), exports);
__exportStar(require("./HappeningsParser"), exports);
__exportStar(require("./PlanHappeningsBuilder"), exports);

},{"./ActionEffectParser":34,"./DerivedVariableParser":35,"./DurativeActionParser":36,"./HappeningsParser":37,"./InstantActionParser":38,"./MetricParser":39,"./NormalizingPddlPlanParser":40,"./NumericExpressionParser":41,"./PddlConstraintsParser":42,"./PddlDomainParser":43,"./PddlFileParser":44,"./PddlInheritanceParser":45,"./PddlPlanBuilder":46,"./PddlPlanParser":47,"./PddlPlannerOutputParser":48,"./PddlProblemParser":49,"./PddlStructure":50,"./PddlSyntaxNode":51,"./PddlSyntaxTree":52,"./PddlSyntaxTreeBuilder":53,"./PddlTokenizer":54,"./PlanHappeningsBuilder":55,"./PlanValuesParser":56,"./VariablesParser":57}],60:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2021. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],61:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Planner = void 0;
/**
 * Abstract base class for all planners.
 */
class Planner {
    constructor(plannerPath, plannerConfiguration, providerConfiguration) {
        this.plannerPath = plannerPath;
        this.plannerConfiguration = plannerConfiguration;
        this.providerConfiguration = providerConfiguration;
        this._planningProcessKilled = false;
    }
    /** `true` if the planning run was stopped */
    get planningProcessKilled() {
        return this._planningProcessKilled;
    }
    get requiresKeyboardInput() {
        var _a;
        return (_a = this.plannerConfiguration.requiresKeyboardInput) !== null && _a !== void 0 ? _a : false;
    }
    /** `true` if the planner supports search debugger call-backs */
    get supportsSearchDebugger() {
        var _a;
        return (_a = this.plannerConfiguration.supportsSearchDebugger) !== null && _a !== void 0 ? _a : true;
    }
    stop() {
        this._planningProcessKilled = true;
    }
}
exports.Planner = Planner;

},{}],62:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2021. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],63:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });

},{}],64:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchDebuggerSupportType = void 0;
/** Communication mechanism between the search debugger and the planner. */
var SearchDebuggerSupportType;
(function (SearchDebuggerSupportType) {
    /** Search Debugger not supported. */
    SearchDebuggerSupportType["None"] = "None";
    /** HTTP callback to the port exposed by the Search Debugger. */
    SearchDebuggerSupportType["HttpCallback"] = "HttpCallback";
    /** HTTP Web Socket that the Search Debugger opens after the async request is sent to the planning service. Json format. */
    SearchDebuggerSupportType["WebSocketJson"] = "WebSocketJson";
    /** HTTP Web Socket that the Search Debugger opens after the async request is sent to the planning service. Binary format. */
    SearchDebuggerSupportType["WebSocketBinary"] = "WebSocketBinary";
})(SearchDebuggerSupportType = exports.SearchDebuggerSupportType || (exports.SearchDebuggerSupportType = {}));

},{}],65:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WellKnownPlannerKind = exports.PlannerKind = exports.PlannerRegistrar = void 0;
const utils_1 = require("../utils");
/** Keeps track of planner providers. */
class PlannerRegistrar {
    constructor() {
        this.providers = new PlannerProviderMap();
    }
    /**
     * Extensions should call this method to register their planner wrapper.
     * @param kind planner kind this `provider` supports
     * @param provider planner provider
     */
    registerPlannerProvider(kind, provider) {
        if (this.providers.has(kind)) {
            throw new Error(`Planner provider for kind '${kind.kind}' is already registered.`);
        }
        this.providers.set(kind, provider);
    }
    getPlannerProviders() {
        return this.providers.valueList();
    }
    getPlannerProvider(kind) {
        return this.providers.get(kind);
    }
}
exports.PlannerRegistrar = PlannerRegistrar;
class PlannerKind {
    constructor(kind) {
        this.kind = kind;
    }
    /**
     * Derives a kind of planner implementation/variant.
     * @param implementation implementation/variant name
     * @returns new planner kind
     */
    derive(implementation) {
        return new PlannerKind(this.kind + ':' + implementation);
    }
}
exports.PlannerKind = PlannerKind;
class WellKnownPlannerKind {
}
exports.WellKnownPlannerKind = WellKnownPlannerKind;
WellKnownPlannerKind.EXECUTABLE = new PlannerKind("EXECUTABLE");
WellKnownPlannerKind.JAVA_JAR = new PlannerKind("JAVA_JAR");
WellKnownPlannerKind.NODE_JS_SCRIPT = new PlannerKind("NODE_JS_SCRIPT");
WellKnownPlannerKind.COMMAND = new PlannerKind("COMMAND");
WellKnownPlannerKind.SERVICE_SYNC = new PlannerKind("SERVICE_SYNC");
WellKnownPlannerKind.SERVICE_ASYNC = new PlannerKind("SERVICE_ASYNC");
WellKnownPlannerKind.PLANNING_AS_A_SERVICE = new PlannerKind("PLANNING_AS_A_SERVICE");
WellKnownPlannerKind.PLANNING_AS_A_SERVICE_PREVIEW = new PlannerKind("PLANNING_AS_A_SERVICE_PREVIEW");
class PlannerProviderMap extends utils_1.StringifyingMap {
    stringifyKey(key) {
        return key.kind;
    }
}

},{"../utils":76}],66:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });

},{}],67:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Planner"), exports);
__exportStar(require("./PlannerOptionsProvider"), exports);
__exportStar(require("./PlannerProvider"), exports);
__exportStar(require("./PlannerRegistrar"), exports);
__exportStar(require("./PlannerResponseHandler"), exports);
__exportStar(require("./PlannerExecutableRunConfiguration"), exports);
__exportStar(require("./Authentication"), exports);

},{"./Authentication":60,"./Planner":61,"./PlannerExecutableRunConfiguration":62,"./PlannerOptionsProvider":63,"./PlannerProvider":64,"./PlannerRegistrar":65,"./PlannerResponseHandler":66}],68:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });

},{}],69:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchState = void 0;
/** State generated in the process of the plan search. */
class SearchState {
    /**
     * Search state constructor.
     * @param id state ID (assigned when received from the planner)
     * @param origId original/external state ID (by which the planner refers to it)
     * @param g generation (initial state is gen 0)
     * @param earliestTime earliest time this state may be scheduled
     * @param planHead plan head (list of happening starting from the initial state)
     * @param landmarks number of landmarks encountered up to this state
     * @param parentId parent state id
     * @param actionName action applied to create this state
     */
    constructor(id, origId, g, earliestTime, planHead, landmarks, parentId, actionName) {
        this.id = id;
        this.origId = origId;
        this.g = g;
        this.earliestTime = earliestTime;
        this.planHead = planHead;
        this.landmarks = landmarks;
        this.parentId = parentId;
        this.actionName = actionName;
        /** This state meets the goal criteria and other applicable criteria to represent the end-state of a plan. */
        this.isPlan = false;
        this._isEvaluated = false;
    }
    /** Creates initial search state. */
    static createInitial() {
        return new SearchState(0, "0", 0, 0, [], 0);
    }
    get isEvaluated() {
        return this._isEvaluated;
    }
    /**
     * Records state evaluation.
     * @param h heuristic value
     * @param totalMakespan total plan makespan (plan head plus relaxed plan makespan)
     * @param helpfulActions helpful action list
     * @param relaxedPlan relaxed plan
     */
    evaluate(h, totalMakespan, helpfulActions, relaxedPlan) {
        this.h = h;
        this.totalMakespan = totalMakespan;
        this.helpfulActions = helpfulActions;
        this.relaxedPlan = relaxedPlan;
        this.isDeadEnd = false;
        this._isEvaluated = true;
        return this;
    }
    /**
     * Makes this state a search dead-end.
     */
    setDeadEnd() {
        this.h = Number.POSITIVE_INFINITY;
        this.totalMakespan = Number.POSITIVE_INFINITY;
        this.helpfulActions = [];
        this.relaxedPlan = [];
        this.isDeadEnd = true;
        this._isEvaluated = true;
        return this;
    }
    /**
     * Makes this state trimmed by state memoisation.
     */
    setVisitedOrIsWorse() {
        this.wasVisitedOrIsWorse = true;
        return this;
    }
    /** Returns the plan head, and if present, the actions from the relaxed plan. */
    getTotalPlan() {
        if (this.relaxedPlan) {
            return this.planHead.concat(this.relaxedPlan);
        }
        else {
            return this.planHead;
        }
    }
    toString() {
        return `State={origId: ${this.origId}, G: ${this.g}, Action: ${this.actionName}, O: ${this.id}, Time: ${this.earliestTime}, parent: ${this.parentId} H: ${this.h}, Makespan: ${this.totalMakespan}}`;
    }
}
exports.SearchState = SearchState;

},{}],70:[function(require,module,exports){
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchStateToPlan = void 0;
const __1 = require("..");
const utils_1 = require("../utils");
/** Extracts `Plan` from a `SearchState`. */
class SearchStateToPlan {
    constructor(domain, problem, epsilon = 1e-3) {
        this.domain = domain;
        this.problem = problem;
        this.epsilon = epsilon;
    }
    convert(state) {
        var _a;
        const totalPlan = state.getTotalPlan();
        // all happenings except for ENDs
        const planStepBuilders = totalPlan
            .filter(happening => happening.kind !== __1.HappeningType.END)
            .map(happening => PlanStepBuilder.fromStart(happening));
        // now associate all ends with the corresponding starts
        totalPlan
            .filter(happening => happening.kind === __1.HappeningType.END)
            .forEach(endHappening => SearchStateToPlan.associate(endHappening, planStepBuilders));
        const planSteps = planStepBuilders.map(step => step.toPlanStep(state.earliestTime, this.epsilon));
        const helpfulActions = (_a = state.helpfulActions) !== null && _a !== void 0 ? _a : [];
        return new __1.Plan(planSteps, this.domain, this.problem, state.earliestTime, helpfulActions);
    }
    static associate(endHappening, planSteps) {
        const correspondingStart = planSteps.find(step => step.correspondsToEnd(endHappening) && !step.hasEnd());
        if (!correspondingStart) {
            throw new Error("Cannot find start corresponding to: " + endHappening.actionName);
        }
        correspondingStart.setEnd(endHappening);
    }
}
exports.SearchStateToPlan = SearchStateToPlan;
/** Helps pairing corresponding start and end happenings. */
class PlanStepBuilder {
    constructor(start) {
        this.start = start;
    }
    static fromStart(happening) {
        return new PlanStepBuilder(happening);
    }
    /**
     * Sets corresponding end happening.
     * @param endHappening corresponding end happening
     */
    setEnd(endHappening) {
        this.end = endHappening;
    }
    hasEnd() {
        return !!this.end;
    }
    /**
     * Checks whether the given endHappening corresponds to this start.
     * @param endHappening end happening to test
     */
    correspondsToEnd(endHappening) {
        const matchingName = (0, utils_1.equalsCaseInsensitive)(this.start.actionName, endHappening.actionName);
        if (!matchingName) {
            return false;
        }
        if (endHappening.shotCounter === -1) {
            return this.end === undefined;
        }
        else {
            return this.start.shotCounter === endHappening.shotCounter;
        }
    }
    getIterations() {
        var _a, _b;
        return Math.max(this.start.iterations, (_b = (_a = this.end) === null || _a === void 0 ? void 0 : _a.iterations) !== null && _b !== void 0 ? _b : 1);
    }
    toPlanStep(stateTime, epsilon) {
        const isDurative = this.start.kind === __1.HappeningType.START;
        let duration = epsilon;
        if (isDurative) {
            if (this.end) {
                duration = this.end.earliestTime - this.start.earliestTime;
            }
            else {
                // the end was not set yet (perhaps this was a dead end state and there was no relaxed plan at all)
                duration = stateTime - this.start.earliestTime + stateTime * .1;
            }
        }
        const commitment = this.getCommitment(isDurative);
        return new __1.PlanStep(this.start.earliestTime, this.start.actionName, isDurative, duration, -1, commitment, this.getIterations());
    }
    getCommitment(isDurative) {
        if (this.end && !this.end.isRelaxed) {
            return __1.PlanStepCommitment.Committed;
        }
        else if (!this.start.isRelaxed) {
            if (isDurative) {
                return __1.PlanStepCommitment.EndsInRelaxedPlan;
            }
            else {
                return __1.PlanStepCommitment.Committed;
            }
        }
        else {
            return __1.PlanStepCommitment.StartsInRelaxedPlan;
        }
    }
}

},{"..":32,"../utils":76}],71:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./SearchHappening"), exports);
__exportStar(require("./SearchState"), exports);
__exportStar(require("./SearchStateToPlan"), exports);

},{"./SearchHappening":68,"./SearchState":69,"./SearchStateToPlan":70}],72:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getObjectsInheritingFrom = exports.getTypesInheritingFromPlusSelf = void 0;
const util_1 = require("./utils/util");
function getTypesInheritingFromPlusSelf(type, typeInheritance) {
    return [type].concat(typeInheritance.getSubtreePointingTo(type));
}
exports.getTypesInheritingFromPlusSelf = getTypesInheritingFromPlusSelf;
function getObjectsOfType(allObjects, type) {
    const thisTypeObjects = allObjects.getTypeCaseInsensitive(type);
    return thisTypeObjects ? thisTypeObjects.getObjects() : [];
}
function getObjectsInheritingFrom(allObjects, type, typeInheritance) {
    const subTypes = getTypesInheritingFromPlusSelf(type, typeInheritance);
    const subTypesObjects = subTypes.map(subType => getObjectsOfType(allObjects, subType));
    return util_1.Util.flatMap(subTypesObjects);
}
exports.getObjectsInheritingFrom = getObjectsInheritingFrom;

},{"./utils/util":78}],73:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirectionalGraph = void 0;
/**
 * Simple directional graph.
 */
class DirectionalGraph {
    /**
     * Constructor, optionally copy-constructor.
     * @param verticesAndEdges optional list of vertex-edges tuples - use as a copy constructor to re-hydrate from de-serialized object
     */
    constructor(verticesAndEdges) {
        // vertices and edges stemming from them
        this.verticesAndEdges = [];
        if (verticesAndEdges) {
            this.verticesAndEdges = verticesAndEdges;
        }
    }
    static fromGraph(graph) {
        return new DirectionalGraph(graph.verticesAndEdges);
    }
    /**
     * Get all vertices.
     */
    getVertices() {
        return this.verticesAndEdges.map(tuple => tuple[0]);
    }
    /**
     * Get all edges.
     */
    getEdges() {
        const edges = [];
        this.verticesAndEdges.forEach(vertexEdges => {
            const fromVertex = vertexEdges[0];
            const connectedVertices = vertexEdges[1];
            connectedVertices.forEach(toVertex => edges.push([fromVertex, toVertex]));
        });
        return edges;
    }
    addEdge(from, to) {
        const fromVertex = this.verticesAndEdges.find(vertex => vertex[0] === from);
        if (fromVertex) {
            const edgesAlreadyInserted = fromVertex[1];
            if (to && !edgesAlreadyInserted.includes(to)) {
                edgesAlreadyInserted.push(to);
            }
        }
        else {
            const edges = to ? [to] : [];
            this.verticesAndEdges.push([from, edges]);
        }
        if (to) {
            this.addEdge(to, undefined);
        }
        return this;
    }
    getVerticesWithEdgesFrom(vertex) {
        const verticesFound = this.verticesAndEdges.find(t => t[0] === vertex);
        return verticesFound ? verticesFound[1] : undefined;
    }
    getVerticesWithEdgesTo(vertex) {
        return this.verticesAndEdges
            .filter(t => t[1].includes(vertex))
            .map(t => t[0]);
    }
    getSubtreePointingTo(vertex) {
        const vertices = this.getVerticesWithEdgesTo(vertex);
        const verticesSubTree = vertices
            .map(childVertex => this.getSubtreePointingTo(childVertex))
            .reduce((x, y) => x.concat(y), []);
        return vertices.concat(verticesSubTree);
    }
    getSubtreePointingFrom(vertex) {
        const vertices = this.getVerticesWithEdgesFrom(vertex);
        if (!vertices) {
            return [];
        }
        const verticesSubTree = vertices
            .map(childVertex => this.getSubtreePointingFrom(childVertex))
            .reduce((x, y) => x.concat(y), []);
        return vertices.concat(verticesSubTree);
    }
}
exports.DirectionalGraph = DirectionalGraph;

},{}],74:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi 2020. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringifyingMap = void 0;
/**
 * Map that stringifies the key objects in order to leverage
 * the javascript native Map and preserve key uniqueness.
 */
class StringifyingMap {
    constructor() {
        this.map = new Map();
        this.keyMap = new Map();
    }
    has(key) {
        const keyString = this.stringifyKey(key);
        return this.map.has(keyString);
    }
    get(key) {
        const keyString = this.stringifyKey(key);
        return this.map.get(keyString);
    }
    set(key, value) {
        const keyString = this.stringifyKey(key);
        this.map.set(keyString, value);
        this.keyMap.set(keyString, key);
        return this;
    }
    /**
     * Puts new key/value if key is absent.
     * @param key key
     * @param defaultValue default value factory
     */
    putIfAbsent(key, defaultValue) {
        if (!this.has(key)) {
            const value = defaultValue();
            this.set(key, value);
            return true;
        }
        return false;
    }
    keys() {
        return this.keyMap.values();
    }
    keyList() {
        return [...this.keys()];
    }
    values() {
        return this.map.values();
    }
    valueList() {
        return [...this.values()];
    }
    delete(key) {
        const keyString = this.stringifyKey(key);
        const flag = this.map.delete(keyString);
        this.keyMap.delete(keyString);
        return flag;
    }
    clear() {
        this.map.clear();
        this.keyMap.clear();
    }
    size() {
        return this.map.size;
    }
    get length() {
        return this.size();
    }
    forEach(callbackfn, thisArg) {
        this.map.forEach(callbackfn, thisArg);
    }
}
exports.StringifyingMap = StringifyingMap;

},{}],75:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exists = exports.isEmpty = exports.getFiles = exports.mkdirIfDoesNotExist = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
/**
 * Creates directory (optionally recursively)
 * @param path path for the directory to create
 * @param options `fs.mkdir` options
 */
async function mkdirIfDoesNotExist(path, options) {
    return new Promise((resolve, reject) => {
        fs.mkdir(path, options, err => {
            if (err && err.code !== 'EEXIST') {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
exports.mkdirIfDoesNotExist = mkdirIfDoesNotExist;
/**
 * All files in the this and its sub-directories.
 * @param dir starting directory
 * @returns file name array with absolute path
 */
async function getFiles(dir) {
    const dirents = await fs.promises.readdir(dir, { withFileTypes: true });
    const childrenFilePromises = dirents.map(dirent => {
        const res = path.resolve(dir, dirent.name);
        return dirent.isDirectory() ? getFiles(res) : Promise.resolve([res]);
    });
    const files = await Promise.all(childrenFilePromises);
    return Array.prototype.concat(...files);
}
exports.getFiles = getFiles;
/**
 * Determines whether the directory is empty i.e. contains any files or sub-directories.
 * @param directory directory to test
 */
async function isEmpty(directory) {
    const stats = await fs.promises.stat(directory);
    if (!stats.isDirectory()) {
        throw new Error("Not a directory: " + directory);
    }
    const dirContent = await fs.promises.readdir(directory);
    return dirContent.length === 0;
}
exports.isEmpty = isEmpty;
async function exists(path) {
    try {
        await fs.promises.stat(path);
    }
    catch (err) {
        const error = err;
        if (error.code === 'ENOENT') {
            return false;
        }
        else {
            throw err;
        }
    }
    return true;
}
exports.exists = exists;

},{"fs":227,"path":235}],76:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.afs = exports.serializationUtils = exports.DirectionalGraph = exports.StringifyingMap = void 0;
__exportStar(require("./util"), exports);
var StringifyingMap_1 = require("./StringifyingMap");
Object.defineProperty(exports, "StringifyingMap", { enumerable: true, get: function () { return StringifyingMap_1.StringifyingMap; } });
var DirectionalGraph_1 = require("./DirectionalGraph");
Object.defineProperty(exports, "DirectionalGraph", { enumerable: true, get: function () { return DirectionalGraph_1.DirectionalGraph; } });
exports.serializationUtils = __importStar(require("./serializationUtils"));
const afs = __importStar(require("./asyncfs"));
exports.afs = afs;

},{"./DirectionalGraph":73,"./StringifyingMap":74,"./asyncfs":75,"./serializationUtils":77,"./util":78}],77:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
* Copyright (c) Jan Dolejsi 2020. All rights reserved.
* Licensed under the MIT License. See License.txt in the project root for license information.
* ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSerializable = exports.objToStrMap = exports.strMapToObj = exports.asSerializable = void 0;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function asSerializable(obj) {
    if (obj === undefined || obj === null) {
        return obj;
    }
    else if (obj instanceof Map) {
        return strMapToObj(obj);
    }
    else if (obj instanceof Array) {
        return obj.map(o => asSerializable(o));
    }
    else if (obj instanceof Set) {
        return [...obj].map(o => asSerializable(o));
    }
    else if (obj instanceof Object) {
        const serObj = Object.create(null);
        Object.keys(obj).forEach(key => serObj[key] = asSerializable(obj[key]));
        return serObj;
    }
    else {
        return obj;
    }
}
exports.asSerializable = asSerializable;
function strMapToObj(strMap) {
    const obj = Object.create(null);
    for (const [k, v] of strMap) {
        obj[k] = asSerializable(v);
    }
    return obj;
}
exports.strMapToObj = strMapToObj;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function objToStrMap(obj) {
    const strMap = new Map();
    for (const k of Object.keys(obj)) {
        strMap.set(k, obj[k]);
    }
    return strMap;
}
exports.objToStrMap = objToStrMap;
/**
 * Removes circular dependencies to make JSON-serialization safe.
 * @param orig original object
 */
function makeSerializable(orig) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const getCircularReplacer = () => {
        const seen = new WeakSet();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return (_key, value) => {
            if (typeof value === "object" && value !== null) {
                if (seen.has(value)) {
                    return;
                }
                seen.add(value);
            }
            return value;
        };
    };
    return JSON.parse(JSON.stringify(orig, getCircularReplacer()));
}
exports.makeSerializable = makeSerializable;

},{}],78:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.equalsCaseInsensitive = exports.Util = void 0;
const os = __importStar(require("os"));
class Util {
    /**
     * Wraps path with doublequotes, if it includes a space.
     *
     * This is necessary on Windows in order to handle spaces in file and directory names.
     * @param path file system path
     */
    static q(path) {
        return this.shouldBeDoubleQuoted(path) ? `"${path}"` : path;
    }
    static shouldBeDoubleQuoted(path) {
        return os.platform() === 'win32' && path.includes(' ') && !path.includes('"')
            && !path.includes(" -jar ")
            && !path.includes(" -javaagent:")
            && !path.startsWith("node ");
    }
    /**
     * Replaces all occurrences
     * @param text text to replace in
     * @param searchValue value to replace
     * @param replaceValue replacement value
     */
    static replaceAll(text, searchValue, replaceValue) {
        return text.split(searchValue).join(replaceValue);
    }
    /**
     * Groups array by a key
     * @param list list to be grouped
     * @param keyGetter grouping key selector
     */
    static groupBy(list, keyGetter) {
        const map = new Map();
        list.forEach((item) => {
            const key = keyGetter(item);
            const collection = map.get(key);
            if (!collection) {
                map.set(key, [item]);
            }
            else {
                collection.push(item);
            }
        });
        return map;
    }
    /**
     * Equivalent of flatMap from other languages.
     * @param arrayOfArrays array of arrays to be flattened to single dimentional array
     */
    static flatMap(arrayOfArrays) {
        // eslint-disable-next-line prefer-spread
        return new Array().concat.apply(new Array(), arrayOfArrays);
    }
    static distinct(array) {
        return [...new Set(array).values()];
    }
}
exports.Util = Util;
/** @returns `true` if `text1` and `text2` are equal ignoring case. */
function equalsCaseInsensitive(text1, text2) {
    return text1.toLowerCase() === text2.toLowerCase();
}
exports.equalsCaseInsensitive = equalsCaseInsensitive;

},{"os":234}],79:[function(require,module,exports){
(function (Buffer){(function (){
;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = require('stream').Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = require('string_decoder').StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})(typeof exports === 'undefined' ? this.sax = {} : exports)

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":228,"stream":254,"string_decoder":255}],80:[function(require,module,exports){
(function (process){(function (){
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r=e();for(var n in r)("object"==typeof exports?exports:t)[n]=r[n]}}(this,(()=>(()=>{"use strict";var t={470:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",o=0,i=-1,a=0,s=0;s<=t.length;++s){if(s<t.length)r=t.charCodeAt(s);else{if(47===r)break;r=47}if(47===r){if(i===s-1||1===a);else if(i!==s-1&&2===a){if(n.length<2||2!==o||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var h=n.lastIndexOf("/");if(h!==n.length-1){-1===h?(n="",o=0):o=(n=n.slice(0,h)).length-1-n.lastIndexOf("/"),i=s,a=0;continue}}else if(2===n.length||1===n.length){n="",o=0,i=s,a=0;continue}e&&(n.length>0?n+="/..":n="..",o=2)}else n.length>0?n+="/"+t.slice(i+1,s):n=t.slice(i+1,s),o=s-i-1;i=s,a=0}else 46===r&&-1!==a?++a:a=-1}return n}var n={resolve:function(){for(var t,n="",o=!1,i=arguments.length-1;i>=-1&&!o;i--){var a;i>=0?a=arguments[i]:(void 0===t&&(t=process.cwd()),a=t),e(a),0!==a.length&&(n=a+"/"+n,o=47===a.charCodeAt(0))}return n=r(n,!o),o?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return".";var n=47===t.charCodeAt(0),o=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&o&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,r=0;r<arguments.length;++r){var o=arguments[r];e(o),o.length>0&&(void 0===t?t=o:t+="/"+o)}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return"";if((t=n.resolve(t))===(r=n.resolve(r)))return"";for(var o=1;o<t.length&&47===t.charCodeAt(o);++o);for(var i=t.length,a=i-o,s=1;s<r.length&&47===r.charCodeAt(s);++s);for(var h=r.length-s,c=a<h?a:h,f=-1,u=0;u<=c;++u){if(u===c){if(h>c){if(47===r.charCodeAt(s+u))return r.slice(s+u+1);if(0===u)return r.slice(s+u)}else a>c&&(47===t.charCodeAt(o+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(o+u);if(l!==r.charCodeAt(s+u))break;47===l&&(f=u)}var p="";for(u=o+f+1;u<=i;++u)u!==i&&47!==t.charCodeAt(u)||(0===p.length?p+="..":p+="/..");return p.length>0?p+r.slice(s+f):(s+=f,47===r.charCodeAt(s)&&++s,r.slice(s))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var r=t.charCodeAt(0),n=47===r,o=-1,i=!0,a=t.length-1;a>=1;--a)if(47===(r=t.charCodeAt(a))){if(!i){o=a;break}}else i=!1;return-1===o?n?"/":".":n&&1===o?"//":t.slice(0,o)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError('"ext" argument must be a string');e(t);var n,o=0,i=-1,a=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return"";var s=r.length-1,h=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!a){o=n+1;break}}else-1===h&&(a=!1,h=n+1),s>=0&&(c===r.charCodeAt(s)?-1==--s&&(i=n):(s=-1,i=h))}return o===i?i=h:-1===i&&(i=t.length),t.slice(o,i)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!a){o=n+1;break}}else-1===i&&(a=!1,i=n+1);return-1===i?"":t.slice(o,i)},extname:function(t){e(t);for(var r=-1,n=0,o=-1,i=!0,a=0,s=t.length-1;s>=0;--s){var h=t.charCodeAt(s);if(47!==h)-1===o&&(i=!1,o=s+1),46===h?-1===r?r=s:1!==a&&(a=1):-1!==r&&(a=-1);else if(!i){n=s+1;break}}return-1===r||-1===o||0===a||1===a&&r===o-1&&r===n+1?"":t.slice(r,o)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,o=t.charCodeAt(0),i=47===o;i?(r.root="/",n=1):n=0;for(var a=-1,s=0,h=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(o=t.charCodeAt(f)))-1===h&&(c=!1,h=f+1),46===o?-1===a?a=f:1!==u&&(u=1):-1!==a&&(u=-1);else if(!c){s=f+1;break}return-1===a||-1===h||0===u||1===u&&a===h-1&&a===s+1?-1!==h&&(r.base=r.name=0===s&&i?t.slice(1,h):t.slice(s,h)):(0===s&&i?(r.name=t.slice(1,a),r.base=t.slice(1,h)):(r.name=t.slice(s,a),r.base=t.slice(s,h)),r.ext=t.slice(a,h)),s>0?r.dir=t.slice(0,s-1):i&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n},674:(t,e)=>{if(Object.defineProperty(e,"__esModule",{value:!0}),e.isWindows=void 0,"object"==typeof process)e.isWindows="win32"===process.platform;else if("object"==typeof navigator){var r=navigator.userAgent;e.isWindows=r.indexOf("Windows")>=0}},796:function(t,e,r){var n,o,i=this&&this.__extends||(n=function(t,e){return n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])},n(t,e)},function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function r(){this.constructor=t}n(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)});Object.defineProperty(e,"__esModule",{value:!0}),e.uriToFsPath=e.URI=void 0;var a=r(674),s=/^\w[\w\d+.-]*$/,h=/^\//,c=/^\/\//;function f(t,e){if(!t.scheme&&e)throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t.authority,'", path: "').concat(t.path,'", query: "').concat(t.query,'", fragment: "').concat(t.fragment,'"}'));if(t.scheme&&!s.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!h.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}else if(c.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}var u="",l="/",p=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,d=function(){function t(t,e,r,n,o,i){void 0===i&&(i=!1),"object"==typeof t?(this.scheme=t.scheme||u,this.authority=t.authority||u,this.path=t.path||u,this.query=t.query||u,this.fragment=t.fragment||u):(this.scheme=function(t,e){return t||e?t:"file"}(t,i),this.authority=e||u,this.path=function(t,e){switch(t){case"https":case"http":case"file":e?e[0]!==l&&(e=l+e):e=l}return e}(this.scheme,r||u),this.query=n||u,this.fragment=o||u,f(this,i))}return t.isUri=function(e){return e instanceof t||!!e&&"string"==typeof e.authority&&"string"==typeof e.fragment&&"string"==typeof e.path&&"string"==typeof e.query&&"string"==typeof e.scheme&&"string"==typeof e.fsPath&&"function"==typeof e.with&&"function"==typeof e.toString},Object.defineProperty(t.prototype,"fsPath",{get:function(){return C(this,!1)},enumerable:!1,configurable:!0}),t.prototype.with=function(t){if(!t)return this;var e=t.scheme,r=t.authority,n=t.path,o=t.query,i=t.fragment;return void 0===e?e=this.scheme:null===e&&(e=u),void 0===r?r=this.authority:null===r&&(r=u),void 0===n?n=this.path:null===n&&(n=u),void 0===o?o=this.query:null===o&&(o=u),void 0===i?i=this.fragment:null===i&&(i=u),e===this.scheme&&r===this.authority&&n===this.path&&o===this.query&&i===this.fragment?this:new v(e,r,n,o,i)},t.parse=function(t,e){void 0===e&&(e=!1);var r=p.exec(t);return r?new v(r[2]||u,x(r[4]||u),x(r[5]||u),x(r[7]||u),x(r[9]||u),e):new v(u,u,u,u,u)},t.file=function(t){var e=u;if(a.isWindows&&(t=t.replace(/\\/g,l)),t[0]===l&&t[1]===l){var r=t.indexOf(l,2);-1===r?(e=t.substring(2),t=l):(e=t.substring(2,r),t=t.substring(r)||l)}return new v("file",e,t,u,u)},t.from=function(t){var e=new v(t.scheme,t.authority,t.path,t.query,t.fragment);return f(e,!0),e},t.prototype.toString=function(t){return void 0===t&&(t=!1),A(this,t)},t.prototype.toJSON=function(){return this},t.revive=function(e){if(e){if(e instanceof t)return e;var r=new v(e);return r._formatted=e.external,r._fsPath=e._sep===g?e.fsPath:null,r}return e},t}();e.URI=d;var g=a.isWindows?1:void 0,v=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e._formatted=null,e._fsPath=null,e}return i(e,t),Object.defineProperty(e.prototype,"fsPath",{get:function(){return this._fsPath||(this._fsPath=C(this,!1)),this._fsPath},enumerable:!1,configurable:!0}),e.prototype.toString=function(t){return void 0===t&&(t=!1),t?A(this,!0):(this._formatted||(this._formatted=A(this,!1)),this._formatted)},e.prototype.toJSON=function(){var t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=g),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t},e}(d),y=((o={})[58]="%3A",o[47]="%2F",o[63]="%3F",o[35]="%23",o[91]="%5B",o[93]="%5D",o[64]="%40",o[33]="%21",o[36]="%24",o[38]="%26",o[39]="%27",o[40]="%28",o[41]="%29",o[42]="%2A",o[43]="%2B",o[44]="%2C",o[59]="%3B",o[61]="%3D",o[32]="%20",o);function m(t,e,r){for(var n=void 0,o=-1,i=0;i<t.length;i++){var a=t.charCodeAt(i);if(a>=97&&a<=122||a>=65&&a<=90||a>=48&&a<=57||45===a||46===a||95===a||126===a||e&&47===a||r&&91===a||r&&93===a||r&&58===a)-1!==o&&(n+=encodeURIComponent(t.substring(o,i)),o=-1),void 0!==n&&(n+=t.charAt(i));else{void 0===n&&(n=t.substr(0,i));var s=y[a];void 0!==s?(-1!==o&&(n+=encodeURIComponent(t.substring(o,i)),o=-1),n+=s):-1===o&&(o=i)}}return-1!==o&&(n+=encodeURIComponent(t.substring(o))),void 0!==n?n:t}function b(t){for(var e=void 0,r=0;r<t.length;r++){var n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=y[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function C(t,e){var r;return r=t.authority&&t.path.length>1&&"file"===t.scheme?"//".concat(t.authority).concat(t.path):47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,a.isWindows&&(r=r.replace(/\//g,"\\")),r}function A(t,e){var r=e?b:m,n="",o=t.scheme,i=t.authority,a=t.path,s=t.query,h=t.fragment;if(o&&(n+=o,n+=":"),(i||"file"===o)&&(n+=l,n+=l),i){var c=i.indexOf("@");if(-1!==c){var f=i.substr(0,c);i=i.substr(c+1),-1===(c=f.lastIndexOf(":"))?n+=r(f,!1,!1):(n+=r(f.substr(0,c),!1,!1),n+=":",n+=r(f.substr(c+1),!1,!0)),n+="@"}-1===(c=(i=i.toLowerCase()).lastIndexOf(":"))?n+=r(i,!1,!0):(n+=r(i.substr(0,c),!1,!0),n+=i.substr(c))}if(a){if(a.length>=3&&47===a.charCodeAt(0)&&58===a.charCodeAt(2))(u=a.charCodeAt(1))>=65&&u<=90&&(a="/".concat(String.fromCharCode(u+32),":").concat(a.substr(3)));else if(a.length>=2&&58===a.charCodeAt(1)){var u;(u=a.charCodeAt(0))>=65&&u<=90&&(a="".concat(String.fromCharCode(u+32),":").concat(a.substr(2)))}n+=r(a,!0,!1)}return s&&(n+="?",n+=r(s,!1,!1)),h&&(n+="#",n+=e?h:m(h,!1,!1)),n}function w(t){try{return decodeURIComponent(t)}catch(e){return t.length>3?t.substr(0,3)+w(t.substr(3)):t}}e.uriToFsPath=C;var _=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function x(t){return t.match(_)?t.replace(_,(function(t){return w(t)})):t}},679:function(t,e,r){var n=this&&this.__spreadArray||function(t,e,r){if(r||2===arguments.length)for(var n,o=0,i=e.length;o<i;o++)!n&&o in e||(n||(n=Array.prototype.slice.call(e,0,o)),n[o]=e[o]);return t.concat(n||Array.prototype.slice.call(e))};Object.defineProperty(e,"__esModule",{value:!0}),e.Utils=void 0;var o,i=r(470),a=i.posix||i,s="/";(o=e.Utils||(e.Utils={})).joinPath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];return t.with({path:a.join.apply(a,n([t.path],e,!1))})},o.resolvePath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];var o=t.path,i=!1;o[0]!==s&&(o=s+o,i=!0);var h=a.resolve.apply(a,n([o],e,!1));return i&&h[0]===s&&!t.authority&&(h=h.substring(1)),t.with({path:h})},o.dirname=function(t){if(0===t.path.length||t.path===s)return t;var e=a.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=""),t.with({path:e})},o.basename=function(t){return a.basename(t.path)},o.extname=function(t){return a.extname(t.path)}}},e={};function r(n){var o=e[n];if(void 0!==o)return o.exports;var i=e[n]={exports:{}};return t[n].call(i.exports,i,i.exports,r),i.exports}var n={};return(()=>{var t=n;Object.defineProperty(t,"__esModule",{value:!0}),t.Utils=t.URI=void 0;var e=r(796);Object.defineProperty(t,"URI",{enumerable:!0,get:function(){return e.URI}});var o=r(679);Object.defineProperty(t,"Utils",{enumerable:!0,get:function(){return o.Utils}})})(),n})()));

}).call(this)}).call(this,require('_process'))
},{"_process":237}],81:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  exports.stripBOM = function(str) {
    if (str[0] === '\uFEFF') {
      return str.substring(1);
    } else {
      return str;
    }
  };

}).call(this);

},{}],82:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,
    hasProp = {}.hasOwnProperty;

  builder = require('xmlbuilder');

  defaults = require('./defaults').defaults;

  requiresCDATA = function(entry) {
    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
  };

  wrapCDATA = function(entry) {
    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
  };

  escapeCDATA = function(entry) {
    return entry.replace(']]>', ']]]]><![CDATA[>');
  };

  exports.Builder = (function() {
    function Builder(opts) {
      var key, ref, value;
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
    }

    Builder.prototype.buildObject = function(rootObj) {
      var attrkey, charkey, render, rootElement, rootName;
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
        rootName = Object.keys(rootObj)[0];
        rootObj = rootObj[rootName];
      } else {
        rootName = this.options.rootName;
      }
      render = (function(_this) {
        return function(element, obj) {
          var attr, child, entry, index, key, value;
          if (typeof obj !== 'object') {
            if (_this.options.cdata && requiresCDATA(obj)) {
              element.raw(wrapCDATA(obj));
            } else {
              element.txt(obj);
            }
          } else if (Array.isArray(obj)) {
            for (index in obj) {
              if (!hasProp.call(obj, index)) continue;
              child = obj[index];
              for (key in child) {
                entry = child[key];
                element = render(element.ele(key), entry).up();
              }
            }
          } else {
            for (key in obj) {
              if (!hasProp.call(obj, key)) continue;
              child = obj[key];
              if (key === attrkey) {
                if (typeof child === "object") {
                  for (attr in child) {
                    value = child[attr];
                    element = element.att(attr, value);
                  }
                }
              } else if (key === charkey) {
                if (_this.options.cdata && requiresCDATA(child)) {
                  element = element.raw(wrapCDATA(child));
                } else {
                  element = element.txt(child);
                }
              } else if (Array.isArray(child)) {
                for (index in child) {
                  if (!hasProp.call(child, index)) continue;
                  entry = child[index];
                  if (typeof entry === 'string') {
                    if (_this.options.cdata && requiresCDATA(entry)) {
                      element = element.ele(key).raw(wrapCDATA(entry)).up();
                    } else {
                      element = element.ele(key, entry).up();
                    }
                  } else {
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else if (typeof child === "object") {
                element = render(element.ele(key), child).up();
              } else {
                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                  element = element.ele(key).raw(wrapCDATA(child)).up();
                } else {
                  if (child == null) {
                    child = '';
                  }
                  element = element.ele(key, child.toString()).up();
                }
              }
            }
          }
          return element;
        };
      })(this);
      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
        headless: this.options.headless,
        allowSurrogateChars: this.options.allowSurrogateChars
      });
      return render(rootElement, rootObj).end(this.options.renderOpts);
    };

    return Builder;

  })();

}).call(this);

},{"./defaults":83,"xmlbuilder":119}],83:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  exports.defaults = {
    "0.1": {
      explicitCharkey: false,
      trim: true,
      normalize: true,
      normalizeTags: false,
      attrkey: "@",
      charkey: "#",
      explicitArray: false,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: false,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      childkey: '@@',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      emptyTag: ''
    },
    "0.2": {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      normalizeTags: false,
      attrkey: "$",
      charkey: "_",
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: true,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      preserveChildrenOrder: false,
      childkey: '$$',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      rootName: 'root',
      xmldec: {
        'version': '1.0',
        'encoding': 'UTF-8',
        'standalone': true
      },
      doctype: null,
      renderOpts: {
        'pretty': true,
        'indent': '  ',
        'newline': '\n'
      },
      headless: false,
      chunkSize: 10000,
      emptyTag: '',
      cdata: false
    }
  };

}).call(this);

},{}],84:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  sax = require('sax');

  events = require('events');

  bom = require('./bom');

  processors = require('./processors');

  setImmediate = require('timers').setImmediate;

  defaults = require('./defaults').defaults;

  isEmpty = function(thing) {
    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
  };

  processItem = function(processors, item, key) {
    var i, len, process;
    for (i = 0, len = processors.length; i < len; i++) {
      process = processors[i];
      item = process(item, key);
    }
    return item;
  };

  exports.Parser = (function(superClass) {
    extend(Parser, superClass);

    function Parser(opts) {
      this.parseStringPromise = bind(this.parseStringPromise, this);
      this.parseString = bind(this.parseString, this);
      this.reset = bind(this.reset, this);
      this.assignOrPush = bind(this.assignOrPush, this);
      this.processAsync = bind(this.processAsync, this);
      var key, ref, value;
      if (!(this instanceof exports.Parser)) {
        return new exports.Parser(opts);
      }
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
      if (this.options.xmlns) {
        this.options.xmlnskey = this.options.attrkey + "ns";
      }
      if (this.options.normalizeTags) {
        if (!this.options.tagNameProcessors) {
          this.options.tagNameProcessors = [];
        }
        this.options.tagNameProcessors.unshift(processors.normalize);
      }
      this.reset();
    }

    Parser.prototype.processAsync = function() {
      var chunk, err;
      try {
        if (this.remaining.length <= this.options.chunkSize) {
          chunk = this.remaining;
          this.remaining = '';
          this.saxParser = this.saxParser.write(chunk);
          return this.saxParser.close();
        } else {
          chunk = this.remaining.substr(0, this.options.chunkSize);
          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
          this.saxParser = this.saxParser.write(chunk);
          return setImmediate(this.processAsync);
        }
      } catch (error1) {
        err = error1;
        if (!this.saxParser.errThrown) {
          this.saxParser.errThrown = true;
          return this.emit(err);
        }
      }
    };

    Parser.prototype.assignOrPush = function(obj, key, newValue) {
      if (!(key in obj)) {
        if (!this.options.explicitArray) {
          return obj[key] = newValue;
        } else {
          return obj[key] = [newValue];
        }
      } else {
        if (!(obj[key] instanceof Array)) {
          obj[key] = [obj[key]];
        }
        return obj[key].push(newValue);
      }
    };

    Parser.prototype.reset = function() {
      var attrkey, charkey, ontext, stack;
      this.removeAllListeners();
      this.saxParser = sax.parser(this.options.strict, {
        trim: false,
        normalize: false,
        xmlns: this.options.xmlns
      });
      this.saxParser.errThrown = false;
      this.saxParser.onerror = (function(_this) {
        return function(error) {
          _this.saxParser.resume();
          if (!_this.saxParser.errThrown) {
            _this.saxParser.errThrown = true;
            return _this.emit("error", error);
          }
        };
      })(this);
      this.saxParser.onend = (function(_this) {
        return function() {
          if (!_this.saxParser.ended) {
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      this.saxParser.ended = false;
      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
      this.resultObject = null;
      stack = [];
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      this.saxParser.onopentag = (function(_this) {
        return function(node) {
          var key, newValue, obj, processedKey, ref;
          obj = {};
          obj[charkey] = "";
          if (!_this.options.ignoreAttrs) {
            ref = node.attributes;
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                obj[attrkey] = {};
              }
              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
              if (_this.options.mergeAttrs) {
                _this.assignOrPush(obj, processedKey, newValue);
              } else {
                obj[attrkey][processedKey] = newValue;
              }
            }
          }
          obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
          if (_this.options.xmlns) {
            obj[_this.options.xmlnskey] = {
              uri: node.uri,
              local: node.local
            };
          }
          return stack.push(obj);
        };
      })(this);
      this.saxParser.onclosetag = (function(_this) {
        return function() {
          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
          obj = stack.pop();
          nodeName = obj["#name"];
          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
            delete obj["#name"];
          }
          if (obj.cdata === true) {
            cdata = obj.cdata;
            delete obj.cdata;
          }
          s = stack[stack.length - 1];
          if (obj[charkey].match(/^\s*$/) && !cdata) {
            emptyStr = obj[charkey];
            delete obj[charkey];
          } else {
            if (_this.options.trim) {
              obj[charkey] = obj[charkey].trim();
            }
            if (_this.options.normalize) {
              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
            }
            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
              obj = obj[charkey];
            }
          }
          if (isEmpty(obj)) {
            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
          }
          if (_this.options.validator != null) {
            xpath = "/" + ((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = stack.length; i < len; i++) {
                node = stack[i];
                results.push(node["#name"]);
              }
              return results;
            })()).concat(nodeName).join("/");
            (function() {
              var err;
              try {
                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
              } catch (error1) {
                err = error1;
                return _this.emit("error", err);
              }
            })();
          }
          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
            if (!_this.options.preserveChildrenOrder) {
              node = {};
              if (_this.options.attrkey in obj) {
                node[_this.options.attrkey] = obj[_this.options.attrkey];
                delete obj[_this.options.attrkey];
              }
              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                node[_this.options.charkey] = obj[_this.options.charkey];
                delete obj[_this.options.charkey];
              }
              if (Object.getOwnPropertyNames(obj).length > 0) {
                node[_this.options.childkey] = obj;
              }
              obj = node;
            } else if (s) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              objClone = {};
              for (key in obj) {
                if (!hasProp.call(obj, key)) continue;
                objClone[key] = obj[key];
              }
              s[_this.options.childkey].push(objClone);
              delete obj["#name"];
              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
          }
          if (stack.length > 0) {
            return _this.assignOrPush(s, nodeName, obj);
          } else {
            if (_this.options.explicitRoot) {
              old = obj;
              obj = {};
              obj[nodeName] = old;
            }
            _this.resultObject = obj;
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      ontext = (function(_this) {
        return function(text) {
          var charChild, s;
          s = stack[stack.length - 1];
          if (s) {
            s[charkey] += text;
            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              charChild = {
                '#name': '__text__'
              };
              charChild[charkey] = text;
              if (_this.options.normalize) {
                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
              }
              s[_this.options.childkey].push(charChild);
            }
            return s;
          }
        };
      })(this);
      this.saxParser.ontext = ontext;
      return this.saxParser.oncdata = (function(_this) {
        return function(text) {
          var s;
          s = ontext(text);
          if (s) {
            return s.cdata = true;
          }
        };
      })(this);
    };

    Parser.prototype.parseString = function(str, cb) {
      var err;
      if ((cb != null) && typeof cb === "function") {
        this.on("end", function(result) {
          this.reset();
          return cb(null, result);
        });
        this.on("error", function(err) {
          this.reset();
          return cb(err);
        });
      }
      try {
        str = str.toString();
        if (str.trim() === '') {
          this.emit("end", null);
          return true;
        }
        str = bom.stripBOM(str);
        if (this.options.async) {
          this.remaining = str;
          setImmediate(this.processAsync);
          return this.saxParser;
        }
        return this.saxParser.write(str).close();
      } catch (error1) {
        err = error1;
        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
          this.emit('error', err);
          return this.saxParser.errThrown = true;
        } else if (this.saxParser.ended) {
          throw err;
        }
      }
    };

    Parser.prototype.parseStringPromise = function(str) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.parseString(str, function(err, value) {
            if (err) {
              return reject(err);
            } else {
              return resolve(value);
            }
          });
        };
      })(this));
    };

    return Parser;

  })(events);

  exports.parseString = function(str, a, b) {
    var cb, options, parser;
    if (b != null) {
      if (typeof b === 'function') {
        cb = b;
      }
      if (typeof a === 'object') {
        options = a;
      }
    } else {
      if (typeof a === 'function') {
        cb = a;
      }
      options = {};
    }
    parser = new exports.Parser(options);
    return parser.parseString(str, cb);
  };

  exports.parseStringPromise = function(str, a) {
    var options, parser;
    if (typeof a === 'object') {
      options = a;
    }
    parser = new exports.Parser(options);
    return parser.parseStringPromise(str);
  };

}).call(this);

},{"./bom":81,"./defaults":83,"./processors":85,"events":230,"sax":79,"timers":256}],85:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var prefixMatch;

  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

  exports.normalize = function(str) {
    return str.toLowerCase();
  };

  exports.firstCharLowerCase = function(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
  };

  exports.stripPrefix = function(str) {
    return str.replace(prefixMatch, '');
  };

  exports.parseNumbers = function(str) {
    if (!isNaN(str)) {
      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
    }
    return str;
  };

  exports.parseBooleans = function(str) {
    if (/^(?:true|false)$/i.test(str)) {
      str = str.toLowerCase() === 'true';
    }
    return str;
  };

}).call(this);

},{}],86:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var builder, defaults, parser, processors,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  defaults = require('./defaults');

  builder = require('./builder');

  parser = require('./parser');

  processors = require('./processors');

  exports.defaults = defaults.defaults;

  exports.processors = processors;

  exports.ValidationError = (function(superClass) {
    extend(ValidationError, superClass);

    function ValidationError(message) {
      this.message = message;
    }

    return ValidationError;

  })(Error);

  exports.Builder = builder.Builder;

  exports.Parser = parser.Parser;

  exports.parseString = parser.parseString;

  exports.parseStringPromise = parser.parseStringPromise;

}).call(this);

},{"./builder":82,"./defaults":83,"./parser":84,"./processors":85}],87:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  module.exports = {
    Disconnected: 1,
    Preceding: 2,
    Following: 4,
    Contains: 8,
    ContainedBy: 16,
    ImplementationSpecific: 32
  };

}).call(this);

},{}],88:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  module.exports = {
    Element: 1,
    Attribute: 2,
    Text: 3,
    CData: 4,
    EntityReference: 5,
    EntityDeclaration: 6,
    ProcessingInstruction: 7,
    Comment: 8,
    Document: 9,
    DocType: 10,
    DocumentFragment: 11,
    NotationDeclaration: 12,
    Declaration: 201,
    Raw: 202,
    AttributeDeclaration: 203,
    ElementDeclaration: 204,
    Dummy: 205
  };

}).call(this);

},{}],89:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  assign = function() {
    var i, key, len, source, sources, target;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (isFunction(Object.assign)) {
      Object.assign.apply(null, arguments);
    } else {
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        if (source != null) {
          for (key in source) {
            if (!hasProp.call(source, key)) continue;
            target[key] = source[key];
          }
        }
      }
    }
    return target;
  };

  isFunction = function(val) {
    return !!val && Object.prototype.toString.call(val) === '[object Function]';
  };

  isObject = function(val) {
    var ref;
    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
  };

  isArray = function(val) {
    if (isFunction(Array.isArray)) {
      return Array.isArray(val);
    } else {
      return Object.prototype.toString.call(val) === '[object Array]';
    }
  };

  isEmpty = function(val) {
    var key;
    if (isArray(val)) {
      return !val.length;
    } else {
      for (key in val) {
        if (!hasProp.call(val, key)) continue;
        return false;
      }
      return true;
    }
  };

  isPlainObject = function(val) {
    var ctor, proto;
    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
  };

  getValue = function(obj) {
    if (isFunction(obj.valueOf)) {
      return obj.valueOf();
    } else {
      return obj;
    }
  };

  module.exports.assign = assign;

  module.exports.isFunction = isFunction;

  module.exports.isObject = isObject;

  module.exports.isArray = isArray;

  module.exports.isEmpty = isEmpty;

  module.exports.isPlainObject = isPlainObject;

  module.exports.getValue = getValue;

}).call(this);

},{}],90:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  module.exports = {
    None: 0,
    OpenTag: 1,
    InsideTag: 2,
    CloseTag: 3
  };

}).call(this);

},{}],91:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLAttribute, XMLNode;

  NodeType = require('./NodeType');

  XMLNode = require('./XMLNode');

  module.exports = XMLAttribute = (function() {
    function XMLAttribute(parent, name, value) {
      this.parent = parent;
      if (this.parent) {
        this.options = this.parent.options;
        this.stringify = this.parent.stringify;
      }
      if (name == null) {
        throw new Error("Missing attribute name. " + this.debugInfo(name));
      }
      this.name = this.stringify.name(name);
      this.value = this.stringify.attValue(value);
      this.type = NodeType.Attribute;
      this.isId = false;
      this.schemaTypeInfo = null;
    }

    Object.defineProperty(XMLAttribute.prototype, 'nodeType', {
      get: function() {
        return this.type;
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {
      get: function() {
        return this.parent;
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'textContent', {
      get: function() {
        return this.value;
      },
      set: function(value) {
        return this.value = value || '';
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'prefix', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'localName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'specified', {
      get: function() {
        return true;
      }
    });

    XMLAttribute.prototype.clone = function() {
      return Object.create(this);
    };

    XMLAttribute.prototype.toString = function(options) {
      return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
    };

    XMLAttribute.prototype.debugInfo = function(name) {
      name = name || this.name;
      if (name == null) {
        return "parent: <" + this.parent.name + ">";
      } else {
        return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
      }
    };

    XMLAttribute.prototype.isEqualNode = function(node) {
      if (node.namespaceURI !== this.namespaceURI) {
        return false;
      }
      if (node.prefix !== this.prefix) {
        return false;
      }
      if (node.localName !== this.localName) {
        return false;
      }
      if (node.value !== this.value) {
        return false;
      }
      return true;
    };

    return XMLAttribute;

  })();

}).call(this);

},{"./NodeType":88,"./XMLNode":110}],92:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLCData, XMLCharacterData,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = require('./NodeType');

  XMLCharacterData = require('./XMLCharacterData');

  module.exports = XMLCData = (function(superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text. " + this.debugInfo());
      }
      this.name = "#cdata-section";
      this.type = NodeType.CData;
      this.value = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function() {
      return Object.create(this);
    };

    XMLCData.prototype.toString = function(options) {
      return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
    };

    return XMLCData;

  })(XMLCharacterData);

}).call(this);

},{"./NodeType":88,"./XMLCharacterData":93}],93:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCharacterData, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  module.exports = XMLCharacterData = (function(superClass) {
    extend(XMLCharacterData, superClass);

    function XMLCharacterData(parent) {
      XMLCharacterData.__super__.constructor.call(this, parent);
      this.value = '';
    }

    Object.defineProperty(XMLCharacterData.prototype, 'data', {
      get: function() {
        return this.value;
      },
      set: function(value) {
        return this.value = value || '';
      }
    });

    Object.defineProperty(XMLCharacterData.prototype, 'length', {
      get: function() {
        return this.value.length;
      }
    });

    Object.defineProperty(XMLCharacterData.prototype, 'textContent', {
      get: function() {
        return this.value;
      },
      set: function(value) {
        return this.value = value || '';
      }
    });

    XMLCharacterData.prototype.clone = function() {
      return Object.create(this);
    };

    XMLCharacterData.prototype.substringData = function(offset, count) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLCharacterData.prototype.appendData = function(arg) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLCharacterData.prototype.insertData = function(offset, arg) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLCharacterData.prototype.deleteData = function(offset, count) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLCharacterData.prototype.replaceData = function(offset, count, arg) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLCharacterData.prototype.isEqualNode = function(node) {
      if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
        return false;
      }
      if (node.data !== this.data) {
        return false;
      }
      return true;
    };

    return XMLCharacterData;

  })(XMLNode);

}).call(this);

},{"./XMLNode":110}],94:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLCharacterData, XMLComment,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = require('./NodeType');

  XMLCharacterData = require('./XMLCharacterData');

  module.exports = XMLComment = (function(superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text. " + this.debugInfo());
      }
      this.name = "#comment";
      this.type = NodeType.Comment;
      this.value = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function() {
      return Object.create(this);
    };

    XMLComment.prototype.toString = function(options) {
      return this.options.writer.comment(this, this.options.writer.filterOptions(options));
    };

    return XMLComment;

  })(XMLCharacterData);

}).call(this);

},{"./NodeType":88,"./XMLCharacterData":93}],95:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;

  XMLDOMErrorHandler = require('./XMLDOMErrorHandler');

  XMLDOMStringList = require('./XMLDOMStringList');

  module.exports = XMLDOMConfiguration = (function() {
    function XMLDOMConfiguration() {
      var clonedSelf;
      this.defaultParams = {
        "canonical-form": false,
        "cdata-sections": false,
        "comments": false,
        "datatype-normalization": false,
        "element-content-whitespace": true,
        "entities": true,
        "error-handler": new XMLDOMErrorHandler(),
        "infoset": true,
        "validate-if-schema": false,
        "namespaces": true,
        "namespace-declarations": true,
        "normalize-characters": false,
        "schema-location": '',
        "schema-type": '',
        "split-cdata-sections": true,
        "validate": false,
        "well-formed": true
      };
      this.params = clonedSelf = Object.create(this.defaultParams);
    }

    Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {
      get: function() {
        return new XMLDOMStringList(Object.keys(this.defaultParams));
      }
    });

    XMLDOMConfiguration.prototype.getParameter = function(name) {
      if (this.params.hasOwnProperty(name)) {
        return this.params[name];
      } else {
        return null;
      }
    };

    XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {
      return true;
    };

    XMLDOMConfiguration.prototype.setParameter = function(name, value) {
      if (value != null) {
        return this.params[name] = value;
      } else {
        return delete this.params[name];
      }
    };

    return XMLDOMConfiguration;

  })();

}).call(this);

},{"./XMLDOMErrorHandler":96,"./XMLDOMStringList":98}],96:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDOMErrorHandler;

  module.exports = XMLDOMErrorHandler = (function() {
    function XMLDOMErrorHandler() {}

    XMLDOMErrorHandler.prototype.handleError = function(error) {
      throw new Error(error);
    };

    return XMLDOMErrorHandler;

  })();

}).call(this);

},{}],97:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDOMImplementation;

  module.exports = XMLDOMImplementation = (function() {
    function XMLDOMImplementation() {}

    XMLDOMImplementation.prototype.hasFeature = function(feature, version) {
      return true;
    };

    XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
      throw new Error("This DOM method is not implemented.");
    };

    XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
      throw new Error("This DOM method is not implemented.");
    };

    XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
      throw new Error("This DOM method is not implemented.");
    };

    XMLDOMImplementation.prototype.getFeature = function(feature, version) {
      throw new Error("This DOM method is not implemented.");
    };

    return XMLDOMImplementation;

  })();

}).call(this);

},{}],98:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDOMStringList;

  module.exports = XMLDOMStringList = (function() {
    function XMLDOMStringList(arr) {
      this.arr = arr || [];
    }

    Object.defineProperty(XMLDOMStringList.prototype, 'length', {
      get: function() {
        return this.arr.length;
      }
    });

    XMLDOMStringList.prototype.item = function(index) {
      return this.arr[index] || null;
    };

    XMLDOMStringList.prototype.contains = function(str) {
      return this.arr.indexOf(str) !== -1;
    };

    return XMLDOMStringList;

  })();

}).call(this);

},{}],99:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDTDAttList, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  NodeType = require('./NodeType');

  module.exports = XMLDTDAttList = (function(superClass) {
    extend(XMLDTDAttList, superClass);

    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      XMLDTDAttList.__super__.constructor.call(this, parent);
      if (elementName == null) {
        throw new Error("Missing DTD element name. " + this.debugInfo());
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
      }
      this.elementName = this.stringify.name(elementName);
      this.type = NodeType.AttributeDeclaration;
      this.attributeName = this.stringify.name(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      if (defaultValue) {
        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      }
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.toString = function(options) {
      return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
    };

    return XMLDTDAttList;

  })(XMLNode);

}).call(this);

},{"./NodeType":88,"./XMLNode":110}],100:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDTDElement, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  NodeType = require('./NodeType');

  module.exports = XMLDTDElement = (function(superClass) {
    extend(XMLDTDElement, superClass);

    function XMLDTDElement(parent, name, value) {
      XMLDTDElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD element name. " + this.debugInfo());
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (Array.isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.name(name);
      this.type = NodeType.ElementDeclaration;
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.toString = function(options) {
      return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
    };

    return XMLDTDElement;

  })(XMLNode);

}).call(this);

},{"./NodeType":88,"./XMLNode":110}],101:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDTDEntity, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = require('./Utility').isObject;

  XMLNode = require('./XMLNode');

  NodeType = require('./NodeType');

  module.exports = XMLDTDEntity = (function(superClass) {
    extend(XMLDTDEntity, superClass);

    function XMLDTDEntity(parent, pe, name, value) {
      XMLDTDEntity.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD entity name. " + this.debugInfo(name));
      }
      if (value == null) {
        throw new Error("Missing DTD entity value. " + this.debugInfo(name));
      }
      this.pe = !!pe;
      this.name = this.stringify.name(name);
      this.type = NodeType.EntityDeclaration;
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
        this.internal = true;
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
        }
        this.internal = false;
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
        }
      }
    }

    Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {
      get: function() {
        return this.pubID;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {
      get: function() {
        return this.sysID;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {
      get: function() {
        return this.nData || null;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {
      get: function() {
        return null;
      }
    });

    XMLDTDEntity.prototype.toString = function(options) {
      return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
    };

    return XMLDTDEntity;

  })(XMLNode);

}).call(this);

},{"./NodeType":88,"./Utility":89,"./XMLNode":110}],102:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDTDNotation, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  NodeType = require('./NodeType');

  module.exports = XMLDTDNotation = (function(superClass) {
    extend(XMLDTDNotation, superClass);

    function XMLDTDNotation(parent, name, value) {
      XMLDTDNotation.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD notation name. " + this.debugInfo(name));
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
      }
      this.name = this.stringify.name(name);
      this.type = NodeType.NotationDeclaration;
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {
      get: function() {
        return this.pubID;
      }
    });

    Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {
      get: function() {
        return this.sysID;
      }
    });

    XMLDTDNotation.prototype.toString = function(options) {
      return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
    };

    return XMLDTDNotation;

  })(XMLNode);

}).call(this);

},{"./NodeType":88,"./XMLNode":110}],103:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDeclaration, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = require('./Utility').isObject;

  XMLNode = require('./XMLNode');

  NodeType = require('./NodeType');

  module.exports = XMLDeclaration = (function(superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      this.type = NodeType.Declaration;
      this.version = this.stringify.xmlVersion(version);
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.toString = function(options) {
      return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
    };

    return XMLDeclaration;

  })(XMLNode);

}).call(this);

},{"./NodeType":88,"./Utility":89,"./XMLNode":110}],104:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = require('./Utility').isObject;

  XMLNode = require('./XMLNode');

  NodeType = require('./NodeType');

  XMLDTDAttList = require('./XMLDTDAttList');

  XMLDTDEntity = require('./XMLDTDEntity');

  XMLDTDElement = require('./XMLDTDElement');

  XMLDTDNotation = require('./XMLDTDNotation');

  XMLNamedNodeMap = require('./XMLNamedNodeMap');

  module.exports = XMLDocType = (function(superClass) {
    extend(XMLDocType, superClass);

    function XMLDocType(parent, pubID, sysID) {
      var child, i, len, ref, ref1, ref2;
      XMLDocType.__super__.constructor.call(this, parent);
      this.type = NodeType.DocType;
      if (parent.children) {
        ref = parent.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (child.type === NodeType.Element) {
            this.name = child.name;
            break;
          }
        }
      }
      this.documentObject = parent;
      if (isObject(pubID)) {
        ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
      }
      if (sysID == null) {
        ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    Object.defineProperty(XMLDocType.prototype, 'entities', {
      get: function() {
        var child, i, len, nodes, ref;
        nodes = {};
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if ((child.type === NodeType.EntityDeclaration) && !child.pe) {
            nodes[child.name] = child;
          }
        }
        return new XMLNamedNodeMap(nodes);
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'notations', {
      get: function() {
        var child, i, len, nodes, ref;
        nodes = {};
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (child.type === NodeType.NotationDeclaration) {
            nodes[child.name] = child;
          }
        }
        return new XMLNamedNodeMap(nodes);
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'publicId', {
      get: function() {
        return this.pubID;
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'systemId', {
      get: function() {
        return this.sysID;
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'internalSubset', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    XMLDocType.prototype.element = function(name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function(name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.toString = function(options) {
      return this.options.writer.docType(this, this.options.writer.filterOptions(options));
    };

    XMLDocType.prototype.ele = function(name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.up = function() {
      return this.root() || this.documentObject;
    };

    XMLDocType.prototype.isEqualNode = function(node) {
      if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
        return false;
      }
      if (node.name !== this.name) {
        return false;
      }
      if (node.publicId !== this.publicId) {
        return false;
      }
      if (node.systemId !== this.systemId) {
        return false;
      }
      return true;
    };

    return XMLDocType;

  })(XMLNode);

}).call(this);

},{"./NodeType":88,"./Utility":89,"./XMLDTDAttList":99,"./XMLDTDElement":100,"./XMLDTDEntity":101,"./XMLDTDNotation":102,"./XMLNamedNodeMap":109,"./XMLNode":110}],105:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isPlainObject = require('./Utility').isPlainObject;

  XMLDOMImplementation = require('./XMLDOMImplementation');

  XMLDOMConfiguration = require('./XMLDOMConfiguration');

  XMLNode = require('./XMLNode');

  NodeType = require('./NodeType');

  XMLStringifier = require('./XMLStringifier');

  XMLStringWriter = require('./XMLStringWriter');

  module.exports = XMLDocument = (function(superClass) {
    extend(XMLDocument, superClass);

    function XMLDocument(options) {
      XMLDocument.__super__.constructor.call(this, null);
      this.name = "#document";
      this.type = NodeType.Document;
      this.documentURI = null;
      this.domConfig = new XMLDOMConfiguration();
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter();
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
    }

    Object.defineProperty(XMLDocument.prototype, 'implementation', {
      value: new XMLDOMImplementation()
    });

    Object.defineProperty(XMLDocument.prototype, 'doctype', {
      get: function() {
        var child, i, len, ref;
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (child.type === NodeType.DocType) {
            return child;
          }
        }
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'documentElement', {
      get: function() {
        return this.rootObject || null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {
      get: function() {
        return false;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {
      get: function() {
        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
          return this.children[0].encoding;
        } else {
          return null;
        }
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {
      get: function() {
        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
          return this.children[0].standalone === 'yes';
        } else {
          return false;
        }
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {
      get: function() {
        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
          return this.children[0].version;
        } else {
          return "1.0";
        }
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'URL', {
      get: function() {
        return this.documentURI;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'origin', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'compatMode', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'characterSet', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'contentType', {
      get: function() {
        return null;
      }
    });

    XMLDocument.prototype.end = function(writer) {
      var writerOptions;
      writerOptions = {};
      if (!writer) {
        writer = this.options.writer;
      } else if (isPlainObject(writer)) {
        writerOptions = writer;
        writer = this.options.writer;
      }
      return writer.document(this, writer.filterOptions(writerOptions));
    };

    XMLDocument.prototype.toString = function(options) {
      return this.options.writer.document(this, this.options.writer.filterOptions(options));
    };

    XMLDocument.prototype.createElement = function(tagName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createDocumentFragment = function() {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createTextNode = function(data) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createComment = function(data) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createCDATASection = function(data) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createProcessingInstruction = function(target, data) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createAttribute = function(name) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createEntityReference = function(name) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.getElementsByTagName = function(tagname) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.importNode = function(importedNode, deep) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.getElementById = function(elementId) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.adoptNode = function(source) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.normalizeDocument = function() {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.getElementsByClassName = function(classNames) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createEvent = function(eventInterface) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createRange = function() {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    return XMLDocument;

  })(XMLNode);

}).call(this);

},{"./NodeType":88,"./Utility":89,"./XMLDOMConfiguration":95,"./XMLDOMImplementation":97,"./XMLNode":110,"./XMLStringWriter":115,"./XMLStringifier":116}],106:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref,
    hasProp = {}.hasOwnProperty;

  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;

  NodeType = require('./NodeType');

  XMLDocument = require('./XMLDocument');

  XMLElement = require('./XMLElement');

  XMLCData = require('./XMLCData');

  XMLComment = require('./XMLComment');

  XMLRaw = require('./XMLRaw');

  XMLText = require('./XMLText');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  XMLDeclaration = require('./XMLDeclaration');

  XMLDocType = require('./XMLDocType');

  XMLDTDAttList = require('./XMLDTDAttList');

  XMLDTDEntity = require('./XMLDTDEntity');

  XMLDTDElement = require('./XMLDTDElement');

  XMLDTDNotation = require('./XMLDTDNotation');

  XMLAttribute = require('./XMLAttribute');

  XMLStringifier = require('./XMLStringifier');

  XMLStringWriter = require('./XMLStringWriter');

  WriterState = require('./WriterState');

  module.exports = XMLDocumentCB = (function() {
    function XMLDocumentCB(options, onData, onEnd) {
      var writerOptions;
      this.name = "?xml";
      this.type = NodeType.Document;
      options || (options = {});
      writerOptions = {};
      if (!options.writer) {
        options.writer = new XMLStringWriter();
      } else if (isPlainObject(options.writer)) {
        writerOptions = options.writer;
        options.writer = new XMLStringWriter();
      }
      this.options = options;
      this.writer = options.writer;
      this.writerOptions = this.writer.filterOptions(writerOptions);
      this.stringify = new XMLStringifier(options);
      this.onDataCallback = onData || function() {};
      this.onEndCallback = onEnd || function() {};
      this.currentNode = null;
      this.currentLevel = -1;
      this.openTags = {};
      this.documentStarted = false;
      this.documentCompleted = false;
      this.root = null;
    }

    XMLDocumentCB.prototype.createChildNode = function(node) {
      var att, attName, attributes, child, i, len, ref1, ref2;
      switch (node.type) {
        case NodeType.CData:
          this.cdata(node.value);
          break;
        case NodeType.Comment:
          this.comment(node.value);
          break;
        case NodeType.Element:
          attributes = {};
          ref1 = node.attribs;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName)) continue;
            att = ref1[attName];
            attributes[attName] = att.value;
          }
          this.node(node.name, attributes);
          break;
        case NodeType.Dummy:
          this.dummy();
          break;
        case NodeType.Raw:
          this.raw(node.value);
          break;
        case NodeType.Text:
          this.text(node.value);
          break;
        case NodeType.ProcessingInstruction:
          this.instruction(node.target, node.value);
          break;
        default:
          throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
      }
      ref2 = node.children;
      for (i = 0, len = ref2.length; i < len; i++) {
        child = ref2[i];
        this.createChildNode(child);
        if (child.type === NodeType.Element) {
          this.up();
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.dummy = function() {
      return this;
    };

    XMLDocumentCB.prototype.node = function(name, attributes, text) {
      var ref1;
      if (name == null) {
        throw new Error("Missing node name.");
      }
      if (this.root && this.currentLevel === -1) {
        throw new Error("Document can only have one root node. " + this.debugInfo(name));
      }
      this.openCurrent();
      name = getValue(name);
      if (attributes == null) {
        attributes = {};
      }
      attributes = getValue(attributes);
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      this.currentNode = new XMLElement(this, name, attributes);
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      if (text != null) {
        this.text(text);
      }
      return this;
    };

    XMLDocumentCB.prototype.element = function(name, attributes, text) {
      var child, i, len, oldValidationFlag, ref1, root;
      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
        this.dtdElement.apply(this, arguments);
      } else {
        if (Array.isArray(name) || isObject(name) || isFunction(name)) {
          oldValidationFlag = this.options.noValidation;
          this.options.noValidation = true;
          root = new XMLDocument(this.options).element('TEMP_ROOT');
          root.element(name);
          this.options.noValidation = oldValidationFlag;
          ref1 = root.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
        } else {
          this.node(name, attributes, text);
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (!this.currentNode || this.currentNode.children) {
        throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
      }
      if (name != null) {
        name = getValue(name);
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (this.options.keepNullAttributes && (value == null)) {
          this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
        } else if (value != null) {
          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.text = function(value) {
      var node;
      this.openCurrent();
      node = new XMLText(this, value);
      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.cdata = function(value) {
      var node;
      this.openCurrent();
      node = new XMLCData(this, value);
      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.comment = function(value) {
      var node;
      this.openCurrent();
      node = new XMLComment(this, value);
      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.raw = function(value) {
      var node;
      this.openCurrent();
      node = new XMLRaw(this, value);
      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.instruction = function(target, value) {
      var i, insTarget, insValue, len, node;
      this.openCurrent();
      if (target != null) {
        target = getValue(target);
      }
      if (value != null) {
        value = getValue(value);
      }
      if (Array.isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        node = new XMLProcessingInstruction(this, target, value);
        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      }
      return this;
    };

    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
      var node;
      this.openCurrent();
      if (this.documentStarted) {
        throw new Error("declaration() must be the first node.");
      }
      node = new XMLDeclaration(this, version, encoding, standalone);
      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
      this.openCurrent();
      if (root == null) {
        throw new Error("Missing root node name.");
      }
      if (this.root) {
        throw new Error("dtd() must come before the root node.");
      }
      this.currentNode = new XMLDocType(this, pubID, sysID);
      this.currentNode.rootNodeName = root;
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      return this;
    };

    XMLDocumentCB.prototype.dtdElement = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDElement(this, name, value);
      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var node;
      this.openCurrent();
      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.entity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, false, name, value);
      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.pEntity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, true, name, value);
      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.notation = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDNotation(this, name, value);
      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.up = function() {
      if (this.currentLevel < 0) {
        throw new Error("The document node has no parent.");
      }
      if (this.currentNode) {
        if (this.currentNode.children) {
          this.closeNode(this.currentNode);
        } else {
          this.openNode(this.currentNode);
        }
        this.currentNode = null;
      } else {
        this.closeNode(this.openTags[this.currentLevel]);
      }
      delete this.openTags[this.currentLevel];
      this.currentLevel--;
      return this;
    };

    XMLDocumentCB.prototype.end = function() {
      while (this.currentLevel >= 0) {
        this.up();
      }
      return this.onEnd();
    };

    XMLDocumentCB.prototype.openCurrent = function() {
      if (this.currentNode) {
        this.currentNode.children = true;
        return this.openNode(this.currentNode);
      }
    };

    XMLDocumentCB.prototype.openNode = function(node) {
      var att, chunk, name, ref1;
      if (!node.isOpen) {
        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
          this.root = node;
        }
        chunk = '';
        if (node.type === NodeType.Element) {
          this.writerOptions.state = WriterState.OpenTag;
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;
          ref1 = node.attribs;
          for (name in ref1) {
            if (!hasProp.call(ref1, name)) continue;
            att = ref1[name];
            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
          }
          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);
          this.writerOptions.state = WriterState.InsideTag;
        } else {
          this.writerOptions.state = WriterState.OpenTag;
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;
          if (node.pubID && node.sysID) {
            chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            chunk += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children) {
            chunk += ' [';
            this.writerOptions.state = WriterState.InsideTag;
          } else {
            this.writerOptions.state = WriterState.CloseTag;
            chunk += '>';
          }
          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
        }
        this.onData(chunk, this.currentLevel);
        return node.isOpen = true;
      }
    };

    XMLDocumentCB.prototype.closeNode = function(node) {
      var chunk;
      if (!node.isClosed) {
        chunk = '';
        this.writerOptions.state = WriterState.CloseTag;
        if (node.type === NodeType.Element) {
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
        } else {
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
        }
        this.writerOptions.state = WriterState.None;
        this.onData(chunk, this.currentLevel);
        return node.isClosed = true;
      }
    };

    XMLDocumentCB.prototype.onData = function(chunk, level) {
      this.documentStarted = true;
      return this.onDataCallback(chunk, level + 1);
    };

    XMLDocumentCB.prototype.onEnd = function() {
      this.documentCompleted = true;
      return this.onEndCallback();
    };

    XMLDocumentCB.prototype.debugInfo = function(name) {
      if (name == null) {
        return "";
      } else {
        return "node: <" + name + ">";
      }
    };

    XMLDocumentCB.prototype.ele = function() {
      return this.element.apply(this, arguments);
    };

    XMLDocumentCB.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
      return this.doctype(root, pubID, sysID);
    };

    XMLDocumentCB.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLDocumentCB.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.t = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLDocumentCB.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.att = function() {
      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.a = function() {
      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocumentCB.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocumentCB.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    return XMLDocumentCB;

  })();

}).call(this);

},{"./NodeType":88,"./Utility":89,"./WriterState":90,"./XMLAttribute":91,"./XMLCData":92,"./XMLComment":94,"./XMLDTDAttList":99,"./XMLDTDElement":100,"./XMLDTDEntity":101,"./XMLDTDNotation":102,"./XMLDeclaration":103,"./XMLDocType":104,"./XMLDocument":105,"./XMLElement":108,"./XMLProcessingInstruction":112,"./XMLRaw":113,"./XMLStringWriter":115,"./XMLStringifier":116,"./XMLText":117}],107:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDummy, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  NodeType = require('./NodeType');

  module.exports = XMLDummy = (function(superClass) {
    extend(XMLDummy, superClass);

    function XMLDummy(parent) {
      XMLDummy.__super__.constructor.call(this, parent);
      this.type = NodeType.Dummy;
    }

    XMLDummy.prototype.clone = function() {
      return Object.create(this);
    };

    XMLDummy.prototype.toString = function(options) {
      return '';
    };

    return XMLDummy;

  })(XMLNode);

}).call(this);

},{"./NodeType":88,"./XMLNode":110}],108:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;

  XMLNode = require('./XMLNode');

  NodeType = require('./NodeType');

  XMLAttribute = require('./XMLAttribute');

  XMLNamedNodeMap = require('./XMLNamedNodeMap');

  module.exports = XMLElement = (function(superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      var child, j, len, ref1;
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name. " + this.debugInfo());
      }
      this.name = this.stringify.name(name);
      this.type = NodeType.Element;
      this.attribs = {};
      this.schemaTypeInfo = null;
      if (attributes != null) {
        this.attribute(attributes);
      }
      if (parent.type === NodeType.Document) {
        this.isRoot = true;
        this.documentObject = parent;
        parent.rootObject = this;
        if (parent.children) {
          ref1 = parent.children;
          for (j = 0, len = ref1.length; j < len; j++) {
            child = ref1[j];
            if (child.type === NodeType.DocType) {
              child.name = this.name;
              break;
            }
          }
        }
      }
    }

    Object.defineProperty(XMLElement.prototype, 'tagName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLElement.prototype, 'namespaceURI', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLElement.prototype, 'prefix', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLElement.prototype, 'localName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLElement.prototype, 'id', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLElement.prototype, 'className', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLElement.prototype, 'classList', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLElement.prototype, 'attributes', {
      get: function() {
        if (!this.attributeMap || !this.attributeMap.nodes) {
          this.attributeMap = new XMLNamedNodeMap(this.attribs);
        }
        return this.attributeMap;
      }
    });

    XMLElement.prototype.clone = function() {
      var att, attName, clonedSelf, ref1;
      clonedSelf = Object.create(this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attribs = {};
      ref1 = this.attribs;
      for (attName in ref1) {
        if (!hasProp.call(ref1, attName)) continue;
        att = ref1[attName];
        clonedSelf.attribs[attName] = att.clone();
      }
      clonedSelf.children = [];
      this.children.forEach(function(child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (name != null) {
        name = getValue(name);
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (this.options.keepNullAttributes && (value == null)) {
          this.attribs[name] = new XMLAttribute(this, name, "");
        } else if (value != null) {
          this.attribs[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function(name) {
      var attName, j, len;
      if (name == null) {
        throw new Error("Missing attribute name. " + this.debugInfo());
      }
      name = getValue(name);
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          attName = name[j];
          delete this.attribs[attName];
        }
      } else {
        delete this.attribs[name];
      }
      return this;
    };

    XMLElement.prototype.toString = function(options) {
      return this.options.writer.element(this, this.options.writer.filterOptions(options));
    };

    XMLElement.prototype.att = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.a = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.getAttribute = function(name) {
      if (this.attribs.hasOwnProperty(name)) {
        return this.attribs[name].value;
      } else {
        return null;
      }
    };

    XMLElement.prototype.setAttribute = function(name, value) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getAttributeNode = function(name) {
      if (this.attribs.hasOwnProperty(name)) {
        return this.attribs[name];
      } else {
        return null;
      }
    };

    XMLElement.prototype.setAttributeNode = function(newAttr) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.removeAttributeNode = function(oldAttr) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getElementsByTagName = function(name) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.hasAttribute = function(name) {
      return this.attribs.hasOwnProperty(name);
    };

    XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.setIdAttribute = function(name, isId) {
      if (this.attribs.hasOwnProperty(name)) {
        return this.attribs[name].isId;
      } else {
        return isId;
      }
    };

    XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getElementsByTagName = function(tagname) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getElementsByClassName = function(classNames) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.isEqualNode = function(node) {
      var i, j, ref1;
      if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
        return false;
      }
      if (node.namespaceURI !== this.namespaceURI) {
        return false;
      }
      if (node.prefix !== this.prefix) {
        return false;
      }
      if (node.localName !== this.localName) {
        return false;
      }
      if (node.attribs.length !== this.attribs.length) {
        return false;
      }
      for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
        if (!this.attribs[i].isEqualNode(node.attribs[i])) {
          return false;
        }
      }
      return true;
    };

    return XMLElement;

  })(XMLNode);

}).call(this);

},{"./NodeType":88,"./Utility":89,"./XMLAttribute":91,"./XMLNamedNodeMap":109,"./XMLNode":110}],109:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNamedNodeMap;

  module.exports = XMLNamedNodeMap = (function() {
    function XMLNamedNodeMap(nodes) {
      this.nodes = nodes;
    }

    Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {
      get: function() {
        return Object.keys(this.nodes).length || 0;
      }
    });

    XMLNamedNodeMap.prototype.clone = function() {
      return this.nodes = null;
    };

    XMLNamedNodeMap.prototype.getNamedItem = function(name) {
      return this.nodes[name];
    };

    XMLNamedNodeMap.prototype.setNamedItem = function(node) {
      var oldNode;
      oldNode = this.nodes[node.nodeName];
      this.nodes[node.nodeName] = node;
      return oldNode || null;
    };

    XMLNamedNodeMap.prototype.removeNamedItem = function(name) {
      var oldNode;
      oldNode = this.nodes[name];
      delete this.nodes[name];
      return oldNode || null;
    };

    XMLNamedNodeMap.prototype.item = function(index) {
      return this.nodes[Object.keys(this.nodes)[index]] || null;
    };

    XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented.");
    };

    XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {
      throw new Error("This DOM method is not implemented.");
    };

    XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented.");
    };

    return XMLNamedNodeMap;

  })();

}).call(this);

},{}],110:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1,
    hasProp = {}.hasOwnProperty;

  ref1 = require('./Utility'), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  XMLProcessingInstruction = null;

  XMLDummy = null;

  NodeType = null;

  XMLNodeList = null;

  XMLNamedNodeMap = null;

  DocumentPosition = null;

  module.exports = XMLNode = (function() {
    function XMLNode(parent1) {
      this.parent = parent1;
      if (this.parent) {
        this.options = this.parent.options;
        this.stringify = this.parent.stringify;
      }
      this.value = null;
      this.children = [];
      this.baseURI = null;
      if (!XMLElement) {
        XMLElement = require('./XMLElement');
        XMLCData = require('./XMLCData');
        XMLComment = require('./XMLComment');
        XMLDeclaration = require('./XMLDeclaration');
        XMLDocType = require('./XMLDocType');
        XMLRaw = require('./XMLRaw');
        XMLText = require('./XMLText');
        XMLProcessingInstruction = require('./XMLProcessingInstruction');
        XMLDummy = require('./XMLDummy');
        NodeType = require('./NodeType');
        XMLNodeList = require('./XMLNodeList');
        XMLNamedNodeMap = require('./XMLNamedNodeMap');
        DocumentPosition = require('./DocumentPosition');
      }
    }

    Object.defineProperty(XMLNode.prototype, 'nodeName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'nodeType', {
      get: function() {
        return this.type;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'nodeValue', {
      get: function() {
        return this.value;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'parentNode', {
      get: function() {
        return this.parent;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'childNodes', {
      get: function() {
        if (!this.childNodeList || !this.childNodeList.nodes) {
          this.childNodeList = new XMLNodeList(this.children);
        }
        return this.childNodeList;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'firstChild', {
      get: function() {
        return this.children[0] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'lastChild', {
      get: function() {
        return this.children[this.children.length - 1] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'previousSibling', {
      get: function() {
        var i;
        i = this.parent.children.indexOf(this);
        return this.parent.children[i - 1] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'nextSibling', {
      get: function() {
        var i;
        i = this.parent.children.indexOf(this);
        return this.parent.children[i + 1] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {
      get: function() {
        return this.document() || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'textContent', {
      get: function() {
        var child, j, len, ref2, str;
        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
          str = '';
          ref2 = this.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (child.textContent) {
              str += child.textContent;
            }
          }
          return str;
        } else {
          return null;
        }
      },
      set: function(value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    XMLNode.prototype.setParent = function(parent) {
      var child, j, len, ref2, results;
      this.parent = parent;
      if (parent) {
        this.options = parent.options;
        this.stringify = parent.stringify;
      }
      ref2 = this.children;
      results = [];
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        results.push(child.setParent(this));
      }
      return results;
    };

    XMLNode.prototype.element = function(name, attributes, text) {
      var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
      lastChild = null;
      if (attributes === null && (text == null)) {
        ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
      }
      if (attributes == null) {
        attributes = {};
      }
      attributes = getValue(attributes);
      if (!isObject(attributes)) {
        ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
      }
      if (name != null) {
        name = getValue(name);
      }
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
            lastChild = this.dummy();
          } else if (isObject(val) && isEmpty(val)) {
            lastChild = this.element(key);
          } else if (!this.options.keepNullNodes && (val == null)) {
            lastChild = this.dummy();
          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
            for (k = 0, len1 = val.length; k < len1; k++) {
              item = val[k];
              childNode = {};
              childNode[key] = item;
              lastChild = this.element(childNode);
            }
          } else if (isObject(val)) {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.element(val);
            } else {
              lastChild = this.element(key);
              lastChild.element(val);
            }
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else if (!this.options.keepNullNodes && text === null) {
        lastChild = this.dummy();
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function(name, attributes, text) {
      var child, i, newChild, refChild, removed;
      if (name != null ? name.type : void 0) {
        newChild = name;
        refChild = attributes;
        newChild.setParent(this);
        if (refChild) {
          i = children.indexOf(refChild);
          removed = children.splice(i);
          children.push(newChild);
          Array.prototype.push.apply(children, removed);
        } else {
          children.push(newChild);
        }
        return newChild;
      } else {
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        }
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      }
    };

    XMLNode.prototype.insertAfter = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function() {
      var i, ref2;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element. " + this.debugInfo());
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;
      return this.parent;
    };

    XMLNode.prototype.node = function(name, attributes, text) {
      var child, ref2;
      if (name != null) {
        name = getValue(name);
      }
      attributes || (attributes = {});
      attributes = getValue(attributes);
      if (!isObject(attributes)) {
        ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function(value) {
      var child;
      if (isObject(value)) {
        this.element(value);
      }
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.commentBefore = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.commentAfter = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.raw = function(value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.dummy = function() {
      var child;
      child = new XMLDummy(this);
      return child;
    };

    XMLNode.prototype.instruction = function(target, value) {
      var insTarget, insValue, instruction, j, len;
      if (target != null) {
        target = getValue(target);
      }
      if (value != null) {
        value = getValue(value);
      }
      if (Array.isArray(target)) {
        for (j = 0, len = target.length; j < len; j++) {
          insTarget = target[j];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.children.push(instruction);
      }
      return this;
    };

    XMLNode.prototype.instructionBefore = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.instructionAfter = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.declaration = function(version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      if (doc.children.length === 0) {
        doc.children.unshift(xmldec);
      } else if (doc.children[0].type === NodeType.Declaration) {
        doc.children[0] = xmldec;
      } else {
        doc.children.unshift(xmldec);
      }
      return doc.root() || doc;
    };

    XMLNode.prototype.dtd = function(pubID, sysID) {
      var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      ref2 = doc.children;
      for (i = j = 0, len = ref2.length; j < len; i = ++j) {
        child = ref2[i];
        if (child.type === NodeType.DocType) {
          doc.children[i] = doctype;
          return doctype;
        }
      }
      ref3 = doc.children;
      for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
        child = ref3[i];
        if (child.isRoot) {
          doc.children.splice(i, 0, doctype);
          return doctype;
        }
      }
      doc.children.push(doctype);
      return doctype;
    };

    XMLNode.prototype.up = function() {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function() {
      var node;
      node = this;
      while (node) {
        if (node.type === NodeType.Document) {
          return node.rootObject;
        } else if (node.isRoot) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.document = function() {
      var node;
      node = this;
      while (node) {
        if (node.type === NodeType.Document) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.end = function(options) {
      return this.document().end(options);
    };

    XMLNode.prototype.prev = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node. " + this.debugInfo());
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node. " + this.debugInfo());
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importDocument = function(doc) {
      var clonedRoot;
      clonedRoot = doc.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.debugInfo = function(name) {
      var ref2, ref3;
      name = name || this.name;
      if ((name == null) && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
        return "";
      } else if (name == null) {
        return "parent: <" + this.parent.name + ">";
      } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
        return "node: <" + name + ">";
      } else {
        return "node: <" + name + ">, parent: <" + this.parent.name + ">";
      }
    };

    XMLNode.prototype.ele = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.doc = function() {
      return this.document();
    };

    XMLNode.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLNode.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.u = function() {
      return this.up();
    };

    XMLNode.prototype.importXMLBuilder = function(doc) {
      return this.importDocument(doc);
    };

    XMLNode.prototype.replaceChild = function(newChild, oldChild) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.removeChild = function(oldChild) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.appendChild = function(newChild) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.hasChildNodes = function() {
      return this.children.length !== 0;
    };

    XMLNode.prototype.cloneNode = function(deep) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.normalize = function() {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.isSupported = function(feature, version) {
      return true;
    };

    XMLNode.prototype.hasAttributes = function() {
      return this.attribs.length !== 0;
    };

    XMLNode.prototype.compareDocumentPosition = function(other) {
      var ref, res;
      ref = this;
      if (ref === other) {
        return 0;
      } else if (this.document() !== other.document()) {
        res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
        if (Math.random() < 0.5) {
          res |= DocumentPosition.Preceding;
        } else {
          res |= DocumentPosition.Following;
        }
        return res;
      } else if (ref.isAncestor(other)) {
        return DocumentPosition.Contains | DocumentPosition.Preceding;
      } else if (ref.isDescendant(other)) {
        return DocumentPosition.Contains | DocumentPosition.Following;
      } else if (ref.isPreceding(other)) {
        return DocumentPosition.Preceding;
      } else {
        return DocumentPosition.Following;
      }
    };

    XMLNode.prototype.isSameNode = function(other) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.lookupPrefix = function(namespaceURI) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.lookupNamespaceURI = function(prefix) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.isEqualNode = function(node) {
      var i, j, ref2;
      if (node.nodeType !== this.nodeType) {
        return false;
      }
      if (node.children.length !== this.children.length) {
        return false;
      }
      for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
        if (!this.children[i].isEqualNode(node.children[i])) {
          return false;
        }
      }
      return true;
    };

    XMLNode.prototype.getFeature = function(feature, version) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.setUserData = function(key, data, handler) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.getUserData = function(key) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.contains = function(other) {
      if (!other) {
        return false;
      }
      return other === this || this.isDescendant(other);
    };

    XMLNode.prototype.isDescendant = function(node) {
      var child, isDescendantChild, j, len, ref2;
      ref2 = this.children;
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        if (node === child) {
          return true;
        }
        isDescendantChild = child.isDescendant(node);
        if (isDescendantChild) {
          return true;
        }
      }
      return false;
    };

    XMLNode.prototype.isAncestor = function(node) {
      return node.isDescendant(this);
    };

    XMLNode.prototype.isPreceding = function(node) {
      var nodePos, thisPos;
      nodePos = this.treePosition(node);
      thisPos = this.treePosition(this);
      if (nodePos === -1 || thisPos === -1) {
        return false;
      } else {
        return nodePos < thisPos;
      }
    };

    XMLNode.prototype.isFollowing = function(node) {
      var nodePos, thisPos;
      nodePos = this.treePosition(node);
      thisPos = this.treePosition(this);
      if (nodePos === -1 || thisPos === -1) {
        return false;
      } else {
        return nodePos > thisPos;
      }
    };

    XMLNode.prototype.treePosition = function(node) {
      var found, pos;
      pos = 0;
      found = false;
      this.foreachTreeNode(this.document(), function(childNode) {
        pos++;
        if (!found && childNode === node) {
          return found = true;
        }
      });
      if (found) {
        return pos;
      } else {
        return -1;
      }
    };

    XMLNode.prototype.foreachTreeNode = function(node, func) {
      var child, j, len, ref2, res;
      node || (node = this.document());
      ref2 = node.children;
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        if (res = func(child)) {
          return res;
        } else {
          res = this.foreachTreeNode(child, func);
          if (res) {
            return res;
          }
        }
      }
    };

    return XMLNode;

  })();

}).call(this);

},{"./DocumentPosition":87,"./NodeType":88,"./Utility":89,"./XMLCData":92,"./XMLComment":94,"./XMLDeclaration":103,"./XMLDocType":104,"./XMLDummy":107,"./XMLElement":108,"./XMLNamedNodeMap":109,"./XMLNodeList":111,"./XMLProcessingInstruction":112,"./XMLRaw":113,"./XMLText":117}],111:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNodeList;

  module.exports = XMLNodeList = (function() {
    function XMLNodeList(nodes) {
      this.nodes = nodes;
    }

    Object.defineProperty(XMLNodeList.prototype, 'length', {
      get: function() {
        return this.nodes.length || 0;
      }
    });

    XMLNodeList.prototype.clone = function() {
      return this.nodes = null;
    };

    XMLNodeList.prototype.item = function(index) {
      return this.nodes[index] || null;
    };

    return XMLNodeList;

  })();

}).call(this);

},{}],112:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLCharacterData, XMLProcessingInstruction,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = require('./NodeType');

  XMLCharacterData = require('./XMLCharacterData');

  module.exports = XMLProcessingInstruction = (function(superClass) {
    extend(XMLProcessingInstruction, superClass);

    function XMLProcessingInstruction(parent, target, value) {
      XMLProcessingInstruction.__super__.constructor.call(this, parent);
      if (target == null) {
        throw new Error("Missing instruction target. " + this.debugInfo());
      }
      this.type = NodeType.ProcessingInstruction;
      this.target = this.stringify.insTarget(target);
      this.name = this.target;
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function() {
      return Object.create(this);
    };

    XMLProcessingInstruction.prototype.toString = function(options) {
      return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
    };

    XMLProcessingInstruction.prototype.isEqualNode = function(node) {
      if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
        return false;
      }
      if (node.target !== this.target) {
        return false;
      }
      return true;
    };

    return XMLProcessingInstruction;

  })(XMLCharacterData);

}).call(this);

},{"./NodeType":88,"./XMLCharacterData":93}],113:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLNode, XMLRaw,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = require('./NodeType');

  XMLNode = require('./XMLNode');

  module.exports = XMLRaw = (function(superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text. " + this.debugInfo());
      }
      this.type = NodeType.Raw;
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function() {
      return Object.create(this);
    };

    XMLRaw.prototype.toString = function(options) {
      return this.options.writer.raw(this, this.options.writer.filterOptions(options));
    };

    return XMLRaw;

  })(XMLNode);

}).call(this);

},{"./NodeType":88,"./XMLNode":110}],114:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, WriterState, XMLStreamWriter, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = require('./NodeType');

  XMLWriterBase = require('./XMLWriterBase');

  WriterState = require('./WriterState');

  module.exports = XMLStreamWriter = (function(superClass) {
    extend(XMLStreamWriter, superClass);

    function XMLStreamWriter(stream, options) {
      this.stream = stream;
      XMLStreamWriter.__super__.constructor.call(this, options);
    }

    XMLStreamWriter.prototype.endline = function(node, options, level) {
      if (node.isLastRootNode && options.state === WriterState.CloseTag) {
        return '';
      } else {
        return XMLStreamWriter.__super__.endline.call(this, node, options, level);
      }
    };

    XMLStreamWriter.prototype.document = function(doc, options) {
      var child, i, j, k, len, len1, ref, ref1, results;
      ref = doc.children;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        child = ref[i];
        child.isLastRootNode = i === doc.children.length - 1;
      }
      options = this.filterOptions(options);
      ref1 = doc.children;
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        child = ref1[k];
        results.push(this.writeChildNode(child, options, 0));
      }
      return results;
    };

    XMLStreamWriter.prototype.attribute = function(att, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
    };

    XMLStreamWriter.prototype.cdata = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.comment = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.declaration = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.docType = function(node, options, level) {
      var child, j, len, ref;
      level || (level = 0);
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      this.stream.write(this.indent(node, options, level));
      this.stream.write('<!DOCTYPE ' + node.root().name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      if (node.children.length > 0) {
        this.stream.write(' [');
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.InsideTag;
        ref = node.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          this.writeChildNode(child, options, level + 1);
        }
        options.state = WriterState.CloseTag;
        this.stream.write(']');
      }
      options.state = WriterState.CloseTag;
      this.stream.write(options.spaceBeforeSlash + '>');
      this.stream.write(this.endline(node, options, level));
      options.state = WriterState.None;
      return this.closeNode(node, options, level);
    };

    XMLStreamWriter.prototype.element = function(node, options, level) {
      var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
      level || (level = 0);
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      this.stream.write(this.indent(node, options, level) + '<' + node.name);
      ref = node.attribs;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        this.attribute(att, options, level);
      }
      childNodeCount = node.children.length;
      firstChildNode = childNodeCount === 0 ? null : node.children[0];
      if (childNodeCount === 0 || node.children.every(function(e) {
        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
      })) {
        if (options.allowEmpty) {
          this.stream.write('>');
          options.state = WriterState.CloseTag;
          this.stream.write('</' + node.name + '>');
        } else {
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + '/>');
        }
      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {
        this.stream.write('>');
        options.state = WriterState.InsideTag;
        options.suppressPrettyCount++;
        prettySuppressed = true;
        this.writeChildNode(firstChildNode, options, level + 1);
        options.suppressPrettyCount--;
        prettySuppressed = false;
        options.state = WriterState.CloseTag;
        this.stream.write('</' + node.name + '>');
      } else {
        this.stream.write('>' + this.endline(node, options, level));
        options.state = WriterState.InsideTag;
        ref1 = node.children;
        for (j = 0, len = ref1.length; j < len; j++) {
          child = ref1[j];
          this.writeChildNode(child, options, level + 1);
        }
        options.state = WriterState.CloseTag;
        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');
      }
      this.stream.write(this.endline(node, options, level));
      options.state = WriterState.None;
      return this.closeNode(node, options, level);
    };

    XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.raw = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.text = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.dtdElement = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
    };

    return XMLStreamWriter;

  })(XMLWriterBase);

}).call(this);

},{"./NodeType":88,"./WriterState":90,"./XMLWriterBase":118}],115:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var XMLStringWriter, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLWriterBase = require('./XMLWriterBase');

  module.exports = XMLStringWriter = (function(superClass) {
    extend(XMLStringWriter, superClass);

    function XMLStringWriter(options) {
      XMLStringWriter.__super__.constructor.call(this, options);
    }

    XMLStringWriter.prototype.document = function(doc, options) {
      var child, i, len, r, ref;
      options = this.filterOptions(options);
      r = '';
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        r += this.writeChildNode(child, options, 0);
      }
      if (options.pretty && r.slice(-options.newline.length) === options.newline) {
        r = r.slice(0, -options.newline.length);
      }
      return r;
    };

    return XMLStringWriter;

  })(XMLWriterBase);

}).call(this);

},{"./XMLWriterBase":118}],116:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var XMLStringifier,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    function XMLStringifier(options) {
      this.assertLegalName = bind(this.assertLegalName, this);
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      options || (options = {});
      this.options = options;
      if (!this.options.version) {
        this.options.version = '1.0';
      }
      ref = options.stringify || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.name = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalName('' + val || '');
    };

    XMLStringifier.prototype.text = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar(this.textEscape('' + val || ''));
    };

    XMLStringifier.prototype.cdata = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      val = '' + val || '';
      val = val.replace(']]>', ']]]]><![CDATA[>');
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return '' + val || '';
    };

    XMLStringifier.prototype.attValue = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar(this.attEscape(val = '' + val || ''));
    };

    XMLStringifier.prototype.insTarget = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.insValue = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.xmlVersion = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      val = '' + val || '';
      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.xmlStandalone = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdSysID = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdElementValue = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdAttType = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdAttDefault = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdEntityValue = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdNData = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.assertLegalChar = function(str) {
      var regex, res;
      if (this.options.noValidation) {
        return str;
      }
      regex = '';
      if (this.options.version === '1.0') {
        regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        if (res = str.match(regex)) {
          throw new Error("Invalid character in string: " + str + " at index " + res.index);
        }
      } else if (this.options.version === '1.1') {
        regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        if (res = str.match(regex)) {
          throw new Error("Invalid character in string: " + str + " at index " + res.index);
        }
      }
      return str;
    };

    XMLStringifier.prototype.assertLegalName = function(str) {
      var regex;
      if (this.options.noValidation) {
        return str;
      }
      this.assertLegalChar(str);
      regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
      if (!str.match(regex)) {
        throw new Error("Invalid character in name");
      }
      return str;
    };

    XMLStringifier.prototype.textEscape = function(str) {
      var ampregex;
      if (this.options.noValidation) {
        return str;
      }
      ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function(str) {
      var ampregex;
      if (this.options.noValidation) {
        return str;
      }
      ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
    };

    return XMLStringifier;

  })();

}).call(this);

},{}],117:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLCharacterData, XMLText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = require('./NodeType');

  XMLCharacterData = require('./XMLCharacterData');

  module.exports = XMLText = (function(superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text. " + this.debugInfo());
      }
      this.name = "#text";
      this.type = NodeType.Text;
      this.value = this.stringify.text(text);
    }

    Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLText.prototype, 'wholeText', {
      get: function() {
        var next, prev, str;
        str = '';
        prev = this.previousSibling;
        while (prev) {
          str = prev.data + str;
          prev = prev.previousSibling;
        }
        str += this.data;
        next = this.nextSibling;
        while (next) {
          str = str + next.data;
          next = next.nextSibling;
        }
        return str;
      }
    });

    XMLText.prototype.clone = function() {
      return Object.create(this);
    };

    XMLText.prototype.toString = function(options) {
      return this.options.writer.text(this, this.options.writer.filterOptions(options));
    };

    XMLText.prototype.splitText = function(offset) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLText.prototype.replaceWholeText = function(content) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    return XMLText;

  })(XMLCharacterData);

}).call(this);

},{"./NodeType":88,"./XMLCharacterData":93}],118:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign,
    hasProp = {}.hasOwnProperty;

  assign = require('./Utility').assign;

  NodeType = require('./NodeType');

  XMLDeclaration = require('./XMLDeclaration');

  XMLDocType = require('./XMLDocType');

  XMLCData = require('./XMLCData');

  XMLComment = require('./XMLComment');

  XMLElement = require('./XMLElement');

  XMLRaw = require('./XMLRaw');

  XMLText = require('./XMLText');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  XMLDummy = require('./XMLDummy');

  XMLDTDAttList = require('./XMLDTDAttList');

  XMLDTDElement = require('./XMLDTDElement');

  XMLDTDEntity = require('./XMLDTDEntity');

  XMLDTDNotation = require('./XMLDTDNotation');

  WriterState = require('./WriterState');

  module.exports = XMLWriterBase = (function() {
    function XMLWriterBase(options) {
      var key, ref, value;
      options || (options = {});
      this.options = options;
      ref = options.writer || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this["_" + key] = this[key];
        this[key] = value;
      }
    }

    XMLWriterBase.prototype.filterOptions = function(options) {
      var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
      options || (options = {});
      options = assign({}, this.options, options);
      filteredOptions = {
        writer: this
      };
      filteredOptions.pretty = options.pretty || false;
      filteredOptions.allowEmpty = options.allowEmpty || false;
      filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';
      filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\n';
      filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
      filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
      filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';
      if (filteredOptions.spaceBeforeSlash === true) {
        filteredOptions.spaceBeforeSlash = ' ';
      }
      filteredOptions.suppressPrettyCount = 0;
      filteredOptions.user = {};
      filteredOptions.state = WriterState.None;
      return filteredOptions;
    };

    XMLWriterBase.prototype.indent = function(node, options, level) {
      var indentLevel;
      if (!options.pretty || options.suppressPrettyCount) {
        return '';
      } else if (options.pretty) {
        indentLevel = (level || 0) + options.offset + 1;
        if (indentLevel > 0) {
          return new Array(indentLevel).join(options.indent);
        }
      }
      return '';
    };

    XMLWriterBase.prototype.endline = function(node, options, level) {
      if (!options.pretty || options.suppressPrettyCount) {
        return '';
      } else {
        return options.newline;
      }
    };

    XMLWriterBase.prototype.attribute = function(att, options, level) {
      var r;
      this.openAttribute(att, options, level);
      r = ' ' + att.name + '="' + att.value + '"';
      this.closeAttribute(att, options, level);
      return r;
    };

    XMLWriterBase.prototype.cdata = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<![CDATA[';
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += ']]>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.comment = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!-- ';
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += ' -->' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.declaration = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<?xml';
      options.state = WriterState.InsideTag;
      r += ' version="' + node.version + '"';
      if (node.encoding != null) {
        r += ' encoding="' + node.encoding + '"';
      }
      if (node.standalone != null) {
        r += ' standalone="' + node.standalone + '"';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '?>';
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.docType = function(node, options, level) {
      var child, i, len, r, ref;
      level || (level = 0);
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level);
      r += '<!DOCTYPE ' + node.root().name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      if (node.children.length > 0) {
        r += ' [';
        r += this.endline(node, options, level);
        options.state = WriterState.InsideTag;
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          r += this.writeChildNode(child, options, level + 1);
        }
        options.state = WriterState.CloseTag;
        r += ']';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>';
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.element = function(node, options, level) {
      var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
      level || (level = 0);
      prettySuppressed = false;
      r = '';
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r += this.indent(node, options, level) + '<' + node.name;
      ref = node.attribs;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        r += this.attribute(att, options, level);
      }
      childNodeCount = node.children.length;
      firstChildNode = childNodeCount === 0 ? null : node.children[0];
      if (childNodeCount === 0 || node.children.every(function(e) {
        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
      })) {
        if (options.allowEmpty) {
          r += '>';
          options.state = WriterState.CloseTag;
          r += '</' + node.name + '>' + this.endline(node, options, level);
        } else {
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);
        }
      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {
        r += '>';
        options.state = WriterState.InsideTag;
        options.suppressPrettyCount++;
        prettySuppressed = true;
        r += this.writeChildNode(firstChildNode, options, level + 1);
        options.suppressPrettyCount--;
        prettySuppressed = false;
        options.state = WriterState.CloseTag;
        r += '</' + node.name + '>' + this.endline(node, options, level);
      } else {
        if (options.dontPrettyTextNodes) {
          ref1 = node.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            if ((child.type === NodeType.Text || child.type === NodeType.Raw) && (child.value != null)) {
              options.suppressPrettyCount++;
              prettySuppressed = true;
              break;
            }
          }
        }
        r += '>' + this.endline(node, options, level);
        options.state = WriterState.InsideTag;
        ref2 = node.children;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          child = ref2[j];
          r += this.writeChildNode(child, options, level + 1);
        }
        options.state = WriterState.CloseTag;
        r += this.indent(node, options, level) + '</' + node.name + '>';
        if (prettySuppressed) {
          options.suppressPrettyCount--;
        }
        r += this.endline(node, options, level);
        options.state = WriterState.None;
      }
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.writeChildNode = function(node, options, level) {
      switch (node.type) {
        case NodeType.CData:
          return this.cdata(node, options, level);
        case NodeType.Comment:
          return this.comment(node, options, level);
        case NodeType.Element:
          return this.element(node, options, level);
        case NodeType.Raw:
          return this.raw(node, options, level);
        case NodeType.Text:
          return this.text(node, options, level);
        case NodeType.ProcessingInstruction:
          return this.processingInstruction(node, options, level);
        case NodeType.Dummy:
          return '';
        case NodeType.Declaration:
          return this.declaration(node, options, level);
        case NodeType.DocType:
          return this.docType(node, options, level);
        case NodeType.AttributeDeclaration:
          return this.dtdAttList(node, options, level);
        case NodeType.ElementDeclaration:
          return this.dtdElement(node, options, level);
        case NodeType.EntityDeclaration:
          return this.dtdEntity(node, options, level);
        case NodeType.NotationDeclaration:
          return this.dtdNotation(node, options, level);
        default:
          throw new Error("Unknown XML node type: " + node.constructor.name);
      }
    };

    XMLWriterBase.prototype.processingInstruction = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<?';
      options.state = WriterState.InsideTag;
      r += node.target;
      if (node.value) {
        r += ' ' + node.value;
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '?>';
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.raw = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level);
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.text = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level);
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.dtdAttList = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!ATTLIST';
      options.state = WriterState.InsideTag;
      r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
      if (node.defaultValueType !== '#DEFAULT') {
        r += ' ' + node.defaultValueType;
      }
      if (node.defaultValue) {
        r += ' "' + node.defaultValue + '"';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.dtdElement = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!ELEMENT';
      options.state = WriterState.InsideTag;
      r += ' ' + node.name + ' ' + node.value;
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.dtdEntity = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!ENTITY';
      options.state = WriterState.InsideTag;
      if (node.pe) {
        r += ' %';
      }
      r += ' ' + node.name;
      if (node.value) {
        r += ' "' + node.value + '"';
      } else {
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.nData) {
          r += ' NDATA ' + node.nData;
        }
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.dtdNotation = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!NOTATION';
      options.state = WriterState.InsideTag;
      r += ' ' + node.name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.pubID) {
        r += ' PUBLIC "' + node.pubID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.openNode = function(node, options, level) {};

    XMLWriterBase.prototype.closeNode = function(node, options, level) {};

    XMLWriterBase.prototype.openAttribute = function(att, options, level) {};

    XMLWriterBase.prototype.closeAttribute = function(att, options, level) {};

    return XMLWriterBase;

  })();

}).call(this);

},{"./NodeType":88,"./Utility":89,"./WriterState":90,"./XMLCData":92,"./XMLComment":94,"./XMLDTDAttList":99,"./XMLDTDElement":100,"./XMLDTDEntity":101,"./XMLDTDNotation":102,"./XMLDeclaration":103,"./XMLDocType":104,"./XMLDummy":107,"./XMLElement":108,"./XMLProcessingInstruction":112,"./XMLRaw":113,"./XMLText":117}],119:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;

  ref = require('./Utility'), assign = ref.assign, isFunction = ref.isFunction;

  XMLDOMImplementation = require('./XMLDOMImplementation');

  XMLDocument = require('./XMLDocument');

  XMLDocumentCB = require('./XMLDocumentCB');

  XMLStringWriter = require('./XMLStringWriter');

  XMLStreamWriter = require('./XMLStreamWriter');

  NodeType = require('./NodeType');

  WriterState = require('./WriterState');

  module.exports.create = function(name, xmldec, doctype, options) {
    var doc, root;
    if (name == null) {
      throw new Error("Root element needs a name.");
    }
    options = assign({}, xmldec, doctype, options);
    doc = new XMLDocument(options);
    root = doc.element(name);
    if (!options.headless) {
      doc.declaration(options);
      if ((options.pubID != null) || (options.sysID != null)) {
        doc.dtd(options);
      }
    }
    return root;
  };

  module.exports.begin = function(options, onData, onEnd) {
    var ref1;
    if (isFunction(options)) {
      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
      options = {};
    }
    if (onData) {
      return new XMLDocumentCB(options, onData, onEnd);
    } else {
      return new XMLDocument(options);
    }
  };

  module.exports.stringWriter = function(options) {
    return new XMLStringWriter(options);
  };

  module.exports.streamWriter = function(stream, options) {
    return new XMLStreamWriter(stream, options);
  };

  module.exports.implementation = new XMLDOMImplementation();

  module.exports.nodeType = NodeType;

  module.exports.writerState = WriterState;

}).call(this);

},{"./NodeType":88,"./Utility":89,"./WriterState":90,"./XMLDOMImplementation":97,"./XMLDocument":105,"./XMLDocumentCB":106,"./XMLStreamWriter":114,"./XMLStringWriter":115}],120:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],121:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./DocumentPositionResolver":120,"./FileInfo":122,"./language":138,"./parser/PddlSyntaxTree":157,"./parser/PddlTokenizer":159,"./utils/DirectionalGraph":178,"./utils/serializationUtils":182,"dup":16}],122:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./DocumentPositionResolver":120,"./language":138,"./parser/PddlSyntaxTree":157,"./parser/PddlTokenizer":159,"dup":17}],123:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"./language":138,"./typeInheritance":177,"dup":18}],124:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"./FileInfo":122,"./language":138,"./parser/PddlSyntaxTree":157,"dup":19}],125:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./DomainInfo":121,"./parser/ActionEffectParser":139,"./parser/PddlTokenizer":159,"dup":20}],126:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./language":138,"dup":21}],127:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],128:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./DocumentPositionResolver":120,"./FileInfo":122,"./language":138,"./parser/HappeningsParser":142,"./parser/PddlPlanParser":152,"./parser/PddlSyntaxTreeBuilder":158,"./parser/index":164,"./planner/PlannerRegistrar":170,"dup":23,"events":230,"path":235,"vscode-uri":185}],129:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],130:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"./DomainInfo":121,"./PlanStep":132,"./ProblemInfo":134,"dup":25}],131:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./FileInfo":122,"./Plan":130,"./language":138,"./parser/PddlSyntaxTree":157,"dup":26}],132:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./HappeningsInfo":124,"dup":27}],133:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"child_process":227,"dup":28,"fs":227,"nunjucks":1,"path":235}],134:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./DocumentPositionResolver":120,"./DomainInfo":121,"./FileInfo":122,"./language":138,"./parser/PddlSyntaxTree":157,"dup":29}],135:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./PreProcessors":133,"dup":30}],136:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],137:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./DocumentPositionResolver":120,"./DomainInfo":121,"./FileInfo":122,"./Grounder":123,"./HappeningsInfo":124,"./ModelHierarchy":125,"./NumericExpression":126,"./PddlExtensionContext":127,"./PddlWorkspace":128,"./PddlWorkspaceExtension":129,"./Plan":130,"./PlanInfo":131,"./PlanStep":132,"./PreProcessors":133,"./ProblemInfo":134,"./constraints":136,"./language":138,"./parser/index":164,"./planner/index":172,"./search/index":176,"./typeInheritance":177,"./utils/index":181,"dup":32}],138:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],139:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"../language":138,"dup":34}],140:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"../DocumentPositionResolver":120,"../language":138,"./PddlTokenizer":159,"./VariablesParser":162,"dup":35}],141:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"../DocumentPositionResolver":120,"../DomainInfo":121,"./DerivedVariableParser":140,"./PddlTokenizer":159,"./VariablesParser":162,"dup":36}],142:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"../HappeningsInfo":124,"./PddlPlanParser":152,"./PlanHappeningsBuilder":160,"dup":37}],143:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"../DocumentPositionResolver":120,"../DomainInfo":121,"./DerivedVariableParser":140,"./PddlTokenizer":159,"./VariablesParser":162,"dup":38}],144:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"../DocumentPositionResolver":120,"../ProblemInfo":134,"./DerivedVariableParser":140,"./NumericExpressionParser":146,"./PddlTokenizer":159,"dup":39}],145:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"../PlanStep":132,"./PddlPlanBuilder":151,"./PddlPlanParser":152,"dup":40}],146:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"..":137,"../NumericExpression":126,"dup":41}],147:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"../constraints":136,"./PddlTokenizer":159,"dup":42}],148:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"../DocumentPositionResolver":120,"../DomainInfo":121,"./DerivedVariableParser":140,"./DurativeActionParser":141,"./InstantActionParser":143,"./PddlConstraintsParser":147,"./PddlFileParser":149,"./PddlInheritanceParser":150,"./PddlSyntaxTreeBuilder":158,"./PddlTokenizer":159,"./VariablesParser":162,"dup":43,"vscode-uri":185}],149:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],150:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"../DomainInfo":121,"../utils/DirectionalGraph":178,"dup":45}],151:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"../Plan":130,"dup":46}],152:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"../DocumentPositionResolver":120,"../PlanInfo":131,"../PlanStep":132,"./PddlPlanBuilder":151,"dup":47,"vscode-uri":185}],153:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"../DocumentPositionResolver":120,"../DomainInfo":121,"../ProblemInfo":134,"./PddlPlanBuilder":151,"./PddlPlanParser":152,"./PddlSyntaxTree":157,"./XmlPlanBuilder":163,"dup":48}],154:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"../DocumentPositionResolver":120,"../FileInfo":122,"../PreProcessors":133,"../ProblemInfo":134,"../ProblemParserPreProcessor":135,"./MetricParser":144,"./PddlConstraintsParser":147,"./PddlDomainParser":148,"./PddlFileParser":149,"./PddlInheritanceParser":150,"./PddlSyntaxTree":157,"./PddlSyntaxTreeBuilder":158,"./PddlTokenizer":159,"dup":49,"path":235,"vscode-uri":185}],155:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"./PddlTokenizer":159,"dup":50}],156:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"./PddlTokenizer":159,"dup":51}],157:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"./PddlSyntaxNode":156,"dup":52}],158:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"./PddlSyntaxNode":156,"./PddlSyntaxTree":157,"./PddlTokenizer":159,"dup":53}],159:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"dup":54}],160:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"../DocumentPositionResolver":120,"../FileInfo":122,"../HappeningsInfo":124,"dup":55}],161:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"dup":56}],162:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"../DocumentPositionResolver":120,"../language":138,"../utils/util":183,"./PddlTokenizer":159,"dup":57}],163:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"../PlanStep":132,"dup":58,"parse-xsd-duration":2,"xml2js":191}],164:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"./ActionEffectParser":139,"./DerivedVariableParser":140,"./DurativeActionParser":141,"./HappeningsParser":142,"./InstantActionParser":143,"./MetricParser":144,"./NormalizingPddlPlanParser":145,"./NumericExpressionParser":146,"./PddlConstraintsParser":147,"./PddlDomainParser":148,"./PddlFileParser":149,"./PddlInheritanceParser":150,"./PddlPlanBuilder":151,"./PddlPlanParser":152,"./PddlPlannerOutputParser":153,"./PddlProblemParser":154,"./PddlStructure":155,"./PddlSyntaxNode":156,"./PddlSyntaxTree":157,"./PddlSyntaxTreeBuilder":158,"./PddlTokenizer":159,"./PlanHappeningsBuilder":160,"./PlanValuesParser":161,"./VariablesParser":162,"dup":59}],165:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"dup":60}],166:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"dup":61}],167:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"dup":62}],168:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"dup":63}],169:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"dup":64}],170:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"../utils":181,"dup":65}],171:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"dup":66}],172:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"./Authentication":165,"./Planner":166,"./PlannerExecutableRunConfiguration":167,"./PlannerOptionsProvider":168,"./PlannerProvider":169,"./PlannerRegistrar":170,"./PlannerResponseHandler":171,"dup":67}],173:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"dup":68}],174:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"dup":69}],175:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"..":137,"../utils":181,"dup":70}],176:[function(require,module,exports){
arguments[4][71][0].apply(exports,arguments)
},{"./SearchHappening":173,"./SearchState":174,"./SearchStateToPlan":175,"dup":71}],177:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"./utils/util":183,"dup":72}],178:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"dup":73}],179:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"dup":74}],180:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"dup":75,"fs":227,"path":235}],181:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"./DirectionalGraph":178,"./StringifyingMap":179,"./asyncfs":180,"./serializationUtils":182,"./util":183,"dup":76}],182:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"dup":77}],183:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"dup":78,"os":234}],184:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"buffer":228,"dup":79,"stream":254,"string_decoder":255}],185:[function(require,module,exports){
(function (process){(function (){
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r=e();for(var n in r)("object"==typeof exports?exports:t)[n]=r[n]}}(this,(function(){return(()=>{"use strict";var t={470:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",o=0,i=-1,a=0,s=0;s<=t.length;++s){if(s<t.length)r=t.charCodeAt(s);else{if(47===r)break;r=47}if(47===r){if(i===s-1||1===a);else if(i!==s-1&&2===a){if(n.length<2||2!==o||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var h=n.lastIndexOf("/");if(h!==n.length-1){-1===h?(n="",o=0):o=(n=n.slice(0,h)).length-1-n.lastIndexOf("/"),i=s,a=0;continue}}else if(2===n.length||1===n.length){n="",o=0,i=s,a=0;continue}e&&(n.length>0?n+="/..":n="..",o=2)}else n.length>0?n+="/"+t.slice(i+1,s):n=t.slice(i+1,s),o=s-i-1;i=s,a=0}else 46===r&&-1!==a?++a:a=-1}return n}var n={resolve:function(){for(var t,n="",o=!1,i=arguments.length-1;i>=-1&&!o;i--){var a;i>=0?a=arguments[i]:(void 0===t&&(t=process.cwd()),a=t),e(a),0!==a.length&&(n=a+"/"+n,o=47===a.charCodeAt(0))}return n=r(n,!o),o?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return".";var n=47===t.charCodeAt(0),o=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&o&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,r=0;r<arguments.length;++r){var o=arguments[r];e(o),o.length>0&&(void 0===t?t=o:t+="/"+o)}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return"";if((t=n.resolve(t))===(r=n.resolve(r)))return"";for(var o=1;o<t.length&&47===t.charCodeAt(o);++o);for(var i=t.length,a=i-o,s=1;s<r.length&&47===r.charCodeAt(s);++s);for(var h=r.length-s,c=a<h?a:h,f=-1,u=0;u<=c;++u){if(u===c){if(h>c){if(47===r.charCodeAt(s+u))return r.slice(s+u+1);if(0===u)return r.slice(s+u)}else a>c&&(47===t.charCodeAt(o+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(o+u);if(l!==r.charCodeAt(s+u))break;47===l&&(f=u)}var p="";for(u=o+f+1;u<=i;++u)u!==i&&47!==t.charCodeAt(u)||(0===p.length?p+="..":p+="/..");return p.length>0?p+r.slice(s+f):(s+=f,47===r.charCodeAt(s)&&++s,r.slice(s))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var r=t.charCodeAt(0),n=47===r,o=-1,i=!0,a=t.length-1;a>=1;--a)if(47===(r=t.charCodeAt(a))){if(!i){o=a;break}}else i=!1;return-1===o?n?"/":".":n&&1===o?"//":t.slice(0,o)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError('"ext" argument must be a string');e(t);var n,o=0,i=-1,a=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return"";var s=r.length-1,h=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!a){o=n+1;break}}else-1===h&&(a=!1,h=n+1),s>=0&&(c===r.charCodeAt(s)?-1==--s&&(i=n):(s=-1,i=h))}return o===i?i=h:-1===i&&(i=t.length),t.slice(o,i)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!a){o=n+1;break}}else-1===i&&(a=!1,i=n+1);return-1===i?"":t.slice(o,i)},extname:function(t){e(t);for(var r=-1,n=0,o=-1,i=!0,a=0,s=t.length-1;s>=0;--s){var h=t.charCodeAt(s);if(47!==h)-1===o&&(i=!1,o=s+1),46===h?-1===r?r=s:1!==a&&(a=1):-1!==r&&(a=-1);else if(!i){n=s+1;break}}return-1===r||-1===o||0===a||1===a&&r===o-1&&r===n+1?"":t.slice(r,o)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,o=t.charCodeAt(0),i=47===o;i?(r.root="/",n=1):n=0;for(var a=-1,s=0,h=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(o=t.charCodeAt(f)))-1===h&&(c=!1,h=f+1),46===o?-1===a?a=f:1!==u&&(u=1):-1!==a&&(u=-1);else if(!c){s=f+1;break}return-1===a||-1===h||0===u||1===u&&a===h-1&&a===s+1?-1!==h&&(r.base=r.name=0===s&&i?t.slice(1,h):t.slice(s,h)):(0===s&&i?(r.name=t.slice(1,a),r.base=t.slice(1,h)):(r.name=t.slice(s,a),r.base=t.slice(s,h)),r.ext=t.slice(a,h)),s>0?r.dir=t.slice(0,s-1):i&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n},465:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Utils=e.URI=void 0;var n=r(796);Object.defineProperty(e,"URI",{enumerable:!0,get:function(){return n.URI}});var o=r(679);Object.defineProperty(e,"Utils",{enumerable:!0,get:function(){return o.Utils}})},674:(t,e)=>{if(Object.defineProperty(e,"__esModule",{value:!0}),e.isWindows=void 0,"object"==typeof process)e.isWindows="win32"===process.platform;else if("object"==typeof navigator){var r=navigator.userAgent;e.isWindows=r.indexOf("Windows")>=0}},796:function(t,e,r){var n,o,i=this&&this.__extends||(n=function(t,e){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])})(t,e)},function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function r(){this.constructor=t}n(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)});Object.defineProperty(e,"__esModule",{value:!0}),e.uriToFsPath=e.URI=void 0;var a=r(674),s=/^\w[\w\d+.-]*$/,h=/^\//,c=/^\/\//;function f(t,e){if(!t.scheme&&e)throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t.authority,'", path: "').concat(t.path,'", query: "').concat(t.query,'", fragment: "').concat(t.fragment,'"}'));if(t.scheme&&!s.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!h.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}else if(c.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}var u="",l="/",p=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,d=function(){function t(t,e,r,n,o,i){void 0===i&&(i=!1),"object"==typeof t?(this.scheme=t.scheme||u,this.authority=t.authority||u,this.path=t.path||u,this.query=t.query||u,this.fragment=t.fragment||u):(this.scheme=function(t,e){return t||e?t:"file"}(t,i),this.authority=e||u,this.path=function(t,e){switch(t){case"https":case"http":case"file":e?e[0]!==l&&(e=l+e):e=l}return e}(this.scheme,r||u),this.query=n||u,this.fragment=o||u,f(this,i))}return t.isUri=function(e){return e instanceof t||!!e&&"string"==typeof e.authority&&"string"==typeof e.fragment&&"string"==typeof e.path&&"string"==typeof e.query&&"string"==typeof e.scheme&&"string"==typeof e.fsPath&&"function"==typeof e.with&&"function"==typeof e.toString},Object.defineProperty(t.prototype,"fsPath",{get:function(){return C(this,!1)},enumerable:!1,configurable:!0}),t.prototype.with=function(t){if(!t)return this;var e=t.scheme,r=t.authority,n=t.path,o=t.query,i=t.fragment;return void 0===e?e=this.scheme:null===e&&(e=u),void 0===r?r=this.authority:null===r&&(r=u),void 0===n?n=this.path:null===n&&(n=u),void 0===o?o=this.query:null===o&&(o=u),void 0===i?i=this.fragment:null===i&&(i=u),e===this.scheme&&r===this.authority&&n===this.path&&o===this.query&&i===this.fragment?this:new v(e,r,n,o,i)},t.parse=function(t,e){void 0===e&&(e=!1);var r=p.exec(t);return r?new v(r[2]||u,x(r[4]||u),x(r[5]||u),x(r[7]||u),x(r[9]||u),e):new v(u,u,u,u,u)},t.file=function(t){var e=u;if(a.isWindows&&(t=t.replace(/\\/g,l)),t[0]===l&&t[1]===l){var r=t.indexOf(l,2);-1===r?(e=t.substring(2),t=l):(e=t.substring(2,r),t=t.substring(r)||l)}return new v("file",e,t,u,u)},t.from=function(t){var e=new v(t.scheme,t.authority,t.path,t.query,t.fragment);return f(e,!0),e},t.prototype.toString=function(t){return void 0===t&&(t=!1),A(this,t)},t.prototype.toJSON=function(){return this},t.revive=function(e){if(e){if(e instanceof t)return e;var r=new v(e);return r._formatted=e.external,r._fsPath=e._sep===g?e.fsPath:null,r}return e},t}();e.URI=d;var g=a.isWindows?1:void 0,v=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e._formatted=null,e._fsPath=null,e}return i(e,t),Object.defineProperty(e.prototype,"fsPath",{get:function(){return this._fsPath||(this._fsPath=C(this,!1)),this._fsPath},enumerable:!1,configurable:!0}),e.prototype.toString=function(t){return void 0===t&&(t=!1),t?A(this,!0):(this._formatted||(this._formatted=A(this,!1)),this._formatted)},e.prototype.toJSON=function(){var t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=g),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t},e}(d),y=((o={})[58]="%3A",o[47]="%2F",o[63]="%3F",o[35]="%23",o[91]="%5B",o[93]="%5D",o[64]="%40",o[33]="%21",o[36]="%24",o[38]="%26",o[39]="%27",o[40]="%28",o[41]="%29",o[42]="%2A",o[43]="%2B",o[44]="%2C",o[59]="%3B",o[61]="%3D",o[32]="%20",o);function m(t,e){for(var r=void 0,n=-1,o=0;o<t.length;o++){var i=t.charCodeAt(o);if(i>=97&&i<=122||i>=65&&i<=90||i>=48&&i<=57||45===i||46===i||95===i||126===i||e&&47===i)-1!==n&&(r+=encodeURIComponent(t.substring(n,o)),n=-1),void 0!==r&&(r+=t.charAt(o));else{void 0===r&&(r=t.substr(0,o));var a=y[i];void 0!==a?(-1!==n&&(r+=encodeURIComponent(t.substring(n,o)),n=-1),r+=a):-1===n&&(n=o)}}return-1!==n&&(r+=encodeURIComponent(t.substring(n))),void 0!==r?r:t}function b(t){for(var e=void 0,r=0;r<t.length;r++){var n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=y[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function C(t,e){var r;return r=t.authority&&t.path.length>1&&"file"===t.scheme?"//".concat(t.authority).concat(t.path):47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,a.isWindows&&(r=r.replace(/\//g,"\\")),r}function A(t,e){var r=e?b:m,n="",o=t.scheme,i=t.authority,a=t.path,s=t.query,h=t.fragment;if(o&&(n+=o,n+=":"),(i||"file"===o)&&(n+=l,n+=l),i){var c=i.indexOf("@");if(-1!==c){var f=i.substr(0,c);i=i.substr(c+1),-1===(c=f.indexOf(":"))?n+=r(f,!1):(n+=r(f.substr(0,c),!1),n+=":",n+=r(f.substr(c+1),!1)),n+="@"}-1===(c=(i=i.toLowerCase()).indexOf(":"))?n+=r(i,!1):(n+=r(i.substr(0,c),!1),n+=i.substr(c))}if(a){if(a.length>=3&&47===a.charCodeAt(0)&&58===a.charCodeAt(2))(u=a.charCodeAt(1))>=65&&u<=90&&(a="/".concat(String.fromCharCode(u+32),":").concat(a.substr(3)));else if(a.length>=2&&58===a.charCodeAt(1)){var u;(u=a.charCodeAt(0))>=65&&u<=90&&(a="".concat(String.fromCharCode(u+32),":").concat(a.substr(2)))}n+=r(a,!0)}return s&&(n+="?",n+=r(s,!1)),h&&(n+="#",n+=e?h:m(h,!1)),n}function w(t){try{return decodeURIComponent(t)}catch(e){return t.length>3?t.substr(0,3)+w(t.substr(3)):t}}e.uriToFsPath=C;var _=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function x(t){return t.match(_)?t.replace(_,(function(t){return w(t)})):t}},679:function(t,e,r){var n=this&&this.__spreadArray||function(t,e,r){if(r||2===arguments.length)for(var n,o=0,i=e.length;o<i;o++)!n&&o in e||(n||(n=Array.prototype.slice.call(e,0,o)),n[o]=e[o]);return t.concat(n||Array.prototype.slice.call(e))};Object.defineProperty(e,"__esModule",{value:!0}),e.Utils=void 0;var o,i=r(470),a=i.posix||i;(o=e.Utils||(e.Utils={})).joinPath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];return t.with({path:a.join.apply(a,n([t.path],e,!1))})},o.resolvePath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];var o=t.path||"/";return t.with({path:a.resolve.apply(a,n([o],e,!1))})},o.dirname=function(t){var e=a.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)?t:t.with({path:e})},o.basename=function(t){return a.basename(t.path)},o.extname=function(t){return a.extname(t.path)}}},e={};return function r(n){if(e[n])return e[n].exports;var o=e[n]={exports:{}};return t[n].call(o.exports,o,o.exports,r),o.exports}(465)})()}));

}).call(this)}).call(this,require('_process'))
},{"_process":237}],186:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"dup":81}],187:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./defaults":188,"dup":82,"xmlbuilder":224}],188:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"dup":83}],189:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"./bom":186,"./defaults":188,"./processors":190,"dup":84,"events":230,"sax":184,"timers":256}],190:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"dup":85}],191:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"./builder":187,"./defaults":188,"./parser":189,"./processors":190,"dup":86}],192:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"dup":87}],193:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"dup":88}],194:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89}],195:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"dup":90}],196:[function(require,module,exports){
arguments[4][91][0].apply(exports,arguments)
},{"./NodeType":193,"./XMLNode":215,"dup":91}],197:[function(require,module,exports){
arguments[4][92][0].apply(exports,arguments)
},{"./NodeType":193,"./XMLCharacterData":198,"dup":92}],198:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"./XMLNode":215,"dup":93}],199:[function(require,module,exports){
arguments[4][94][0].apply(exports,arguments)
},{"./NodeType":193,"./XMLCharacterData":198,"dup":94}],200:[function(require,module,exports){
arguments[4][95][0].apply(exports,arguments)
},{"./XMLDOMErrorHandler":201,"./XMLDOMStringList":203,"dup":95}],201:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],202:[function(require,module,exports){
arguments[4][97][0].apply(exports,arguments)
},{"dup":97}],203:[function(require,module,exports){
arguments[4][98][0].apply(exports,arguments)
},{"dup":98}],204:[function(require,module,exports){
arguments[4][99][0].apply(exports,arguments)
},{"./NodeType":193,"./XMLNode":215,"dup":99}],205:[function(require,module,exports){
arguments[4][100][0].apply(exports,arguments)
},{"./NodeType":193,"./XMLNode":215,"dup":100}],206:[function(require,module,exports){
arguments[4][101][0].apply(exports,arguments)
},{"./NodeType":193,"./Utility":194,"./XMLNode":215,"dup":101}],207:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"./NodeType":193,"./XMLNode":215,"dup":102}],208:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"./NodeType":193,"./Utility":194,"./XMLNode":215,"dup":103}],209:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"./NodeType":193,"./Utility":194,"./XMLDTDAttList":204,"./XMLDTDElement":205,"./XMLDTDEntity":206,"./XMLDTDNotation":207,"./XMLNamedNodeMap":214,"./XMLNode":215,"dup":104}],210:[function(require,module,exports){
arguments[4][105][0].apply(exports,arguments)
},{"./NodeType":193,"./Utility":194,"./XMLDOMConfiguration":200,"./XMLDOMImplementation":202,"./XMLNode":215,"./XMLStringWriter":220,"./XMLStringifier":221,"dup":105}],211:[function(require,module,exports){
arguments[4][106][0].apply(exports,arguments)
},{"./NodeType":193,"./Utility":194,"./WriterState":195,"./XMLAttribute":196,"./XMLCData":197,"./XMLComment":199,"./XMLDTDAttList":204,"./XMLDTDElement":205,"./XMLDTDEntity":206,"./XMLDTDNotation":207,"./XMLDeclaration":208,"./XMLDocType":209,"./XMLDocument":210,"./XMLElement":213,"./XMLProcessingInstruction":217,"./XMLRaw":218,"./XMLStringWriter":220,"./XMLStringifier":221,"./XMLText":222,"dup":106}],212:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"./NodeType":193,"./XMLNode":215,"dup":107}],213:[function(require,module,exports){
arguments[4][108][0].apply(exports,arguments)
},{"./NodeType":193,"./Utility":194,"./XMLAttribute":196,"./XMLNamedNodeMap":214,"./XMLNode":215,"dup":108}],214:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],215:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"./DocumentPosition":192,"./NodeType":193,"./Utility":194,"./XMLCData":197,"./XMLComment":199,"./XMLDeclaration":208,"./XMLDocType":209,"./XMLDummy":212,"./XMLElement":213,"./XMLNamedNodeMap":214,"./XMLNodeList":216,"./XMLProcessingInstruction":217,"./XMLRaw":218,"./XMLText":222,"dup":110}],216:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"dup":111}],217:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./NodeType":193,"./XMLCharacterData":198,"dup":112}],218:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"./NodeType":193,"./XMLNode":215,"dup":113}],219:[function(require,module,exports){
arguments[4][114][0].apply(exports,arguments)
},{"./NodeType":193,"./WriterState":195,"./XMLWriterBase":223,"dup":114}],220:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"./XMLWriterBase":223,"dup":115}],221:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],222:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./NodeType":193,"./XMLCharacterData":198,"dup":117}],223:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./NodeType":193,"./Utility":194,"./WriterState":195,"./XMLCData":197,"./XMLComment":199,"./XMLDTDAttList":204,"./XMLDTDElement":205,"./XMLDTDEntity":206,"./XMLDTDNotation":207,"./XMLDeclaration":208,"./XMLDocType":209,"./XMLDummy":212,"./XMLElement":213,"./XMLProcessingInstruction":217,"./XMLRaw":218,"./XMLText":222,"dup":118}],224:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"./NodeType":193,"./Utility":194,"./WriterState":195,"./XMLDOMImplementation":202,"./XMLDocument":210,"./XMLDocumentCB":211,"./XMLStreamWriter":219,"./XMLStringWriter":220,"dup":119}],225:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],226:[function(require,module,exports){

},{}],227:[function(require,module,exports){
arguments[4][226][0].apply(exports,arguments)
},{"dup":226}],228:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":225,"buffer":228,"ieee754":231}],229:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('buffer').Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":228}],230:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],231:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],232:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],233:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],234:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],235:[function(require,module,exports){
(function (process){(function (){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this)}).call(this,require('_process'))
},{"_process":237}],236:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this)}).call(this,require('_process'))
},{"_process":237}],237:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],238:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":239}],239:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":241,"./_stream_writable":243,"core-util-is":229,"inherits":232,"process-nextick-args":236}],240:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":242,"core-util-is":229,"inherits":232}],241:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":239,"./internal/streams/BufferList":244,"./internal/streams/destroy":245,"./internal/streams/stream":246,"_process":237,"core-util-is":229,"events":230,"inherits":232,"isarray":233,"process-nextick-args":236,"safe-buffer":247,"string_decoder/":248,"util":226}],242:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":239,"core-util-is":229,"inherits":232}],243:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":239,"./internal/streams/destroy":245,"./internal/streams/stream":246,"_process":237,"core-util-is":229,"inherits":232,"process-nextick-args":236,"safe-buffer":247,"timers":256,"util-deprecate":257}],244:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":247,"util":226}],245:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":236}],246:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":230}],247:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":228}],248:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":247}],249:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":250}],250:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":239,"./lib/_stream_passthrough.js":240,"./lib/_stream_readable.js":241,"./lib/_stream_transform.js":242,"./lib/_stream_writable.js":243}],251:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":250}],252:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":243}],253:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":228}],254:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":230,"inherits":232,"readable-stream/duplex.js":238,"readable-stream/passthrough.js":249,"readable-stream/readable.js":250,"readable-stream/transform.js":251,"readable-stream/writable.js":252}],255:[function(require,module,exports){
arguments[4][248][0].apply(exports,arguments)
},{"dup":248,"safe-buffer":253}],256:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":237,"timers":256}],257:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],258:[function(require,module,exports){
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Jan Dolejsi. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
const pddl_gantt_1 = require("pddl-gantt");
const pddl_workspace_1 = require("pddl-workspace");
window.addEventListener('message', event => {
    const message = event.data;
    // console.debug("Message: " + JSON.stringify(message));
    switch (message.command) {
        case 'showPlans':
            const plansData = message.data;
            showPlans(plansData);
            break;
        case 'setVisibility':
            showElement(message.elementId, message.visible);
            break;
        case 'showLinePlot':
            showLinePlot(message.data);
            break;
        case 'hideLinePlotLoadingProgress':
            hideLinePlotLoadingProgress(message.planIndex);
            break;
        case 'visualizeFinalState':
            showFinalState(message.data);
            break;
        case 'error':
            showError(message.message);
            break;
        default:
            console.log("Unexpected message: " + message.command);
    }
});
document.body.onload = () => initialize();
function initialize() {
    plansViz = (0, pddl_gantt_1.createPlansView)("plans", {
        displayWidth: 400,
        epsilon: 1e-3,
        onActionSelected: actionName => revealAction(actionName),
        onLinePlotsVisible: planView => requestLinePlotData(planView),
        onFinalStateVisible: planView => requestFinalState(planView),
        onPlanSelected: planIndex => setSelectedPlan(planIndex)
    });
    if (!vscode) {
        // initialize in-browser debugging
        const dummyPlan = new pddl_workspace_1.Plan([
            new pddl_workspace_1.PlanStep(.5, "hello world", true, 1, 1),
            new pddl_workspace_1.PlanStep(1, "hello universe", true, .8, 2),
        ]);
        const mockVisualization = function visualizeHtml(plan, width) {
            const height = 100;
            return `<svg height="${height}" width="${width}">
                <rect width="${width}" height="${height}" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
                <circle cx="${height / 2}" cy="${height / 2}" r="${plan.metric}" stroke="black" stroke-width="3" fill="red" />
              </svg> `;
        };
        const customDomainVisualization = {
            visualizePlanHtml: mockVisualization
        };
        showElement('downloadVal', true);
        showPlans({
            plans: [dummyPlan],
            width: 300,
            domainVisualizationConfiguration: {
                customVisualization: "see further"
            }
        }, customDomainVisualization);
        showError("Some issue...");
    }
    const menu = document.getElementById("menu");
    if (menu) {
        menu.onclick = () => postCommand('showMenu');
    }
    onLoad();
    function setSelectedPlan(planIndex) {
        if (selectedPlan !== planIndex) {
            selectedPlan = planIndex;
            vscode === null || vscode === void 0 ? void 0 : vscode.postMessage({ "command": "selectPlan", "planIndex": planIndex });
        }
    }
}
let plansViz;
let selectedPlan = 0;
let plansShown = [];
function revealAction(actionName) {
    var _a;
    plansShown[selectedPlan].domain
        && (vscode === null || vscode === void 0 ? void 0 : vscode.postMessage({ "command": "revealAction", "domainUri": (_a = plansShown[selectedPlan].domain) === null || _a === void 0 ? void 0 : _a.fileUri, "action": actionName }));
}
function showElement(elementId, visible) {
    const element = document.getElementById(elementId);
    if (element) {
        element.style.visibility = visible ? "visible" : "collapse";
    }
}
// todo: how to clear the error again?
function showError(message) {
    const element = document.getElementById("error");
    if (element) {
        element.style.visibility = "visible";
        element.innerHTML = `<b>Error:</b> ${message}`;
    }
}
function showPlans(plansData, customDomainVisualization) {
    const plans = plansShown = plansData.plans;
    showElement("pleaseWait", false);
    if (plans.length > 0) {
        const clonedPlans = plans.map(p => pddl_workspace_1.Plan.clone(p));
        if (!plansViz) {
            console.error(`Plan visualization is not initialized.`);
            return;
        }
        plansViz.setDisplayWidth(plansData.width);
        const configuration = customDomainVisualization ?
            pddl_gantt_1.JsonDomainVizConfiguration.withCustomVisualization(plansData.domainVisualizationConfiguration, customDomainVisualization) :
            pddl_gantt_1.JsonDomainVizConfiguration.withCustomVisualizationScript(plansData.domainVisualizationConfiguration, plansData.customDomainVisualizationScript);
        plansViz.showPlans(clonedPlans, undefined, configuration);
    }
    else {
        plansViz.clear();
    }
}
function requestLinePlotData(planView) {
    vscode === null || vscode === void 0 ? void 0 : vscode.postMessage({ 'command': 'linePlotDataRequest', 'planIndex': planView.planIndex });
}
function showLinePlot(data) {
    plansViz.getView(data.planIndex).showPlanLinePlots(data.name, data.unit, data.legend, data.data);
}
function hideLinePlotLoadingProgress(planIndex) {
    plansViz.getView(planIndex).hideLinePlotLoadingProgress();
}
function requestFinalState(planView) {
    vscode === null || vscode === void 0 ? void 0 : vscode.postMessage({ 'command': 'finalStateDataRequest', 'planIndex': planView.planIndex });
}
function showFinalState(data) {
    plansViz.getView(data.planIndex).showFinalState(data.finalState);
}

},{"pddl-gantt":11,"pddl-workspace":137}]},{},[258]);

</script>
            <script type="text/javascript" src="plan_situacion_1_files/loader_002.js"></script>
            <script>
// this file is only needed as long as the PlanReportGenerator is used to generate the standalone plan report html file

google.charts.load('current', { packages: ['corechart', 'line'] });

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function drawChart(chartDivId, functionName, unit, objects, columnData) {

    const data = new google.visualization.DataTable();
    data.addColumn('number', 'X');

    objects.forEach(obj => {
        data.addColumn('number', obj);
    });

    data.addRows(columnData);

    const options = {
        hAxis: {
            title: 'Time'
        },
        vAxis: {
            title: unit,
            scaleType: 'linear' //vAxisScaleType = 'log'
        },
        interpolateNulls: true,
        title: functionName
    };

    const chart = new google.visualization.LineChart(document.getElementById(chartDivId));

    chart.draw(data, options);
}

function createDataTable(variableName, variableData) {
    const data = new google.visualization.DataTable();
    data.addColumn('number', 'X');
    data.addColumn('number', variableName);

    data.addRows(variableData);
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function drawChartMultipleSeries(chartDivId, functionName, unit, objects, columnData) {

    const data = columnData.map(variableData, variableName => createDataTable(variableName, variableData));

    const options = {
        hAxis: {
            title: 'Time'
        },
        vAxis: {
            title: unit,
            scaleType: 'linear' //vAxisScaleType = 'log'
        },
        interpolateNulls: true,
        title: functionName
    };

    const chart = new google.visualization.LineChart(document.getElementById(chartDivId));

    chart.draw(data, options);
}
</script><script type="text/javascript" charset="UTF-8" src="plan_situacion_1_files/loader.js"></script>
        <link id="load-css-0" rel="stylesheet" type="text/css" href="plan_situacion_1_files/tooltip.css"><link id="load-css-1" rel="stylesheet" type="text/css" href="plan_situacion_1_files/util.css"><script type="text/javascript" charset="UTF-8" src="plan_situacion_1_files/jsapi_compiled_default_module.js"></script><script type="text/javascript" charset="UTF-8" src="plan_situacion_1_files/jsapi_compiled_graphics_module.js"></script><script type="text/javascript" charset="UTF-8" src="plan_situacion_1_files/jsapi_compiled_ui_module.js"></script><script type="text/javascript" charset="UTF-8" src="plan_situacion_1_files/jsapi_compiled_corechart_module.js"></script><script type="text/javascript" charset="UTF-8" src="plan_situacion_1_files/jsapi_compiled_fw_module.js"></script><script type="text/javascript" charset="UTF-8" src="plan_situacion_1_files/dygraph-tickers-combined.js"></script><script type="text/javascript" charset="UTF-8" src="plan_situacion_1_files/webfont.js"></script><script type="text/javascript" charset="UTF-8" src="plan_situacion_1_files/jsapi_compiled_line_module.js"></script></head>
        <body onload="scrollPlanSelectorIntoView(0)">
            <div class="planSelectors" style="display: none;">
        <div class="planSelector planSelector-selected" plan="0" onclick="showPlan(0)"><span>0.0540</span>
            <div class="planMetricBar" style="height: 100px" title="Plan #0
Metric value / cost: 0.054
Makespan: 0.054
States evaluated: undefined"></div>
        </div>
            </div>
        

    <div class="gantt" plan="0" style="margin: 5px; height: 1080px; display: block;">
            <div class="planstep" id="plan0step0" style="left: 18.51851851851852px; top: 0px; "><div class="planstep-bar" title="cargar tren puerto v3 contenedor8 e8, Start: 0.0010 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren puerto v3 contenedor8 e8 </div>
        <div class="planstep" id="plan0step1" style="left: 37.03703703703704px; top: 20px; "><div class="planstep-bar" title="cargar tren puerto v2 contenedor7 e7, Start: 0.0020 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren puerto v2 contenedor7 e7 </div>
        <div class="planstep" id="plan0step2" style="left: 55.55555555555556px; top: 40px; "><div class="planstep-bar" title="cargar tren puerto v1 contenedor6 e6, Start: 0.0030 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren puerto v1 contenedor6 e6 </div>
        <div class="planstep" id="plan0step3" style="left: 74.07407407407408px; top: 60px; "><div class="planstep-bar" title="mover puerto fabrica2 tren, Start: 0.0040 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover puerto fabrica2 tren </div>
        <div class="planstep" id="plan0step4" style="left: 92.5925925925926px; top: 80px; "><div class="planstep-bar" title="descargar tren fabrica2 v1 contenedor6 e1f2, Start: 0.0050 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren fabrica2 v1 contenedor6 e1f2 </div>
        <div class="planstep" id="plan0step5" style="left: 111.11111111111111px; top: 100px; "><div class="planstep-bar" title="mover fabrica2 puerto tren, Start: 0.0060 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover fabrica2 puerto tren </div>
        <div class="planstep" id="plan0step6" style="left: 129.62962962962962px; top: 120px; "><div class="planstep-bar" title="cargar tren puerto v1 contenedor5 e5, Start: 0.0070 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren puerto v1 contenedor5 e5 </div>
        <div class="planstep" id="plan0step7" style="left: 148.14814814814815px; top: 140px; "><div class="planstep-bar" title="mover puerto fabrica2 tren, Start: 0.0080 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover puerto fabrica2 tren </div>
        <div class="planstep" id="plan0step8" style="left: 166.66666666666669px; top: 160px; "><div class="planstep-bar" title="descargar tren fabrica2 v1 contenedor5 e2f2, Start: 0.0090 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren fabrica2 v1 contenedor5 e2f2 </div>
        <div class="planstep" id="plan0step9" style="left: 185.1851851851852px; top: 180px; "><div class="planstep-bar" title="mover fabrica2 puerto tren, Start: 0.0100 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover fabrica2 puerto tren </div>
        <div class="planstep" id="plan0step10" style="left: 203.7037037037037px; top: 200px; "><div class="planstep-bar" title="cargar tren puerto v1 contenedor4 e4, Start: 0.0110 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren puerto v1 contenedor4 e4 </div>
        <div class="planstep" id="plan0step11" style="left: 222.22222222222223px; top: 220px; "><div class="planstep-bar" title="mover puerto fabrica2 tren, Start: 0.0120 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover puerto fabrica2 tren </div>
        <div class="planstep" id="plan0step12" style="left: 240.74074074074076px; top: 240px; "><div class="planstep-bar" title="descargar tren fabrica2 v1 contenedor4 e3f2, Start: 0.0130 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren fabrica2 v1 contenedor4 e3f2 </div>
        <div class="planstep" id="plan0step13" style="left: 259.25925925925924px; top: 260px; "><div class="planstep-bar" title="cargar tren fabrica2 v1 contenedor4 e3f2, Start: 0.0140 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren fabrica2 v1 contenedor4 e3f2 </div>
        <div class="planstep" id="plan0step14" style="left: 277.77777777777777px; top: 280px; "><div class="planstep-bar" title="mover fabrica2 almacen tren, Start: 0.0150 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover fabrica2 almacen tren </div>
        <div class="planstep" id="plan0step15" style="left: 296.2962962962963px; top: 300px; "><div class="planstep-bar" title="descargar tren almacen v1 contenedor4 e1a, Start: 0.0160 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren almacen v1 contenedor4 e1a </div>
        <div class="planstep" id="plan0step16" style="left: 314.81481481481484px; top: 320px; "><div class="planstep-bar" title="mover almacen puerto tren, Start: 0.0170 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover almacen puerto tren </div>
        <div class="planstep" id="plan0step17" style="left: 333.33333333333337px; top: 340px; "><div class="planstep-bar" title="cargar tren puerto v1 contenedor3 e3, Start: 0.0180 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren puerto v1 contenedor3 e3 </div>
        <div class="planstep" id="plan0step18" style="left: 351.85185185185185px; top: 360px; "><div class="planstep-bar" title="mover puerto fabrica2 tren, Start: 0.0190 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover puerto fabrica2 tren </div>
        <div class="planstep" id="plan0step19" style="left: 370.3703703703704px; top: 380px; "><div class="planstep-bar" title="descargar tren fabrica2 v1 contenedor3 e3f2, Start: 0.0200 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren fabrica2 v1 contenedor3 e3f2 </div>
        <div class="planstep" id="plan0step20" style="left: 388.8888888888889px; top: 400px; "><div class="planstep-bar" title="cargar tren fabrica2 v1 contenedor3 e3f2, Start: 0.0210 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren fabrica2 v1 contenedor3 e3f2 </div>
        <div class="planstep" id="plan0step21" style="left: 407.4074074074074px; top: 420px; "><div class="planstep-bar" title="mover fabrica2 almacen tren, Start: 0.0220 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover fabrica2 almacen tren </div>
        <div class="planstep" id="plan0step22" style="left: 425.9259259259259px; top: 440px; "><div class="planstep-bar" title="descargar tren almacen v1 contenedor3 e2a, Start: 0.0230 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren almacen v1 contenedor3 e2a </div>
        <div class="planstep" id="plan0step23" style="left: 444.44444444444446px; top: 460px; "><div class="planstep-bar" title="mover almacen puerto tren, Start: 0.0240 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover almacen puerto tren </div>
        <div class="planstep" id="plan0step24" style="left: 462.96296296296305px; top: 480px; "><div class="planstep-bar" title="cargar tren puerto v1 contenedor2 e2, Start: 0.0250 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren puerto v1 contenedor2 e2 </div>
        <div class="planstep" id="plan0step25" style="left: 481.4814814814815px; top: 500px; "><div class="planstep-bar" title="mover puerto fabrica2 tren, Start: 0.0260 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover puerto fabrica2 tren </div>
        <div class="planstep" id="plan0step26" style="left: 500px; top: 520px; "><div class="planstep-bar" title="descargar tren fabrica2 v1 contenedor2 e3f2, Start: 0.0270 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren fabrica2 v1 contenedor2 e3f2 </div>
        <div class="planstep" id="plan0step27" style="left: 518.5185185185185px; top: 540px; "><div class="planstep-bar" title="cargar tren fabrica2 v1 contenedor2 e3f2, Start: 0.0280 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren fabrica2 v1 contenedor2 e3f2 </div>
        <div class="planstep" id="plan0step28" style="left: 537.0370370370371px; top: 560px; "><div class="planstep-bar" title="mover fabrica2 almacen tren, Start: 0.0290 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover fabrica2 almacen tren </div>
        <div class="planstep" id="plan0step29" style="left: 555.5555555555555px; top: 580px; "><div class="planstep-bar" title="descargar tren almacen v1 contenedor2 e3a, Start: 0.0300 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren almacen v1 contenedor2 e3a </div>
        <div class="planstep" id="plan0step30" style="left: 574.074074074074px; top: 600px; "><div class="planstep-bar" title="mover almacen fabrica2 tren, Start: 0.0310 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover almacen fabrica2 tren </div>
        <div class="planstep" id="plan0step31" style="left: 592.5925925925926px; top: 620px; "><div class="planstep-bar" title="cargar tren fabrica2 v4 contenedor5 e2f2, Start: 0.0320 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren fabrica2 v4 contenedor5 e2f2 </div>
        <div class="planstep" id="plan0step32" style="left: 611.1111111111112px; top: 640px; "><div class="planstep-bar" title="mover fabrica2 almacen tren, Start: 0.0330 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover fabrica2 almacen tren </div>
        <div class="planstep" id="plan0step33" style="left: 629.6296296296297px; top: 660px; "><div class="planstep-bar" title="descargar tren almacen v4 contenedor5 e3a, Start: 0.0340 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren almacen v4 contenedor5 e3a </div>
        <div class="planstep" id="plan0step34" style="left: 648.1481481481483px; top: 680px; "><div class="planstep-bar" title="mover almacen fabrica2 tren, Start: 0.0350 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover almacen fabrica2 tren </div>
        <div class="planstep" id="plan0step35" style="left: 666.6666666666667px; top: 700px; "><div class="planstep-bar" title="descargar tren fabrica2 v2 contenedor7 e2f2, Start: 0.0360 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren fabrica2 v2 contenedor7 e2f2 </div>
        <div class="planstep" id="plan0step36" style="left: 685.1851851851851px; top: 720px; "><div class="planstep-bar" title="cargar tren fabrica2 v2 contenedor6 e1f2, Start: 0.0370 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren fabrica2 v2 contenedor6 e1f2 </div>
        <div class="planstep" id="plan0step37" style="left: 703.7037037037037px; top: 740px; "><div class="planstep-bar" title="cargar tren fabrica2 v4 contenedor7 e2f2, Start: 0.0380 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren fabrica2 v4 contenedor7 e2f2 </div>
        <div class="planstep" id="plan0step38" style="left: 722.2222222222222px; top: 760px; "><div class="planstep-bar" title="mover fabrica2 almacen tren, Start: 0.0390 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover fabrica2 almacen tren </div>
        <div class="planstep" id="plan0step39" style="left: 740.7407407407408px; top: 780px; "><div class="planstep-bar" title="descargar tren almacen v4 contenedor7 e3a, Start: 0.0400 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren almacen v4 contenedor7 e3a </div>
        <div class="planstep" id="plan0step40" style="left: 759.2592592592594px; top: 800px; "><div class="planstep-bar" title="mover almacen puerto tren, Start: 0.0410 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover almacen puerto tren </div>
        <div class="planstep" id="plan0step41" style="left: 777.7777777777778px; top: 820px; "><div class="planstep-bar" title="cargar tren puerto v1 contenedor1 e1, Start: 0.0420 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren puerto v1 contenedor1 e1 </div>
        <div class="planstep" id="plan0step42" style="left: 796.2962962962964px; top: 840px; "><div class="planstep-bar" title="mover puerto almacen tren, Start: 0.0430 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover puerto almacen tren </div>
        <div class="planstep" id="plan0step43" style="left: 814.8148148148148px; top: 860px; "><div class="planstep-bar" title="descargar tren almacen v2 contenedor6 e3a, Start: 0.0440 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren almacen v2 contenedor6 e3a </div>
        <div class="planstep" id="plan0step44" style="left: 833.3333333333333px; top: 880px; "><div class="planstep-bar" title="mover almacen fabrica2 tren, Start: 0.0450 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover almacen fabrica2 tren </div>
        <div class="planstep" id="plan0step45" style="left: 851.8518518518518px; top: 900px; "><div class="planstep-bar" title="descargar tren fabrica2 v3 contenedor8 e1f2, Start: 0.0460 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren fabrica2 v3 contenedor8 e1f2 </div>
        <div class="planstep" id="plan0step46" style="left: 870.3703703703703px; top: 920px; "><div class="planstep-bar" title="cargar tren fabrica2 v2 contenedor8 e1f2, Start: 0.0470 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren fabrica2 v2 contenedor8 e1f2 </div>
        <div class="planstep" id="plan0step47" style="left: 888.8888888888889px; top: 940px; "><div class="planstep-bar" title="mover fabrica2 almacen tren, Start: 0.0480 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover fabrica2 almacen tren </div>
        <div class="planstep" id="plan0step48" style="left: 907.4074074074074px; top: 960px; "><div class="planstep-bar" title="descargar tren almacen v2 contenedor8 e2a, Start: 0.0490 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren almacen v2 contenedor8 e2a </div>
        <div class="planstep" id="plan0step49" style="left: 925.9259259259261px; top: 980px; "><div class="planstep-bar" title="mover almacen fabrica2 tren, Start: 0.0500 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover almacen fabrica2 tren </div>
        <div class="planstep" id="plan0step50" style="left: 944.4444444444446px; top: 1000px; "><div class="planstep-bar" title="descargar tren fabrica2 v1 contenedor1 e1f2, Start: 0.0510 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren fabrica2 v1 contenedor1 e1f2 </div>
        <div class="planstep" id="plan0step51" style="left: 962.962962962963px; top: 1020px; "><div class="planstep-bar" title="cargar tren fabrica2 v3 contenedor1 e1f2, Start: 0.0520 " style="width: 18.51851851851852px; background-color: #ff0000"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>cargar tren fabrica2 v3 contenedor1 e1f2 </div>
        <div class="planstep" id="plan0step52" style="left: 981.4814814814815px; top: 1040px; "><div class="planstep-bar" title="mover fabrica2 almacen tren, Start: 0.0530 " style="width: 18.51851851851852px; background-color: #40ff00"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>mover fabrica2 almacen tren </div>
        <div class="planstep" id="plan0step53" style="left: 1000px; top: 1060px; "><div class="planstep-bar" title="descargar tren almacen v3 contenedor1 e2a, Start: 0.0540 " style="width: 18.51851851851852px; background-color: #0080ff"></div><div class="planstep-bar-relaxed whitecarbon" style="width: 0px;"></div>descargar tren almacen v3 contenedor1 e2a </div>

        </div>
    <div class="resourceUtilization" plan="0" style="display: block;">
        <table>
            <tbody><tr>
                <th>lugar</th>
                <th style="width: 1000px"></th>
            </tr>
            <tr>
                <td class="objectName"><div>fabrica1</div></td>
                <td style="position: relative; height: 0px;">

                </td>
            </tr>

            <tr>
                <td class="objectName"><div>fabrica2</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 74.07407407407408px; width: 18.51851851851852px; top: 1px;">mover puerto @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0040</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 92.5925925925926px; width: 18.51851851851852px; top: 21px;">descargar tren @ v1 contenedor6 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor6 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0050</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 111.11111111111111px; width: 18.51851851851852px; top: 1px;">mover @ puerto tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0060</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 148.14814814814815px; width: 18.51851851851852px; top: 1px;">mover puerto @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0080</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 166.66666666666669px; width: 18.51851851851852px; top: 21px;">descargar tren @ v1 contenedor5 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor5 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0090</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 185.1851851851852px; width: 18.51851851851852px; top: 1px;">mover @ puerto tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0100</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 222.22222222222223px; width: 18.51851851851852px; top: 1px;">mover puerto @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0120</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 240.74074074074076px; width: 18.51851851851852px; top: 21px;">descargar tren @ v1 contenedor4 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor4 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0130</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 259.25925925925924px; width: 18.51851851851852px; top: 1px;">cargar tren @ v1 contenedor4 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor4 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0140</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 277.77777777777777px; width: 18.51851851851852px; top: 21px;">mover @ almacen tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0150</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 351.85185185185185px; width: 18.51851851851852px; top: 1px;">mover puerto @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0190</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 370.3703703703704px; width: 18.51851851851852px; top: 21px;">descargar tren @ v1 contenedor3 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor3 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0200</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 388.8888888888889px; width: 18.51851851851852px; top: 1px;">cargar tren @ v1 contenedor3 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor3 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0210</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 407.4074074074074px; width: 18.51851851851852px; top: 21px;">mover @ almacen tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0220</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 481.4814814814815px; width: 18.51851851851852px; top: 1px;">mover puerto @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0260</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 500px; width: 18.51851851851852px; top: 21px;">descargar tren @ v1 contenedor2 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor2 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0270</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 518.5185185185185px; width: 18.51851851851852px; top: 1px;">cargar tren @ v1 contenedor2 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor2 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0280</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 537.0370370370371px; width: 18.51851851851852px; top: 21px;">mover @ almacen tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0290</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 574.074074074074px; width: 18.51851851851852px; top: 1px;">mover almacen @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0310</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 592.5925925925926px; width: 18.51851851851852px; top: 21px;">cargar tren @ v4 contenedor5 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v4 contenedor5 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0320</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 611.1111111111112px; width: 18.51851851851852px; top: 1px;">mover @ almacen tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0330</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 648.1481481481483px; width: 18.51851851851852px; top: 1px;">mover almacen @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0350</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 666.6666666666667px; width: 18.51851851851852px; top: 21px;">descargar tren @ v2 contenedor7 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v2 contenedor7 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0360</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 685.1851851851851px; width: 18.51851851851852px; top: 1px;">cargar tren @ v2 contenedor6 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v2 contenedor6 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0370</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 703.7037037037037px; width: 18.51851851851852px; top: 21px;">cargar tren @ v4 contenedor7 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v4 contenedor7 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0380</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 722.2222222222222px; width: 18.51851851851852px; top: 1px;">mover @ almacen tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0390</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 833.3333333333333px; width: 18.51851851851852px; top: 1px;">mover almacen @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0450</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 851.8518518518518px; width: 18.51851851851852px; top: 21px;">descargar tren @ v3 contenedor8 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v3 contenedor8 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0460</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 870.3703703703703px; width: 18.51851851851852px; top: 1px;">cargar tren @ v2 contenedor8 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v2 contenedor8 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0470</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 888.8888888888889px; width: 18.51851851851852px; top: 21px;">mover @ almacen tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0480</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 925.9259259259261px; width: 18.51851851851852px; top: 1px;">mover almacen @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0500</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 944.4444444444446px; width: 18.51851851851852px; top: 21px;">descargar tren @ v1 contenedor1 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor1 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0510</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 962.962962962963px; width: 18.51851851851852px; top: 1px;">cargar tren @ v3 contenedor1 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v3 contenedor1 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0520</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 981.4814814814815px; width: 18.51851851851852px; top: 21px;">mover @ almacen tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0530</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>puerto</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 18.51851851851852px; width: 18.51851851851852px; top: 1px;">cargar tren @ v3 contenedor8 e8<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v3 contenedor8 e8</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0010</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 37.03703703703704px; width: 18.51851851851852px; top: 21px;">cargar tren @ v2 contenedor7 e7<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v2 contenedor7 e7</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0020</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 55.55555555555556px; width: 18.51851851851852px; top: 1px;">cargar tren @ v1 contenedor6 e6<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor6 e6</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0030</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 74.07407407407408px; width: 18.51851851851852px; top: 21px;">mover @ fabrica2 tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0040</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 111.11111111111111px; width: 18.51851851851852px; top: 1px;">mover fabrica2 @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0060</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 129.62962962962962px; width: 18.51851851851852px; top: 21px;">cargar tren @ v1 contenedor5 e5<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor5 e5</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0070</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 148.14814814814815px; width: 18.51851851851852px; top: 1px;">mover @ fabrica2 tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0080</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 185.1851851851852px; width: 18.51851851851852px; top: 1px;">mover fabrica2 @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0100</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 203.7037037037037px; width: 18.51851851851852px; top: 21px;">cargar tren @ v1 contenedor4 e4<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor4 e4</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0110</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 222.22222222222223px; width: 18.51851851851852px; top: 1px;">mover @ fabrica2 tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0120</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 314.81481481481484px; width: 18.51851851851852px; top: 1px;">mover almacen @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0170</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 333.33333333333337px; width: 18.51851851851852px; top: 21px;">cargar tren @ v1 contenedor3 e3<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor3 e3</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0180</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 351.85185185185185px; width: 18.51851851851852px; top: 1px;">mover @ fabrica2 tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0190</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 444.44444444444446px; width: 18.51851851851852px; top: 1px;">mover almacen @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0240</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 462.96296296296305px; width: 18.51851851851852px; top: 21px;">cargar tren @ v1 contenedor2 e2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor2 e2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0250</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 481.4814814814815px; width: 18.51851851851852px; top: 1px;">mover @ fabrica2 tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0260</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 759.2592592592594px; width: 18.51851851851852px; top: 1px;">mover almacen @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0410</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 777.7777777777778px; width: 18.51851851851852px; top: 21px;">cargar tren @ v1 contenedor1 e1<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor1 e1</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0420</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 796.2962962962964px; width: 18.51851851851852px; top: 1px;">mover @ almacen tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0430</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>almacen</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 277.77777777777777px; width: 18.51851851851852px; top: 1px;">mover fabrica2 @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0150</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 296.2962962962963px; width: 18.51851851851852px; top: 21px;">descargar tren @ v1 contenedor4 e1a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor4 e1a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0160</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 314.81481481481484px; width: 18.51851851851852px; top: 1px;">mover @ puerto tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0170</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 407.4074074074074px; width: 18.51851851851852px; top: 1px;">mover fabrica2 @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0220</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 425.9259259259259px; width: 18.51851851851852px; top: 21px;">descargar tren @ v1 contenedor3 e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor3 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0230</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 444.44444444444446px; width: 18.51851851851852px; top: 1px;">mover @ puerto tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0240</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 537.0370370370371px; width: 18.51851851851852px; top: 1px;">mover fabrica2 @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0290</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 555.5555555555555px; width: 18.51851851851852px; top: 21px;">descargar tren @ v1 contenedor2 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor2 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0300</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 574.074074074074px; width: 18.51851851851852px; top: 1px;">mover @ fabrica2 tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0310</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 611.1111111111112px; width: 18.51851851851852px; top: 1px;">mover fabrica2 @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0330</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 629.6296296296297px; width: 18.51851851851852px; top: 21px;">descargar tren @ v4 contenedor5 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v4 contenedor5 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0340</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 648.1481481481483px; width: 18.51851851851852px; top: 1px;">mover @ fabrica2 tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0350</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 722.2222222222222px; width: 18.51851851851852px; top: 1px;">mover fabrica2 @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0390</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 740.7407407407408px; width: 18.51851851851852px; top: 21px;">descargar tren @ v4 contenedor7 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v4 contenedor7 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0400</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 759.2592592592594px; width: 18.51851851851852px; top: 1px;">mover @ puerto tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0410</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 796.2962962962964px; width: 18.51851851851852px; top: 1px;">mover puerto @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0430</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 814.8148148148148px; width: 18.51851851851852px; top: 21px;">descargar tren @ v2 contenedor6 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v2 contenedor6 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0440</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 833.3333333333333px; width: 18.51851851851852px; top: 1px;">mover @ fabrica2 tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0450</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 888.8888888888889px; width: 18.51851851851852px; top: 1px;">mover fabrica2 @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0480</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 907.4074074074074px; width: 18.51851851851852px; top: 21px;">descargar tren @ v2 contenedor8 e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v2 contenedor8 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0490</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 925.9259259259261px; width: 18.51851851851852px; top: 1px;">mover @ fabrica2 tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0500</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 981.4814814814815px; width: 18.51851851851852px; top: 1px;">mover fabrica2 @ tren<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0530</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 1000px; width: 18.51851851851852px; top: 21px;">descargar tren @ v3 contenedor1 e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v3 contenedor1 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0540</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <th>contenedor</th>
                <th style="width: 1000px"></th>
            </tr>
            <tr>
                <td class="objectName"><div>contenedor1</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 777.7777777777778px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 @ e1<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor1 e1</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0420</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 944.4444444444446px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 @ e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor1 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0510</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 962.962962962963px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 v3 @ e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v3 contenedor1 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0520</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 1000px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v3 @ e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v3 contenedor1 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0540</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>contenedor2</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 462.96296296296305px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 @ e2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor2 e2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0250</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 500px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 @ e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor2 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0270</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 518.5185185185185px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 v1 @ e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor2 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0280</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 555.5555555555555px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v1 @ e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor2 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0300</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>contenedor3</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 333.33333333333337px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 @ e3<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor3 e3</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0180</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 370.3703703703704px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 @ e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor3 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0200</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 388.8888888888889px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 v1 @ e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor3 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0210</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 425.9259259259259px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v1 @ e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor3 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0230</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>contenedor4</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 203.7037037037037px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 @ e4<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor4 e4</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0110</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 240.74074074074076px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 @ e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor4 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0130</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 259.25925925925924px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 v1 @ e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor4 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0140</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 296.2962962962963px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v1 @ e1a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor4 e1a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0160</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>contenedor5</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 129.62962962962962px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 @ e5<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor5 e5</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0070</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 166.66666666666669px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 @ e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor5 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0090</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 592.5925925925926px; width: 18.51851851851852px; top: 1px;">cargar tren fabrica2 v4 @ e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v4 contenedor5 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0320</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 629.6296296296297px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v4 @ e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v4 contenedor5 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0340</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>contenedor6</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 55.55555555555556px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 @ e6<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor6 e6</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0030</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 92.5925925925926px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 @ e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor6 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0050</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 685.1851851851851px; width: 18.51851851851852px; top: 1px;">cargar tren fabrica2 v2 @ e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v2 contenedor6 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0370</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 814.8148148148148px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v2 @ e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v2 contenedor6 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0440</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>contenedor7</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 37.03703703703704px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v2 @ e7<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v2 contenedor7 e7</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0020</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 666.6666666666667px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v2 @ e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v2 contenedor7 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0360</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 703.7037037037037px; width: 18.51851851851852px; top: 1px;">cargar tren fabrica2 v4 @ e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v4 contenedor7 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0380</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 740.7407407407408px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v4 @ e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v4 contenedor7 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0400</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>contenedor8</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 18.51851851851852px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v3 @ e8<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v3 contenedor8 e8</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0010</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 851.8518518518518px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v3 @ e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v3 contenedor8 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0460</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 870.3703703703703px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 v2 @ e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v2 contenedor8 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0470</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 907.4074074074074px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v2 @ e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v2 contenedor8 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0490</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <th>espacio</th>
                <th style="width: 1000px"></th>
            </tr>
            <tr>
                <td class="objectName"><div>e1</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 777.7777777777778px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 contenedor1 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor1 e1</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0420</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e2</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 462.96296296296305px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 contenedor2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor2 e2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0250</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e3</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 333.33333333333337px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 contenedor3 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor3 e3</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0180</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e4</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 203.7037037037037px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 contenedor4 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor4 e4</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0110</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e5</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 129.62962962962962px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 contenedor5 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor5 e5</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0070</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e6</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 55.55555555555556px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v1 contenedor6 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor6 e6</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0030</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e7</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 37.03703703703704px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v2 contenedor7 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v2 contenedor7 e7</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0020</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e8</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 18.51851851851852px; width: 18.51851851851852px; top: 1px;">cargar tren puerto v3 contenedor8 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v3 contenedor8 e8</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0010</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e1f1</div></td>
                <td style="position: relative; height: 0px;">

                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e2f1</div></td>
                <td style="position: relative; height: 0px;">

                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e1f2</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 92.5925925925926px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 contenedor6 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor6 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0050</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 685.1851851851851px; width: 18.51851851851852px; top: 1px;">cargar tren fabrica2 v2 contenedor6 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v2 contenedor6 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0370</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 851.8518518518518px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v3 contenedor8 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v3 contenedor8 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0460</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 870.3703703703703px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 v2 contenedor8 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v2 contenedor8 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0470</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 944.4444444444446px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 contenedor1 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor1 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0510</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 962.962962962963px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 v3 contenedor1 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v3 contenedor1 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0520</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e2f2</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 166.66666666666669px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 contenedor5 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor5 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0090</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 592.5925925925926px; width: 18.51851851851852px; top: 1px;">cargar tren fabrica2 v4 contenedor5 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v4 contenedor5 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0320</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 666.6666666666667px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v2 contenedor7 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v2 contenedor7 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0360</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 703.7037037037037px; width: 18.51851851851852px; top: 1px;">cargar tren fabrica2 v4 contenedor7 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v4 contenedor7 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0380</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e3f2</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 240.74074074074076px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 contenedor4 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor4 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0130</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 259.25925925925924px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 v1 contenedor4 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor4 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0140</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 370.3703703703704px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 contenedor3 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor3 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0200</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 388.8888888888889px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 v1 contenedor3 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor3 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0210</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 500px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 v1 contenedor2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor2 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0270</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 518.5185185185185px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 v1 contenedor2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor2 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0280</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e1a</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 296.2962962962963px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v1 contenedor4 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor4 e1a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0160</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e2a</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 425.9259259259259px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v1 contenedor3 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor3 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0230</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 907.4074074074074px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v2 contenedor8 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v2 contenedor8 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0490</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 1000px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v3 contenedor1 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v3 contenedor1 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0540</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>e3a</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 555.5555555555555px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v1 contenedor2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor2 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0300</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 629.6296296296297px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v4 contenedor5 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v4 contenedor5 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0340</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 740.7407407407408px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v4 contenedor7 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v4 contenedor7 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0400</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 814.8148148148148px; width: 18.51851851851852px; top: 1px;">descargar tren almacen v2 contenedor6 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v2 contenedor6 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0440</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <th>vagon</th>
                <th style="width: 1000px"></th>
            </tr>
            <tr>
                <td class="objectName"><div>v1</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 55.55555555555556px; width: 18.51851851851852px; top: 1px;">cargar tren puerto @ contenedor6 e6<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor6 e6</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0030</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 92.5925925925926px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 @ contenedor6 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor6 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0050</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 129.62962962962962px; width: 18.51851851851852px; top: 1px;">cargar tren puerto @ contenedor5 e5<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor5 e5</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0070</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 166.66666666666669px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 @ contenedor5 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor5 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0090</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 203.7037037037037px; width: 18.51851851851852px; top: 1px;">cargar tren puerto @ contenedor4 e4<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor4 e4</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0110</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 240.74074074074076px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 @ contenedor4 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor4 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0130</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 259.25925925925924px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 @ contenedor4 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor4 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0140</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 296.2962962962963px; width: 18.51851851851852px; top: 1px;">descargar tren almacen @ contenedor4 e1a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor4 e1a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0160</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 333.33333333333337px; width: 18.51851851851852px; top: 1px;">cargar tren puerto @ contenedor3 e3<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor3 e3</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0180</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 370.3703703703704px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 @ contenedor3 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor3 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0200</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 388.8888888888889px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 @ contenedor3 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor3 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0210</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 425.9259259259259px; width: 18.51851851851852px; top: 1px;">descargar tren almacen @ contenedor3 e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor3 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0230</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 462.96296296296305px; width: 18.51851851851852px; top: 1px;">cargar tren puerto @ contenedor2 e2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor2 e2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0250</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 500px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 @ contenedor2 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor2 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0270</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 518.5185185185185px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 @ contenedor2 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor2 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0280</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 555.5555555555555px; width: 18.51851851851852px; top: 1px;">descargar tren almacen @ contenedor2 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor2 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0300</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 777.7777777777778px; width: 18.51851851851852px; top: 1px;">cargar tren puerto @ contenedor1 e1<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor1 e1</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0420</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 944.4444444444446px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 @ contenedor1 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor1 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0510</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>v2</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 37.03703703703704px; width: 18.51851851851852px; top: 1px;">cargar tren puerto @ contenedor7 e7<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v2 contenedor7 e7</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0020</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 666.6666666666667px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 @ contenedor7 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v2 contenedor7 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0360</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 685.1851851851851px; width: 18.51851851851852px; top: 21px;">cargar tren fabrica2 @ contenedor6 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v2 contenedor6 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0370</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 814.8148148148148px; width: 18.51851851851852px; top: 1px;">descargar tren almacen @ contenedor6 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v2 contenedor6 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0440</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 870.3703703703703px; width: 18.51851851851852px; top: 1px;">cargar tren fabrica2 @ contenedor8 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v2 contenedor8 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0470</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 907.4074074074074px; width: 18.51851851851852px; top: 1px;">descargar tren almacen @ contenedor8 e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v2 contenedor8 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0490</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>v3</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 18.51851851851852px; width: 18.51851851851852px; top: 1px;">cargar tren puerto @ contenedor8 e8<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v3 contenedor8 e8</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0010</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 851.8518518518518px; width: 18.51851851851852px; top: 1px;">descargar tren fabrica2 @ contenedor8 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v3 contenedor8 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0460</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 962.962962962963px; width: 18.51851851851852px; top: 1px;">cargar tren fabrica2 @ contenedor1 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v3 contenedor1 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0520</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 1000px; width: 18.51851851851852px; top: 1px;">descargar tren almacen @ contenedor1 e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v3 contenedor1 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0540</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <td class="objectName"><div>v4</div></td>
                <td style="position: relative; height: 20px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 592.5925925925926px; width: 18.51851851851852px; top: 1px;">cargar tren fabrica2 @ contenedor5 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v4 contenedor5 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0320</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 629.6296296296297px; width: 18.51851851851852px; top: 1px;">descargar tren almacen @ contenedor5 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v4 contenedor5 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0340</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 703.7037037037037px; width: 18.51851851851852px; top: 1px;">cargar tren fabrica2 @ contenedor7 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v4 contenedor7 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0380</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 740.7407407407408px; width: 18.51851851851852px; top: 1px;">descargar tren almacen @ contenedor7 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v4 contenedor7 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0400</td></tr></tbody></table></span></div>
                </td>
            </tr>

            <tr>
                <th>tren</th>
                <th style="width: 1000px"></th>
            </tr>
            <tr>
                <td class="objectName"><div>tren</div></td>
                <td style="position: relative; height: 40px;">

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 18.51851851851852px; width: 18.51851851851852px; top: 1px;">cargar @ puerto v3 contenedor8 e8<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v3 contenedor8 e8</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0010</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 37.03703703703704px; width: 18.51851851851852px; top: 21px;">cargar @ puerto v2 contenedor7 e7<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v2 contenedor7 e7</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0020</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 55.55555555555556px; width: 18.51851851851852px; top: 1px;">cargar @ puerto v1 contenedor6 e6<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor6 e6</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0030</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 74.07407407407408px; width: 18.51851851851852px; top: 21px;">mover puerto fabrica2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0040</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 92.5925925925926px; width: 18.51851851851852px; top: 1px;">descargar @ fabrica2 v1 contenedor6 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor6 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0050</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 111.11111111111111px; width: 18.51851851851852px; top: 21px;">mover fabrica2 puerto @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0060</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 129.62962962962962px; width: 18.51851851851852px; top: 1px;">cargar @ puerto v1 contenedor5 e5<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor5 e5</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0070</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 148.14814814814815px; width: 18.51851851851852px; top: 21px;">mover puerto fabrica2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0080</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 166.66666666666669px; width: 18.51851851851852px; top: 1px;">descargar @ fabrica2 v1 contenedor5 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor5 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0090</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 185.1851851851852px; width: 18.51851851851852px; top: 21px;">mover fabrica2 puerto @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0100</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 203.7037037037037px; width: 18.51851851851852px; top: 1px;">cargar @ puerto v1 contenedor4 e4<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor4 e4</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0110</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 222.22222222222223px; width: 18.51851851851852px; top: 21px;">mover puerto fabrica2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0120</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 240.74074074074076px; width: 18.51851851851852px; top: 1px;">descargar @ fabrica2 v1 contenedor4 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor4 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0130</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 259.25925925925924px; width: 18.51851851851852px; top: 21px;">cargar @ fabrica2 v1 contenedor4 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor4 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0140</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 277.77777777777777px; width: 18.51851851851852px; top: 1px;">mover fabrica2 almacen @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0150</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 296.2962962962963px; width: 18.51851851851852px; top: 21px;">descargar @ almacen v1 contenedor4 e1a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor4 e1a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0160</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 314.81481481481484px; width: 18.51851851851852px; top: 1px;">mover almacen puerto @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0170</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 333.33333333333337px; width: 18.51851851851852px; top: 21px;">cargar @ puerto v1 contenedor3 e3<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor3 e3</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0180</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 351.85185185185185px; width: 18.51851851851852px; top: 1px;">mover puerto fabrica2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0190</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 370.3703703703704px; width: 18.51851851851852px; top: 21px;">descargar @ fabrica2 v1 contenedor3 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor3 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0200</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 388.8888888888889px; width: 18.51851851851852px; top: 1px;">cargar @ fabrica2 v1 contenedor3 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor3 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0210</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 407.4074074074074px; width: 18.51851851851852px; top: 21px;">mover fabrica2 almacen @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0220</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 425.9259259259259px; width: 18.51851851851852px; top: 1px;">descargar @ almacen v1 contenedor3 e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor3 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0230</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 444.44444444444446px; width: 18.51851851851852px; top: 21px;">mover almacen puerto @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0240</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 462.96296296296305px; width: 18.51851851851852px; top: 1px;">cargar @ puerto v1 contenedor2 e2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor2 e2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0250</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 481.4814814814815px; width: 18.51851851851852px; top: 21px;">mover puerto fabrica2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0260</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 500px; width: 18.51851851851852px; top: 1px;">descargar @ fabrica2 v1 contenedor2 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor2 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0270</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 518.5185185185185px; width: 18.51851851851852px; top: 21px;">cargar @ fabrica2 v1 contenedor2 e3f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v1 contenedor2 e3f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0280</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 537.0370370370371px; width: 18.51851851851852px; top: 1px;">mover fabrica2 almacen @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0290</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 555.5555555555555px; width: 18.51851851851852px; top: 21px;">descargar @ almacen v1 contenedor2 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v1 contenedor2 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0300</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 574.074074074074px; width: 18.51851851851852px; top: 1px;">mover almacen fabrica2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0310</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 592.5925925925926px; width: 18.51851851851852px; top: 21px;">cargar @ fabrica2 v4 contenedor5 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v4 contenedor5 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0320</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 611.1111111111112px; width: 18.51851851851852px; top: 1px;">mover fabrica2 almacen @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0330</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 629.6296296296297px; width: 18.51851851851852px; top: 21px;">descargar @ almacen v4 contenedor5 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v4 contenedor5 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0340</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 648.1481481481483px; width: 18.51851851851852px; top: 1px;">mover almacen fabrica2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0350</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 666.6666666666667px; width: 18.51851851851852px; top: 21px;">descargar @ fabrica2 v2 contenedor7 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v2 contenedor7 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0360</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 685.1851851851851px; width: 18.51851851851852px; top: 1px;">cargar @ fabrica2 v2 contenedor6 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v2 contenedor6 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0370</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 703.7037037037037px; width: 18.51851851851852px; top: 21px;">cargar @ fabrica2 v4 contenedor7 e2f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v4 contenedor7 e2f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0380</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 722.2222222222222px; width: 18.51851851851852px; top: 1px;">mover fabrica2 almacen @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0390</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 740.7407407407408px; width: 18.51851851851852px; top: 21px;">descargar @ almacen v4 contenedor7 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v4 contenedor7 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0400</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 759.2592592592594px; width: 18.51851851851852px; top: 1px;">mover almacen puerto @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen puerto tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0410</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 777.7777777777778px; width: 18.51851851851852px; top: 21px;">cargar @ puerto v1 contenedor1 e1<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren puerto v1 contenedor1 e1</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0420</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 796.2962962962964px; width: 18.51851851851852px; top: 1px;">mover puerto almacen @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover puerto almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0430</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 814.8148148148148px; width: 18.51851851851852px; top: 21px;">descargar @ almacen v2 contenedor6 e3a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v2 contenedor6 e3a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0440</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 833.3333333333333px; width: 18.51851851851852px; top: 1px;">mover almacen fabrica2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0450</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 851.8518518518518px; width: 18.51851851851852px; top: 21px;">descargar @ fabrica2 v3 contenedor8 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v3 contenedor8 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0460</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 870.3703703703703px; width: 18.51851851851852px; top: 1px;">cargar @ fabrica2 v2 contenedor8 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v2 contenedor8 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0470</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 888.8888888888889px; width: 18.51851851851852px; top: 21px;">mover fabrica2 almacen @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0480</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 907.4074074074074px; width: 18.51851851851852px; top: 1px;">descargar @ almacen v2 contenedor8 e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v2 contenedor8 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0490</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 925.9259259259261px; width: 18.51851851851852px; top: 21px;">mover almacen fabrica2 @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover almacen fabrica2 tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0500</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 944.4444444444446px; width: 18.51851851851852px; top: 1px;">descargar @ fabrica2 v1 contenedor1 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren fabrica2 v1 contenedor1 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0510</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #ff0000; left: 962.962962962963px; width: 18.51851851851852px; top: 21px;">cargar @ fabrica2 v3 contenedor1 e1f2<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">cargar tren fabrica2 v3 contenedor1 e1f2</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0520</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #40ff00; left: 981.4814814814815px; width: 18.51851851851852px; top: 1px;">mover fabrica2 almacen @<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">mover fabrica2 almacen tren</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0530</td></tr></tbody></table></span></div>

                    <div class="resourceTaskTooltip" style="background-color: #0080ff; left: 1000px; width: 18.51851851851852px; top: 21px;">descargar @ almacen v3 contenedor1 e2a<span class="resourceTaskTooltipText"><table><tbody><tr><th colspan="2" class="actionToolTip">descargar tren almacen v3 contenedor1 e2a</th></tr><tr><td class="actionToolTip" style="width:50px">Start:</td><td class="actionToolTip">0.0540</td></tr></tbody></table></span></div>
                </td>
            </tr>

        </tbody></table>
    </div>
    <div class="lineChart" plan="0" style="display: block;margin-top: 20px;">

    </div>

        <script>function drawPlan0Charts(){
}</script>

                <script>
                google.charts.setOnLoadCallback(drawCharts);
                function drawCharts() {
                    drawPlan0Charts();
                }
        </script>
        <script>mendeleyWebImporter = {
  downloadPdfs(e,t) { return this._call('downloadPdfs', [e,t]); },
  open() { return this._call('open', []); },
  setLoginToken(e) { return this._call('setLoginToken', [e]); },
  _call(methodName, methodArgs) {
    const id = Math.random();
    window.postMessage({ id, token: '0.9825923017065733', methodName, methodArgs }, 'null');
    return new Promise(resolve => {
      const listener = window.addEventListener('message', event => {
        const data = event.data;
        if (typeof data !== 'object' || !('result' in data) || data.id !== id) return;
        window.removeEventListener('message', listener);
        resolve(data.result);
      });
    });
  }
};</script></body></html>